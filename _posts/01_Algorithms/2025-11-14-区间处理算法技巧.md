---
title: "区间问题的通用解法：前缀优化与右端点枚举技巧"
categories: [01_Algorithms]
tags: [array, algorithm]

math: true
layout: post
---

区间处理 / 前缀优化，指的是在处理一段连续区间（如数组的一部分）时，**通过预处理前缀或后缀信息**，从而在后续枚举、转移或查询时快速得到结果，避免重复计算。

> 简单说：
> **“前缀存信息，右端点做枚举”**。
> 当我们遍历数组时，可以利用已经计算好的前缀数据，在 O(1) 或 O(log n) 时间内求出区间性质。

---

## 基本概念

区间问题通常涉及重复计算，比如：

* 计算某一段和、积、最大值；
* 判断某一段是否满足某种条件；
* 找到某段的最优答案。

而前缀优化的核心目标是：

> **避免每次都重新扫描区间**，转而通过「累积 + 差分」快速求解。

---

## 典型形式

| 技巧名               | 核心思想          | 常用场景                   |
| ----------------- |---------------| ---------------------- |
| **前缀和** | 前缀和数组实现区间累积   | 快速求区间和                 |
| **前缀最值**          | 记录当前为止的最小值/最大值 | 子数组最优问题       |
| **前缀积/前缀差分**      | 前缀乘积/差分思想     | 连乘、区间修改                |
| **后缀数组**          | 从右往左的前缀（即后缀）  | 双向组合问题                 |
| **前后缀分解**         | 将整体拆为左右两部分    | 乘积数组、左右最值等 |
| **枚举右端点**         | 固定右端点，用前缀信息得到左边结果 | 子区间问题、滑动窗口             |

---

## 典型例题解析

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```text
给定一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的子数组的个数。

子数组是数组中元素的连续非空序列。

示例 1：
输入：nums = [1,1,1], k = 2
输出：2

示例 2：
输入：nums = [1,2,3], k = 3
输出：2

提示：
1 <= nums.length <= 2 * 10^4
-1000 <= nums[i] <= 1000
-10^7 <= k <= 10^7
```

前置阅读，[前缀和数组](/posts/前缀和数组/)

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        ans = s = 0
        cnt = Counter()
        for x in nums:
            cnt[s] += 1
            s += x
            ans += cnt[s - k]
        return ans
```

> 连续区间求解 问题，用前缀优化 + 哈希表，把区间枚举从 O(n²) 优化成了 O(n)。

---

### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/description/)

```text
给你一个整数数组 nums，返回一个数组 answer，
其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

题目保证数组中任意前缀或后缀的乘积都在 32 位整数范围内。
请不要使用除法，且在 O(n) 时间复杂度内完成此题。

示例 1：
输入：nums = [1,2,3,4]
输出： [24,12,8,6]

示例 2：
输入：nums = [-1,1,0,-3,3]
输出： [0,0,9,0,0]

提示：
2 <= nums.length <= 10^5
-30 <= nums[i] <= 30
保证所有前缀积与后缀积在 32 位整数范围内
```

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        pre = [1] * n
        for i in range(1, n):
            pre[i] = pre[i - 1] * nums[i - 1]

        suf = [1] * n
        for i in range(n - 2, -1, -1):
            suf[i] = suf[i + 1] * nums[i + 1]

        return [p * s for p, s in zip(pre, suf)]
```

> 每个位置的结果 = 左侧积 × 右侧积。这就是典型的「前后缀分解」思想。

---

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

```text
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。

示例 2：
输入：nums = [1]
输出：1

示例 3：
输入：nums = [5,4,-1,7,8]
输出：23

提示：
1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
```

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        ans = -inf
        min_pre_sum = pre_sum = 0
        for x in nums:
            pre_sum += x  # 当前的前缀和
            ans = max(ans, pre_sum - min_pre_sum)  # 减去前缀和的最小值
            min_pre_sum = min(min_pre_sum, pre_sum)  # 维护前缀和的最小值
        return ans
```

> 通过记录「前缀最小和」，在枚举右端点时快速得到最优区间。

---

### [525. 连续数组](https://leetcode.cn/problems/contiguous-array/description/)

```text
给定一个二进制数组 nums ，请你找出一个长度最长的连续子数组，该子数组中包含相同数量的0和1。

示例 1：
输入：nums = [0,1,0]
输出：2
说明：[0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。

示例 2：
输入：nums = [0,1,1,1,1,1,0,0,0]
输出：6
解释：[1,1,1,0,0,0] 是具有相同数量 0 和 1 的最长连续子数组。

提示：
1 <= nums.length <= 10^5
nums[i] 不是 0 就是 1
```

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        # 把 0 当作 -1
        nums = [1 if x else -1 for x in nums]

        # 计算 nums 的前缀和
        s = list(accumulate(nums, initial=0))

        pos = {}
        ans = 0
        for i, x in enumerate(s):
            if x in pos:
                # 找到一对相等元素，下标分别为 pos[x] 和 i，距离为 i - pos[x]
                ans = max(ans, i - pos[x])
            else:
                pos[x] = i
        return ans
```

合并两个循环，把 `sum` 数组简化成一个变量 `s`。

上面代码的第二个循环，我们循环了 `n+1` 次（注意 `sum` 的长度是 `n+1`），而在下面的代码中，我们循环了 `n` 次。

少了那一次去哪了？我们单独处理了 `sum` 的第一个数。

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        # 前缀和数组的首项 0 相当于在 -1 下标
        pos = {0: -1}
        ans = s = 0
        for i, x in enumerate(nums):
            s += 1 if x else -1
            if s in pos:
                ans = max(ans, i - pos[s])
            else:
                pos[s] = i
        return ans
```

> 本质也是一个“找连续区间”的问题。0 和 1 数量相等 ⇒ 差值为 0 ⇒ 前缀优化。
> 解法仍然是：固定右端点 + 前缀和 + 哈希表查左端点

---

## 经典例题

| 题号   | 题目                                                                                                   | 标签                  |
| ---- | ---------------------------------------------------------------------------------------------------- |---------------------|
| 3739 | [统计主要元素子数组数目 II](https://leetcode.cn/problems/count-subarrays-with-majority-element-ii/description/) | 枚举右维护左 / 有序集合 / 提升题 |

---
