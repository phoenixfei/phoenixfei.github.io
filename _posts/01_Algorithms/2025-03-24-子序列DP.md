---
title: "动态规划全解：子序列DP全解"
categories: [01_Algorithms]
tags: [algorithm]

math: true
layout: post
---

在动态规划中，有一类问题看似不关心“连续”，却在悄悄考察**选择与不选择**的能力，这正是 **子序列 DP（Subsequence DP）** 的主战场。

---

## 基本概念

**什么是子序列**

给定序列：

$$
A = [a_1, a_2, \dots, a_n]
$$

**子序列（subsequence）** 指的是：

> 从原序列中删除若干（可以是 0 个）元素，**不改变相对顺序**，得到的新序列。

例如：

* $[1, 3, 5]$ 是 $[1, 2, 3, 4, 5]$ 的子序列，$[1, 5, 3]$ 不是（顺序改变）。

---

**子序列 DP 的核心思想**

子序列 DP 的本质是：

> **在“第 i 个位置”，做“选或不选（枚举选哪个）”的决策，并记录最优结果**

因此，子序列类 DP 通常具有以下特征：
* 状态往往与 **位置下标 `i`（或 `(i, j)`）** 有关
* 状态转移本质上体现了 **当前位置元素是否参与构成最优子序列**

---

下面是在**不改变原有结构与技术结论**的前提下，对这段内容做的 **表达优化版**：
目标是 **更严谨 + 更统一术语 + 更适合作为“子序列 DP 总结章节”**。

---

**核心：两种 DP 思路的选择。什么样的题目适合「选或不选」，什么样的题目适合「枚举选哪个」？**

这通常可以分为两类子序列问题：

1. **相邻无关子序列问题**（如：**0-1 背包**、**打家劫舍**）：
   * **策略**：适合「选或不选」。
   * **理由**：每个元素之间互相独立，或者限制条件非常简单，只需要依次考虑当前元素选还是不选即可。

2. **相邻相关子序列问题**（如：**本题 LIS**）：
   * **策略**：适合「枚举选哪个」。
   * **理由**：我们需要知道子序列中相邻两个数的大小关系。

---

## 通用状态设计

**一维 DP（固定结尾）**

常见于 LIS 等问题，状态含义通常为「**以第 `i` 个元素结尾**」。

$$
dp[i] = \text{使用 } a_i \text{ 作为结尾时的最优解}
$$

---

**二维 DP（前缀 + 额外状态）**

当子问题不仅与位置有关，还需要记录「数量 / 容量 / 额外约束」时，常引入第二维。

$$
dp[i][j] = \text{在前 } i \text{ 个元素中，状态为 } j \text{ 时的最优解}
$$

其中 `j` 可以表示：

* 已选择元素个数
* 某种容量或限制
* 某类中间状态

---

**计数型子序列 DP**

这类问题用于统计 **合法子序列的数量**，非常重要，且**常与前缀和、哈希、状态压缩等技巧结合出题**。

典型状态定义为：

$$
dp[i] = \text{以 } i \text{ 结尾的合法子序列个数}
$$

状态转移往往形如：

$$
dp[i] {+}{=} dp[j]
$$

其中 $j < i$ 且满足题目约束条件。

---

**与「线性 DP」的关系**

子序列 DP 本质上是 **线性 DP 的一个重要分支**。

二者的主要区别在于 **是否要求连续**：

| 类型     | 是否连续 | 典型转移形式                          |
| ------ | ---- | ------------------------------- |
| 线性 DP  | 连续   | $dp[i] \leftarrow dp[i-1]$      |
| 子序列 DP | 不连续  | $dp[i] \leftarrow dp[j], j < i$ |

子序列 DP 的状态转移 **更加“全局”**，但也因此具备较强的 **优化空间**。

---

**常见优化方向**

子序列 DP 的优化，本质在于 **减少「枚举前驱 `j`」的成本**：

* **能二分就二分，能按值就不按下标，能累加就不回头。**

| 优化方向         | 适用场景         | 核心思想                 | 典型复杂度变化                         | 代表问题              |
| ------------ | ------------ | -------------------- | ------------------------------- | ----------------- |
| **二分优化**     | 状态只关心“最优末尾值” | 用贪心维护最优结构，通过二分定位转移位置 | $O(n^2) \rightarrow O(n\log n)$ | 最长递增子序列（LIS）      |
| **值域离散化**    | 状态与“数值大小”强相关 | 将下标 DP 转为值域 DP，按值转移  | $O(n^2) \rightarrow O(n + V)$   | 按值转移的子序列问题        |
| **哈希 / 前缀和** | 子序列计数问题      | 累积历史状态，避免显式枚举前驱      | $O(n^2) \rightarrow O(n)$       | 不同子序列个数、和为 K 的子序列 |

> **子序列 DP 的核心难点在于转移“来自哪里”，而优化的关键在于减少枚举这些来源的成本。**

---

## 例题详解

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```text
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。

示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1

提示：
1 <= nums.length <= 2500
-10^4 <= nums[i] <= 10^4
```

**启发思考：寻找子问题**

我们要解决的是：在 $nums$ 中选择一些数字，组成一个严格递增的子序列，求其最大长度。

假设我们要计算以 $nums[i]$ 结尾的最长递增子序列的长度：

* 我们需要枚举所有在 $i$ 之前的下标 $j$（即 $j < i$）。
* 如果满足 $nums[j] < nums[i]$，那么 $nums[i]$ 就可以接在以 $nums[j]$ 结尾的递增子序列后面，长度变为 $f[j] + 1$。
* 如果找不到这样的 $j$，$nums[i]$ 也可以单独作为一个序列，长度为 $1$。

**状态定义与转移**

$dfs(i)$ 表示以 $nums[i]$ 结尾的最长递增子序列（LIS）的长度。

枚举子序列的倒数第二个数的下标 $j$ ，如果 $nums[j] < nums[i]$ ，那么有：
$$
dfs(i) = dfs(j) + 1
$$

---

**记忆话搜索**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        @cache
        def dfs(i: int) -> int:
            res = 0
            for j in range(i):
                if nums[j] < nums[i]:
                    res = max(res, dfs(j))
            return res + 1  # 加一提到循环外面

        return max(dfs(i) for i in range(len(nums)))
```

**1:1 转化为递推**

将 $dfs$ 改写为 $f$ 数组。$f[i]$ 的定义与 $dfs(i)$ 相同，表示以 $nums[i]$ 结尾的最长递增子序列（LIS）的长度。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        f = [0] * len(nums)
        for i, x in enumerate(nums):
            for j, y in enumerate(nums[:i]):
                if x > y:
                    f[i] = max(f[i], f[j])
            f[i] += 1
        return max(f)
```

---

**二分优化：贪心 + 二分**

为了进一步优化时间复杂度，我们观察：
如果有两个长度相同的递增子序列，比如：

* 子序列 A：$[2, 5]$（长度为 2，末尾是 5）
* 子序列 B：$[2, 3]$（长度为 2，末尾是 3）

显然，子序列 B 的潜力更大，因为它的结尾数字更小，后面更容易接上其他数字。

**核心思想**：对于同样长度的递增子序列，末尾元素越小，后面接上新数字的可能性就越大（潜力更强）。

**算法思路：**

1. 维护一个列表 $g$，其中 $g[i]$ 表示长度为 $i+1$ 的递增子序列末尾元素的**最小值**。
2. 遍历 $nums$ 中的每个元素 $x$：
   * 如果 $x$ 大于 $g$ 的最后一个元素，说明 $x$ 可以直接接在当前最长子序列后面，形成更长的序列，将 $x$ 加入 $g$。
   * 否则，在 $g$ 中通过**二分查找**找到第一个大于等于 $x$ 的元素，并将其替换为 $x$（贪心：用更小的末尾元素替换，增加潜力）。
3. 最终 $g$ 的长度即为最长递增子序列的长度。

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        g = []
        for x in nums:
            j = bisect_left(g, x)
            if j == len(g):  # >=x 的 g[j] 不存在
                g.append(x)
            else:
                g[j] = x
        return len(g)
```

---

### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

```text
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

示例 1：
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace" ，它的长度为 3 。

示例 3：
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。

提示：
1 <= text1.length, text2.length <= 1000
text1 和 text2 仅由小写英文字符组成。
```

**启发思考：寻找子问题**

假设字符串 $s$ 长度为 $n$，$t$ 长度为 $m$。定义 $dfs(i, j)$ 为 $s$ 的前 $i$ 个字符与 $t$ 的前 $j$ 个字符的最长公共子序列长度。

考虑两个字符串的最后一个字符：

* **如果字符匹配 ($s[i] == t[j]$)**：
说明该字符一定在 LCS 中。

$$
dfs(i, j) = dfs(i-1, j-1) + 1
$$

* **如果字符不匹配 ($s[i] != t[j]$)**：
说明 $s[i]$ 和 $t[j]$ 至少有一个不在 LCS 中。此时需要分两种情况取最大值：
1. 丢弃 $s[i]$：求 $s$ 的前 $i-1$ 个字符与 $t$ 的前 $j$ 个字符的 LCS。
2. 丢弃 $t[j]$：求 $s$ 的前 $i$ 个字符与 $t$ 的前 $j-1$ 个字符的 LCS。

$$
dfs(i, j) = max(dfs(i-1, j), dfs(i, j-1))
$$

---

**递归搜索 + 保存计算结果 = 记忆化搜索**
```python
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        n, m = len(s), len(t)

        @cache  # 缓存装饰器，避免重复计算 dfs 的结果（记忆化）
        def dfs(i: int, j: int) -> int:
            if i < 0 or j < 0:
                return 0
            if s[i] == t[j]:
                return dfs(i - 1, j - 1) + 1
            return max(dfs(i - 1, j), dfs(i, j - 1))

        return dfs(n - 1, m - 1)
```

**1:1 翻译成递推**
```python
class Solution:
    def longestCommonSubsequence(self, s: str, t: str) -> int:
        n, m = len(s), len(t)
        f = [[0] * (m + 1) for _ in range(n + 1)]
        for i, x in enumerate(s):
            for j, y in enumerate(t):
                f[i + 1][j + 1] = f[i][j] + 1 if x == y else \
                                  max(f[i][j + 1], f[i + 1][j])
        return f[n][m]
```

---

### LIS 与 LCS 对比

**LIS：最长递增子序列**

**问题定义**
给你一个整数数组 $$nums$$，找到其中最长严格递增子序列的长度。

**核心思路：枚举选哪个**
由于我们需要知道当前数字是否比前一个数字大，因此状态定义通常关注“以谁结尾”。

**转移逻辑**

定义 $f[i]$ 为以 $nums[i]$ 结尾的最长递增子序列的长度。

对于每一个 $i$，遍历它之前的每一个 $j$ ($j < i$)：

如果 $nums[j] < nums[i]$，状态转移方程为：

$$f[i] = \max(f[i], f[j] + 1)$$

最终答案为所有状态中的最大值：$\max(f)$

---

**LCS：最长公共子序列**

**问题定义**
给定两个字符串 `s` 和 `t`，返回这两个字符串的最长公共子序列的长度。

**核心思路：选或不选**
这是双序列问题，通常从两个字符串的末尾字符开始考虑。

**转移逻辑**

定义 $f[i+1][j+1]$ 为 $s$ 的前 $i$ 个字符与 $t$ 的前 $j$ 个字符的 LCS 长度。

如果 $s[i] == t[j]$（找到一个公共字符，共同后退）：$$f[i+1][j+1] = f[i][j] + 1$$

否则（其中一个字符没用，取最大值）：$$f[i+1][j+1] = \max(f[i][j+1], f[i+1][j])$$

---

## 经典例题

| 题号   | 题目                                                                                   | 标签          |
| ---- | ------------------------------------------------------------------------------------ |-------------|
| 674  | [最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)  | 连续子数组 |
| 673  | [最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/) | 子序列   |
| 1458 | [两个子序列的最大点积](https://leetcode.cn/problems/max-dot-product-of-two-subsequences/) | 动态规划 / 多子序列 |
| 960 | [删列造序 III](https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/) | 多子序列 |

---
