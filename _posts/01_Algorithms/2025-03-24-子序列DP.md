---
title: "动态规划全解：子序列DP全解"
categories: [01_Algorithms]
tags: [algorithm]

math: true
layout: post
---

在动态规划中，有一类问题看似不关心“连续”，却在悄悄考察**选择与不选择**的能力，这正是 **子序列 DP（Subsequence DP）** 的主战场。

---

## 基本概念

**什么是子序列**

给定序列：

```
A = [a1, a2, a3, ..., an]
```

**子序列（subsequence）** 指的是：

> 从原序列中删除若干（可以是 0 个）元素，**不改变相对顺序**，得到的新序列。

例如：

* `[1, 3, 5]` 是 `[1, 2, 3, 4, 5]` 的子序列，`[1, 5, 3]` 不是（顺序改变）。

---

**子序列 DP 的核心思想**

子序列 DP 的本质是：

> **在“第 i 个位置”，做“选 / 不选”的决策，并记录最优结果**

因此，子序列 DP 几乎一定满足：

* 状态与 **下标 i** 有关
* 状态转移体现 **“是否使用第 i 个元素”**

---

## 经典例题：[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```text
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。

示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1

提示：
1 <= nums.length <= 2500
-10^4 <= nums[i] <= 10^4
```

**状态定义**

```
dp[i] = 以 i 结尾的最长递增子序列长度
```

注意关键词：
**以 i 结尾**

---

**状态转移**

对于所有 `j < i`：

```
如果 a[j] < a[i]：
    dp[i] = max(dp[i], dp[j] + 1)
```

完整转移：

```
dp[i] = 1 + max(dp[j])  (j < i 且 a[j] < a[i])
```

若不存在这样的 j，则 `dp[i] = 1`。

---

**初始化 & 答案**

```python
dp[i] = 1
ans = max(dp)
```

---

**完整Python代码**

**经典DP**
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        f = [0] * len(nums)
        for i, x in enumerate(nums):
            for j, y in enumerate(nums[:i]):
                if x > y:
                    f[i] = max(f[i], f[j])
            f[i] += 1
        return max(f)
```

---

## 通用状态设计

**一维 DP（是否以 i 结尾）**

```
dp[i] = 使用 a[i] 时的最优解
```

典型问题：

* 最长递增子序列（LIS）
* 最大子序列和（不要求连续）
* 最长合法子序列

---

**二维 DP（前 i 个，选 j 个 / 某种状态）**

```
dp[i][j] = 在前 i 个元素中，满足条件 j 的最优解
```

常见于：

* 子序列计数
* 编辑距离
* LCS（最长公共子序列）

---

**计数型子序列 DP**：如子序列个数（非常重要）。这类问题非常容易和前缀和、哈希、状态压缩等结合出题。

```
dp[i] = 以 i 结尾的合法子序列个数
```

转移往往是：

```
dp[i] += dp[j]
```

---

**和「线性 DP」的关系**：子序列 DP 本质上是线性 DP 的一个重要分支。

区别在于：

| 类型     | 是否连续 | 典型特征             |
| ------ | ---- | ---------------- |
| 线性 DP  | 连续   | dp[i] ← dp[i-1]  |
| 子序列 DP | 不连续  | dp[i] ← 所有 j < i |

子序列 DP 的转移 **更“全局”**，但也更容易被优化。

---

## 常见优化方向

> 子序列 DP 的优化，本质是 **减少“枚举前驱 j”的成本**：
> 能二分就二分，能按值就不按下标，能累加就不回头。

| 优化方向            | 适用场景         | 核心思想                     | 典型复杂度变化            | 代表问题              |
| --------------- | ------------ | ------------------------ | ------------------ | ----------------- |
| **二分优化**        | 状态只关心“最优末尾值” | 用贪心维护最优结构，用二分定位转移位置      | O(n²) → O(n log n) | 最长递增子序列（LIS）      |
| **值域 离散化** | 状态与“数值大小”强相关 | 将下标 DP 转为值域 DP，压缩或直接按值转移 | O(n²) → O(n + V)   | 值域打家劫舍、按值转移的子序列   |
| **哈希 / 前缀和**    | 子序列计数问题      | 用哈希或前缀和累积历史状态，避免枚举 j     | O(n²) → O(n)       | 不同子序列个数、和为 K 的子序列 |

---

## 经典例题

| 题号   | 题目                                                                                   | 标签          |
| ---- | ------------------------------------------------------------------------------------ |-------------|
| 300  | [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)              | 子序列   |
| 674  | [最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)  | 连续子数组 |
| 718  | [最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)         | 连续子数组 |
| 1143 | [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)                  | 子序列   |
| 115  | [不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)                        | 子序列计数 |
| 673  | [最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/) | 子序列   |
| 53   | [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)                             | 连续子数组 |
| 960 | [删列造序 III](https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/) | 多子序列 |

---
