---
title: "动态规划全解：线性DP全解"
categories: [01_Algorithms]
tags: [algorithm]

math: true
layout: post
---

一维顺序问题中最基础、最常见的动态规划类型。思路清晰、模板固定、拓展性极强，是进入 DP 世界的“第一道门”。

---

## 基本概念

**线性 DP（Linear DP）** 指的是：

> 状态之间呈线性依赖关系的动态规划问题。

换句话说，
每个状态只依赖于前面（或固定范围内）的若干状态，
状态转移方向是“线性”的（通常是一维数组或一条链）。

例如：

* `dp[i] = f(dp[i-1], dp[i-2], ..., dp[i-k])`

---

线性 DP 的四步法：

| 步骤          | 内容                                                       |
| ----------- | -------------------------------------------------------- |
| **1. 定义状态** | `dp[i]` 表示到第 i 个位置的最优值（最大/最小/可行/方案数）                     |
| **2. 状态转移** | 从前面的状态推到当前状态（例如：`dp[i] = max(dp[i-1], dp[i-2]+nums[i])`） |
| **3. 初始化**  | 边界状态，如 `dp[0]`, `dp[1]`                                  |
| **4. 答案输出** | 通常是 `dp[n-1]` 或 `max(dp)`                                |

线性 DP 常见优化技巧：

| 技巧          | 说明                         |
| ----------- | -------------------------- |
| **空间优化**    | 只依赖前一两个状态时，可用滚动数组或两个变量代替   |
| **前缀/后缀优化** | 通过前缀和、单调栈等加速转移             |
| **排序 + 压缩** | 当状态与“值”相关时，先排序并压缩（如值域打家劫舍） |
| **转移剪枝**    | 当不可能更新更优结果时提前跳出            |

---

## 相邻约束的线性最优

### 核心思想

当问题中元素之间有“相邻约束”时，我们可以用线性 DP 求取最优解。

> 这是动态规划最经典、最基础的类型之一，也是打家劫舍系列的基础模板。

---

问题可以抽象为：

> 给定一个序列 `nums`，选择若干元素，使得任意两个相邻元素不能同时选取，求最大（或最优）收益。

特点：

* “相邻约束” → 相邻元素不能同时选；
* “线性顺序” → 序列可按索引从左到右遍历；
* 目标 → 最大化（或最小化）某种价值。

---

**状态定义**

* `dp[i]` 表示**考虑前 i 个元素**，满足相邻约束时的最优值（最大收益）。

**状态转移**

* 当前元素选或者不选：

$$
dp[i] = \max(dp[i-1], dp[i-2] + nums[i])
$$

* 解释：

  * `dp[i-1]` → 不选第 i 个元素，最优值就是前 i-1 个元素的最优值；
  * `dp[i-2] + nums[i]` → 选第 i 个元素，不能选 i-1，所以加上 i-2 的最优值。

**初始化**

```text
dp[0] = nums[0]
dp[1] = max(nums[0], nums[1])
```

**答案输出**

* `dp[n-1]`，表示整个序列的最优值。

---

### 打家劫舍题目解析

**题目信息**

<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>

<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong> 不触动警报装置的情况下 </strong>，一夜之内能够偷窃到的最高金额。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>[1,2,3,1]
<strong>输出：</strong>4
<strong>解释：</strong>偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>[2,7,9,3,1]
<strong>输出：</strong>12
<strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
&nbsp;    偷窃到的最高金额 = 2 + 9 + 1 = 12 。
</pre>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= nums.length &lt;= 100</code></li> 
 <li><code>0 &lt;= nums[i] &lt;= 400</code></li> 
</ul>

---

**模板代码**

**递归搜索 + 保存计算结果 = 记忆化搜索**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        # dfs(i) 表示从 nums[0] 到 nums[i] 最多能偷多少
        @cache  # 缓存装饰器，避免重复计算 dfs 的结果
        def dfs(i: int) -> int:
            if i < 0:  # 递归边界（没有房子）
                return 0
            return max(dfs(i - 1), dfs(i - 2) + nums[i])

        return dfs(len(nums) - 1)  # 从最后一个房子开始思考
```

**1:1 翻译成递推**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        f = [0] * (len(nums) + 2)
        for i, x in enumerate(nums):
            f[i + 2] = max(f[i + 1], f[i] + x)
        return f[-1]
```

**空间优化：只需要前两个状态**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        f0 = f1 = 0
        for x in nums:
            f0, f1 = f1, max(f1, f0 + x)
        return f1
```

---

**核心总结：选或不选，前两个状态决定最优解**

| 概念  | 含义                                             |
| --- | ---------------------------------------------- |
| 状态  | dp[i] → 前 i 个元素的最优解                            |
| 转移  | dp[i] = max(dp[i-1], dp[i-2]+nums[i])          |
| 初始化 | dp[0] = nums[0], dp[1] = max(nums[0], nums[1]) |
| 优化  | 滚动数组 + O(1) 空间                                 |

---

### 值域打家劫舍

一个有趣的转化思想：**当约束来自「值域」而非「下标」时，我们依然可以“线性化”地求解。**

在线性DP模板题[**198. 打家劫舍**](https://leetcode.cn/problems/house-robber/) 中，给定一个数组 `nums`，不能偷相邻的房子，求最大收益。

```python
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
```

* 线性结构：每个房子在一条直线上。
* 相邻限制：不能连续选择相邻的元素。

> 如果相邻不再指「索引相邻」，而是「**数值相邻**」，会怎样？
> 
> 这类问题就进入了「**值域打家劫舍**」的世界。

---

**值域打家劫舍的核心思想**

> 将“值域”映射成“线性序列”，再在其上应用打家劫舍的 DP 模型。

**思维转化过程**

1. **统计每个数值的贡献**：例如，出现了多个相同值 `v`，总收益为 `v * count[v]`。

2. **提取所有不同值并排序**：可通过值域映射 + 排序，把问题转化为一维线性结构。

3. **按值域转移**：如果相邻值差为 1，则不能同时选；否则可以独立选。 于是问题变成了一个线性 DP：
  ```python
  dp[i] = max(dp[i-1], dp[i-2] + value[i]*count[i])
  ```

---

**思维升华：为什么要「值域排序」**

| 问题           | 如果不排序会怎样？     |
| ------------ | ------------- |
| 不能判断“值域相邻”关系 | 无法用线性顺序表示值差约束 |
| 无法使用一维 DP 转移 | 必须用复杂的图或哈希转移  |
| 无法二分查找前驱     | 查找效率降低，逻辑不清晰  |

排序后：

* 值域成为单调递增序列；
* 可以直接判断 `values[i] - values[j] >= d`；
* 可用二分加速 DP 转移；
* 本质上把值空间“线性化”。

---

**值域打家劫舍的本质**

> 一种把「离散值域问题」映射为「线性序列」的动态规划思想。

它的核心特征：

* 状态线性化；
* 值域代替索引；
* 相邻差值形成 DP 约束。

公式抽象：

$$
dp[i] = \max(dp[i-1], dp[j] + \text{gain}[i]), \quad \text{s.t. } values[i] - values[j] \ge d
$$

---

### 施咒的最大总伤害题目解析

**题目信息**

<p>一个魔法师有许多不同的咒语。</p>

<p>给你一个数组&nbsp;<code>power</code>&nbsp;，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。</p>

<p>已知魔法师使用伤害值为&nbsp;<code>power[i]</code>&nbsp;的咒语时，他们就&nbsp;<strong>不能</strong>&nbsp;使用伤害为&nbsp;<code>power[i] - 2</code>&nbsp;，<code>power[i] - 1</code>&nbsp;，<code>power[i] + 1</code>&nbsp;或者&nbsp;<code>power[i] + 2</code>&nbsp;的咒语。</p>

<p>每个咒语最多只能被使用 <strong>一次</strong>&nbsp;。</p>

<p>请你返回这个魔法师可以达到的伤害值之和的 <strong>最大值</strong>&nbsp;。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p>

<div class="example-block"> 
 <p><span class="example-io"><b>输入：</b>power = [1,1,3,4]</span></p> 
</div>

<p><span class="example-io"><b>输出：</b>6</span></p>

<p><strong>解释：</strong></p>

<p>可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。</p>

<p><strong class="example">示例 2：</strong></p>

<div class="example-block"> 
 <p><span class="example-io"><b>输入：</b>power = [7,1,6,6]</span></p> 
</div>

<p><span class="example-io"><b>输出：</b>13</span></p>

<p><strong>解释：</strong></p>

<p>可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= power.length &lt;= 10<sup>5</sup></code></li> 
 <li><code>1 &lt;= power[i] &lt;= 10<sup>9</sup></code></li> 
</ul>

---

**思路解析**

1. 相邻约束
   * 注意这里的相邻是**值域相邻**，而不是数组下标相邻。
   * 如果选择了 `power[i]`，则所有 `power[j]` 与它相差 `< d` 的法术不能选。

2. 排序与值域线性化
   * 首先按 `power` 对法术排序，这样可以方便按值域顺序考虑。
   * 排序后，可以将问题转化为**值域线性 DP**：
     * 当前法术 `i` 可选择施放或不施放。
     * 如果施放，需要找到**前一个可施法的法术 j**（满足 `power[j] <= power[i] - d`）。

3. 状态定义
   * $dp[i] = \text{前 i 个法术，最大总伤害}$
   * 不施放 `i` → `dp[i-1]`
   * 施放 `i` → `dp[j] + damage[i]`，其中 `j` 是前一个可施法法术（值域差 >= d）

4. 转移方程
   * $dp[i] = max(dp[i-1], dp[j] + damage[i])$
   * j = 最靠近 i 的，满足 `power[j] <= power[i] - d`

--- 

**模板代码**

**递归搜索 + 保存计算结果 = 记忆化搜索**

```python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        cnt = Counter(power)
        a = sorted(cnt)

        @cache  # 缓存装饰器，避免重复计算 dfs（一行代码实现记忆化）
        def dfs(i: int) -> int:
            if i < 0:
                return 0
            x = a[i]
            j = i
            while j and a[j - 1] >= x - 2:
                j -= 1
            return max(dfs(i - 1), dfs(j - 1) + x * cnt[x])

        return dfs(len(a) - 1)
```

**1:1 翻译成递推**

```python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        cnt = Counter(power)
        a = sorted(cnt)
        f = [0] * (len(a) + 1)
        j = 0
        for i, x in enumerate(a):
            while a[j] < x - 2:
                j += 1
            f[i + 1] = max(f[i], f[j] + x * cnt[x])
        return f[-1]
```

## 总结对比

> 线性 DP 的本质是“有序累积最优”。

| 类别    | 状态依赖方向  | 常见题型         | 特点           |
| ----- | ------- | ------------ | ------------ |
| 线性 DP | 单维、顺序依赖 | 打家劫舍、爬楼梯、子序列 | 最基础、模板化      |
| 区间 DP | 区间左右划分  | 合并石头、矩阵链乘    | 双层循环         |
| 背包 DP | 状态二维    | 重量/容量限制问题    | 线性 DP + 限制条件 |
| 状压 DP | 状态组合    | 子集、路径、覆盖     | 线性 DP 的扩展形式  |


> “所有复杂的动态规划，都是线性 DP 的多维变体。”

掌握线性 DP，你就掌握了动态规划的基本骨架。
从它出发，可以自然延伸到区间、树形、状态机、状压等更复杂场景。

---

## 经典例题

| 题号   | 题目                                                                                | 特征          | 备注        |
| ---- | --------------------------------------------------------------------------------- | ----------- | --------- |
| 198  | [打家劫舍](https://leetcode.cn/problems/house-robber/)                                | 下标相邻        | 线性 DP 模板  |
| 740  | [删除并获得点数](https://leetcode.cn/problems/delete-and-earn/)                          | 值域相邻        | 值域打家劫舍模板题 |
| 3186 | [施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/) | 值域稀疏 + 额外权重 | 提升题     |
| 213  | [打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)                          | 环形相邻        | 提升题     |

---
