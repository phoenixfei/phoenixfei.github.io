---
title: "双指针：高效算法技巧"
categories: [01_Algorithms]
tags: [algorithm]

math: true
layout: post
---

双指针是一种常用于处理 **线性结构（如数组、字符串、链表）** 的算法技巧，它通过维护两个指针的位置关系来简化遍历、查找、排序等操作。

### 双指针详解

**主要用途：**

* 使用两个指针同时在数组或链表上移动，常用于线性遍历和查找。
* 通过指针移动的配合，实现效率更高的搜索、匹配或合并操作。

> 核心思想：利用指针的移动代替嵌套循环，提高效率。

**常见的双指针模式：**

| 模式名称                    | 指针方向                                      | 应用场景        |
| ----------------------- |-------------------------------------------| ----------- |
| 对撞指针（Opposite Pointers） | 一个从头，一个从尾，向中间逼近                           | 判断回文、两数之和   |
| 同向指针（Sliding Window）    | 两个指针都从头开始，<br/> `right` 向右扩张，`left` 条件下缩小 | 子数组、最长子串、窗口 |
| 快慢指针（Fast & Slow）       | 一快一慢，常用于链表                                | 判环、找中点      |

---

### 同向双指针

* 两个指针都从左向右（或同一方向）扫描
* 常用于 **滑动窗口**、**子序列/子数组问题**

示例：[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)
```text
给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。

示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。注意 "bca" 和 "cab" 也是正确答案。
```

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        ans = left = 0
        window = set()  # 维护从下标 left 到下标 right 的字符
        for right, c in enumerate(s):
            # 如果窗口内已经包含 c，那么再加入一个 c 会导致窗口内有重复元素
            # 所以要在加入 c 之前，先移出窗口内的 c
            while c in window:  # 窗口内有 c
                window.remove(s[left])
                left += 1  # 缩小窗口
            window.add(c)  # 加入 c
            ans = max(ans, right - left + 1)  # 更新窗口长度最大值
        return ans
```

* `left`、`right` 两个指针 **同向移动**
* 时间复杂度 O(n)

---

### 相向双指针

* 一个指针从左，一个从右
* 常用于 **排序数组的两数和 / 三数和**、**反转数组**

示例：[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)
```text
给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。
如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。
 
示例 1：
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left = 0
        right = len(numbers) - 1
        while True:
            s = numbers[left] + numbers[right]
            if s == target:
                return [left + 1, right + 1]  # 题目要求下标从 1 开始
            if s > target:
                right -= 1
            else:
                left += 1
```

* 利用数组有序性快速逼近目标
* 时间复杂度 O(n)，比暴力 O(n²) 高效

---

### 三指针、四指针

* **三指针（Three Pointers）**：在一个序列（数组/链表）上同时维护三个指针，通过它们之间的相对位置控制逻辑或状态。
* **四指针（Four Pointers）**：在一个序列上同时维护四个指针，常用于优化四重循环或维护两个窗口。

> 核心思想：多指针都是 **利用指针的相对位置维护状态**，用来减少嵌套循环、实现线性或接近线性扫描。

---

**三指针的典型模式：固定 + 双指针（同向或相向）**

示例：[15. 三数之和](https://leetcode.cn/problems/3sum/description/)
```text
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？
请找出所有和为 0 且 不重复 的三元组。

示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

思路：

1. 固定第一个指针 `i`
2. 其余两个指针 `j`, `k` 在剩余数组上相向逼近，寻找符合条件的三元组
3. 三个指针都不回退，整体复杂度 O(n²)

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            x = nums[i]
            if i > 0 and x == nums[i - 1]:  # 跳过重复数字
                continue
            if x + nums[i + 1] + nums[i + 2] > 0:  # 优化一
                break
            if x + nums[-2] + nums[-1] < 0:  # 优化二
                continue
            j = i + 1
            k = n - 1
            while j < k:
                s = x + nums[j] + nums[k]
                if s > 0:
                    k -= 1
                elif s < 0:
                    j += 1
                else:  # 三数之和为 0
                    ans.append([x, nums[j], nums[k]])
                    j += 1
                    while j < k and nums[j] == nums[j - 1]:  # 跳过重复数字
                        j += 1
                    k -= 1
                    while k > j and nums[k] == nums[k + 1]:  # 跳过重复数字
                        k -= 1
        return ans
```

* `i` 固定，`j`、`k` 左右逼近 → 三指针
* 原本三重循环 O(n³) → 优化为 O(n²)

---

**四指针的典型模式：四重循环优化**

示例：[18. 四数之和](https://leetcode.cn/problems/4sum/)

思路：

1. 固定前两个指针 `i`, `j`
2. 其余两个指针 `l`, `r` 在剩余数组上相向逼近
3. 四个指针共同确定满足条件的四元组

* 原本四重循环 O(n⁴) → 优化为 O(n³)
* 三指针 → 两重循环 + 双指针
* 四指针 → 两固定 + 双指针逼近

---

**多指针设计思路**

1. **明确每个指针的角色**

   * 固定指针 / 左右逼近指针 / 条件指针
2. **确定移动策略**

   * 根据条件判断哪个指针先移动
   * 保证不回退、不漏元素
3. **利用指针关系维护状态**

   * 比如窗口大小、和、最大/最小值、满足条件的组合数

---

### 知识点总结

**技巧**
> **“一个扫序列，一个控区间，边界关系决定移动方向。”**

**核心要点**
1. 指针移动 **必须保证不漏不重**
2. **条件判断** 决定哪个指针先动
3. **优化循环**，把原本 O(n²) 问题降为 O(n)
4. 对链表要注意空指针，数组要注意越界

**双指针的典型应用场景**

| 类型        | 典型问题             | 技巧要点               |
| --------- | ---------------- | ------------------ |
| 滑动窗口      | 最长无重复子串、最小覆盖子串   | 同向移动指针，窗口左/右边界动态调整 |
| 排序数组/链表   | 两数和、三数和          | 相向指针逼近目标，利用有序性     |
| 链表问题      | 删除倒数第 k 个节点、判断回文 | 慢指针 + 快指针          |
| 数组操作      | 反转数组、移动零         | 双指针遍历与交换           |
| 子数组/子序列问题 | 最大连续 1、最长递增子序列优化 | 利用左/右边界控制          |

---

### 经典例题

| 题号   | 题目                                                                                                      | 标签               |
| ---- | ------------------------------------------------------------------------------------------------------- |------------------|
| 11   | [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)                                      | 双指针 / 贪心 / 模板题   |
| 42   | [接雨水](https://leetcode.cn/problems/trapping-rain-water/)                                                | 单调栈 / 双指针 / 模板题  |
| 26   | [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)                        | 双指针 / 数组 / 模板题   |
| 2273 | [移除字母异位词后的结果数组](https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/description/) | 双指针 / 字符串 / 提升题  |
| 3347 | [执行操作后元素的最高频率 II](https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/) | 同向三指针 / 差分 / 提升题 |

---
