---
title: "动态规划入门：如何正确理解和使用DP"
categories: [01_Algorithms]
tags: [algorithm]

math: true
layout: post
---

大事化小，小事化了！动态规划（Dynamic Programming，简称 DP）是算法中**最重要、也最容易让人迷糊**的一类思想。

---

## 基本概念

一句话定义：

> **DP 是在“存在重复子问题”的前提下，通过记录中间结果来避免重复计算，从而高效求解最优解的问题。**

它解决的核心问题是三类：

* 最值（最大 / 最小）
* 可行性（能不能做到）
* 计数（有多少种方案）

---

不是所有题都适合 DP。
当你在题目中看到这些特征时，**DP 几乎是第一选择**：

* 要求「最大 / 最小 / 最优」
* 有明显的「子问题」
* 当前选择会影响后续结果
* 有“选 / 不选”“做 / 不做”的决策
* 暴力枚举会出现大量重复计算

> 如果一个问题能被拆成「规模更小、结构相同的子问题」，那它就非常适合 DP。

---

## 求解步骤

任何 DP 题，本质都在回答这四个问题：

| 问题     | 含义              |
| ------ | --------------- |
| 状态是什么？ | dp[i] 表示什么      |
| 如何转移？  | dp[i] 怎么从之前的状态来 |
| 边界条件？  | 最小规模如何处理        |
| 遍历顺序？  | 先算谁、后算谁         |

> **不会 DP $≈$ 状态没想清楚**

---

DP 的两种实现方式
一、记忆化搜索（自顶向下）

* 写法像 DFS
* 用缓存避免重复计算
* 更符合直觉

```python
@lru_cache(None)
def dfs(state):
    if base_case:
        return ...
    return min / max / sum(dfs(next_state))
```

二、递推（自底向上）

* 用 for 循环
* 更高效、可控
* 更适合比赛和工程

```python
for i in range(1, n):
    dp[i] = ...
```

---

## DP 的九大核心类别

### ① 线性 DP

线性 DP 是最基础、也是最常见的一类动态规划，其核心特征是：
**状态沿着一个一维序列推进，当前状态只依赖于前面若干个状态**。

**状态形式**：

典型状态形式为 `dp[i]`，表示“考虑到第 i 个位置时的最优解”。
这类问题往往包含“相邻约束”“选或不选”“前缀最优”等特征。

**特征**：

* 状态是一维
* dp[i] 只依赖前面若干个状态

**典型模型**：

* 打家劫舍
* 值域打家劫舍
* 一维子序列 DP
* 相邻约束的线性最优

线性 DP 是理解其他复杂 DP（如区间、树形、状态机 DP）的基础。
更多内容参考[线性DP专栏](/posts/线性DP/)

---

### ② 区间 DP

区间 DP 的状态定义在一个**连续区间**上，其核心特征是：
**枚举“区间的最后一步”或“区间的分割点”**，通过合并更小区间的结果来求解大区间。

**状态形式**：
通常表示为 `dp[l][r]`，表示区间 `[l, r]` 的最优解。

**特征**：
* 区间 DP 的转移往往涉及三层循环，时间复杂度较高
* 逻辑结构非常清晰

**代表题**：

| 题号   | 题目                                                                                | 标签                   |
| ---- | --------------------------------------------------------------------------------- | -------------------- |
| 516  | [最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)          | 区间 DP / 字符串 / 模板题    |
| 1235 | [规划兼职工作](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/)                         | 区间 DP / 排序 + 二分 / 提升题 |
| 1751 | [最多可以参加的会议数目 II](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/) | 区间 DP / 排序 + 二分 / 提升题 |

---

### ③ 网格 DP

网格 DP 的状态定义在二维坐标上，常用于路径规划、最短路径、计数路径等问题，是二维 DP 中最直观的一类。

**状态形式**：
通常为 `dp[i][j]`，表示到达网格中 `(i, j)` 位置的最优结果。

**特征**：
* 状态空间是二维
* 转移方向固定（如来自上方、左方、左上角等）
* 状态之间构成一个 **有向无环图（DAG）**

更多内容参考[网格图DP专栏](/posts/网格图DP/)

---

### ④ 树形 DP

树形 DP 是在树结构上进行的动态规划。常用于“选或不选节点”“子树最优解”“树上独立集”等问题，是结构化 DP 的重要代表。

**状态形式**：
状态通常定义为 `dp[u][*]`，表示以节点 `u` 为根的子树状态。

**特征**：
* 利用 DFS 遍历树
* 在“回溯阶段”合并子树的 DP 结果
* 正确处理父子关系，避免重复计算

**代表题**：

| 题号  | 题目                                                               | 标签                                          |
| --- | ---------------------------------------------------------------- | ------------------------------------------- |
| 337 | [打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)         | 二叉树 / 树形 DP / 递归 / 提升题 |

---

### ⑤ 背包 DP

背包 DP 是一类带有“容量 / 成本约束”的动态规划问题，核心目标是在限制条件下最大化收益或判断可行性。

根据每个物品的使用次数不同，背包问题可细分为：
* 0/1 背包
* 完全背包
* 多重背包
* 分组背包

**状态形式**：
状态通常定义为 `dp[c]` 或 `dp[i][c]`，表示在容量为 `c` 时的最优结果。

**特征**：
* 有容量 / 成本限制
* 是否能装 / 装多少

更多内容参考[背包DP专栏](/posts/背包DP/)

---

### ⑥ 状态机 DP

状态机 DP 是动态规划中一种**特殊的线性结构 DP**，它的核心思想是：
**将问题抽象为“有限状态 + 时间/位置推进”，然后按状态转移求解最优解或计数。**

**状态形式**：
典型状态形式为 `dp[i][state]`，其中：
* `i` 表示时间 / 位置
* `state` 表示当前所处的有限状态

**特征**：
* 状态数有限
* 随 i 线性推进

**代表题**：

| 题号  | 题目                                                                                                  | 标签                  |
| --- | --------------------------------------------------------------------------------------------------- | ------------------- |
| 121 | [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)                          | 股票系列 / 贪心 / 模板题 |
| 122 | [买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)                    | 股票系列 / 状态机 DP / 模板题     |
| 123 | [买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)                  | 股票系列 / 状态机 DP / 提升题 |
| 188 | [买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)                    | 股票系列 / 状态机 DP / 提升题 |
| 309 | [最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)         | 股票系列 / 状态机 DP / 提升题 |
| 714 | [买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/) | 股票系列 / 状态机 DP / 提升题 |

---

### ⑦ 状压 DP

状压 DP 使用一个二进制掩码（mask）来表示“一个集合的状态”，常用于元素数量较小（通常 ≤ 20）的情况。
常用于 TSP、子集划分、组合枚举等问题，是时间换空间的典型代表。

**状态形式**：
* `dp[mask]`
* `dp[mask][i]`

其中：
* `mask` 是一个二进制整数，每一位代表集合中的一个元素是否被选择/使用。例如，对于 n = 4 个元素：`mask = 0b1010` 表示元素 1 和元素 3 被选中，其余未选中
* `dp[mask][i]` 表示在 mask 状态下，集合中某个特定元素 i 的附加信息，例如：表示在已经选择 mask 的元素后，最后选择 i 的最优解

**特征**：
* 用二进制表示选中 / 未选中
* 枚举子集或向集合中逐步加入元素

**代表题**：

| 题号   | 题目                                                                                        | 标签                         |
| ---- | ----------------------------------------------------------------------------------------- | -------------------------- |
| 1931 | [用三种不同颜色为网格涂色](https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/) | 状压 DP / 列 DP / 网格 DP / 提升题 |

---

### ⑧ 数位 DP

数位 DP 是一类专门用于**按数字位进行枚举与统计**的动态规划方法，常用于处理大整数区间问题。
其核心用途是高效统计 `[0, R]` 或 `[L, R]` 内满足某些数字结构特征的数。

**状态形式**：
`dp[pos][state][tight]`

其中：
* `pos` 表示当前处理到的数字位
* `state` 表示题目相关的额外状态
* `tight` 表示是否受上界约束

**特征**：
* 按数字位 DP
* 区间统计

**代表题**：

| 题号   | 题目                                                                                                    | 标签            |
| ---- | ----------------------------------------------------------------------------------------------------- | ------------- |
| 1399 | [统计最大组的数目](https://leetcode.cn/problems/count-largest-group/)                                         | 数位和 / 枚举      |
| 2843 | [统计对称整数的数目](https://leetcode.cn/problems/count-symmetric-integers)                                    | 数位枚举 / 回文判断   |
| 2999 | [统计强大整数的数目](https://leetcode.cn/problems/count-the-number-of-powerful-integers/)                      | 枚举 / 区间计数     |
| 3352 | [统计小于 N 的 K 可约简整数](https://leetcode.cn/problems/count-k-reducible-numbers-less-than-n/)               | 数位 DP / 数学    |
| 3621 | [位计数深度为 K 的整数数目 I](https://leetcode.cn/problems/number-of-integers-with-popcount-depth-equal-to-k-i/) | 位运算 / 数位 DP   |
| 3753 | [区间内数字的总波动值 II](https://leetcode.cn/problems/total-waviness-of-numbers-in-range-ii/)                  | 数位 DP / 波动性计数 |

---

### ⑨ 概率 / 期望 DP

概率 / 期望 DP 用于求解随机过程中的期望值或概率结果，其状态转移通常带有概率权重。

典型形式为：
`dp[state] = Σ(转移概率 × dp[next_state])`

这类 DP 的难点不在代码，而在于：

* 正确建立期望方程
* 理解状态之间的随机转移关系

常见于掷骰子、随机游走、博弈期望等问题，是 DP 中偏数学的一类。

---

## 入门案列

### 斐波拉切数列

```text
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
也就是：
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。
```

**递归解法**：可读性最好，但是很多节点被重复执行，空间开销太大
```java
public static int fib(int num) {
    if(n <=  0)
        return 0;
    if(n == 1)
        return 1;
    return fib(n - 1) + fib(n - 2);
}
```

![20181113215740939]({{ site.baseurl }}/assets/images/20181113215740939.png)

下面看看算法的执行流程，假如输入6，那么执行的递归树如下所示。上面的每个节点都会被执行一次，导致同样的节点被重复的执行，比如fib(2)被执行了5次。这样导致时间上的浪费，如果递归调用也会导致空间的浪费，导致栈溢出的问题。

结合斐波拉契数列递归解法这个案例，我们再来说说什么是动态规划。动态规划和分治法看起来是非常像的思想，但两者的区别也是非常明显的。

分治法是将问题划分为互不相交的子问题，递归求解子问题，再将他们的解组合起来，求出原问题的解。

而动态规划是应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。例如上述的斐波拉切数列。

上述的递归解法就是分治算法，由于它的子问题是相互相关的，此时利用分治法就做了许多重复的工作，他会反复求解那些公共子子问题。而动态规划算法对每一个子子问题的解只求一次，将其保存在一个表格中，从而避免重复计算。

---

利用**动态规划**的两种方法解决斐波拉契数列问题。

在动态规划中，包含了三个重要概念：**最优子结构、边界和状态转移方程**。

对于斐波拉切数列来说，
- `fib(10)`的最优子结构就是`fib(9, nums)` 和`fib(8, nums)`；
- 边界是 `nums[2]` 和 `nums[1]`；
- 状态转移方程是`nums[10] = fibDP(9, nums) + fibDP(8, nums)`。

注意最优子结构和状态转移方程的区别，个人理解就是最优子结构是针对某个值来说的，而状态转移方程就是它的整体推算方程。

**方法1：自顶向下（备忘录法）记录已求解的节点信息**
```java
public static int fib(int num) {
    if(num <= 0) return 0;
    int[] nums = new int[num + 1]; // 这里长度为 num + 1
    Arrays.fill(nums, -1); // 利用-1填充数组
    return fibDP[num, nums]
}
// 自顶向下解法
public static int fibDP(int num, int[] nums) {
    //注意if判断的顺序
    if (nums[num] != -1) return nums[num]; // 不为-1，表示已求解
    if(num == 0) nums[num] = 0;
    else if(num == 1) nums[num] = 1;       
    else nums[num] = fibDP(num-1, nums) + fibDP(num-2, nums);
    return nums[num];
}
```

**方法2：自底向上求解，并记录节点信息**

利用数组来存放斐波拉切数列中的每一个值，由于是自顶向下递归，它还是最先递归到nums[3]，从此刻开始在往上计算，然后依次保存计算结果在nums数组中，避免了重复运算。

```java
public static int fibDP(int num) {
    if(num <= 0) return 0;
    int[] nums = new int[num+1];
    nums[0] = 0;
    nums[1] = 1;
    for (int i = 2; i <= num; i++) {
        nums[i] = nums[i-1] + nums[i-2];
    }
    return nums[num];
}
```

从上面的例子可以看到自顶向下的方式的动态规划其实包含了递归，而递归就会有额外的开销的。

而使用**自底向上**的方式可以避免。但是该方法对于空间还是有一定的浪费，下面，我们对其空间再压缩一点。

**方法2优化**：仔细观察斐波拉切数列发现，自底向上方法始终只有三个变量，n-2, n-1, n.

```java
public static int fibDP2(int num) {
    if(num <= 0) return num;
    int ret = 1; // n
    int num_1 = 1; // n - 1
    int num_2 = 0; // n - 2
    for (int i = 2; i <= num; i++) {
        ret = num_1 + num_2; // F(n) = F(n-1) + F(n-2)
        num_2 = num_1; // 更新变量 n - 2，使其等于 n - 1
        num_1 = ret; // 更新变量 n - 1，使其等于 n
    }
    return ret;
}
```

斐波拉切数列拓展例题：有一座高度是**10**级台阶的楼梯，从下往上走，每跨一步只能向上**1**级或者**2**级台阶。要求用程序来求出一共有多少种走法。（分析一下，其实就是斐波拉契数列！）。**注意**：此时F(2) = 2。

总结：至此，斐波拉切数列案列结束。不过这类案列仅仅是动态规划领域中的最最简单的问题。因为它只有一个变化维度。还有许多问题远比这复杂的多。下面敬请看入门案例2和3。弄懂这3个案列，才算对动态规划有了粗浅入门。

---

### 钢条切割

![20170715221117648]({{ site.baseurl }}/assets/images/20170715221117648.png)

解法思路：

一般滴，对于$r_n(n>=1)$，我们可以用更短的钢条的最优切割收益来描述它：

$$
r_n = \max(p_n, r_1+r_{n-1},r_2+r_{n-2},...,r_{n-1}+r_1) \tag{1}
$$

第一个参数$p_n$对应不切割，直接出售长度为$n$英寸的钢条的方案。

其他$n-1$个参数对应另外$n-1$种方案：对每个$i=1,2,...,n-1$，首先将钢条切割为长度为$i$和$n-i$的两段，接着求解这两段的最优切割收益$r_i$和$r_{n-i}$（每种方案的最优收益为两段的最优收益之和）。

由于无法预知哪种方案会获得最优利益，我们必须考察所有可能的$i$，选取其中收益最大者。

---

除了上述求解方法外，钢条切割问题还存在一种相似的但更为简单的递归求解方法：

我们将钢条从左边切割下长度为$i$的一段，只对右边剩下的长度为$n-i$的一段进行切割（递归求解），对左边的一段则不再进行切割。即问题分解的方式为：将长度为$n$的钢条分解为左边开始一段，以及剩余部分继续分解的结果。

这样，不做任何切割的方案就可以描述为：第一段的长度为$n$，收益为$p_n$，剩余部分长度为$0$，对弈收益为$r_0 = 0$。于是我们可以得到公式（1）的简化版。

$$
r_n = \max_{1<=i<=n}(p_i + r_{n-i}) \tag2
$$

关于子问题的最优解，并在有可能的两段切割方案中选取嘴和收益最大者，构成原问题的最优解。我们称钢条切割问题满足**最优子结构（optimal substructure）**性质：问题的最优解由相关问题的最优解组合而成，而这些子问题可以独立求解。

**递归解法**：
```java
public static int cut(int[] p, int n) {
    if(n == 0) return 0;
    int ret = Integer.MIN_VALUE;; // 记录某种切割方法的最大利益值
    for (int i = 1; i <= n; i++) {
        ret = Math.max(ret, cut(p, n-i)+p[i-1]);
    }
    return ret;
}
```

递归很好理解，如果不懂，请仔细阅读上面的思路。

递归的思路其实和回溯法是一样的，遍历所有解空间。

这里跟斐波拉切数列不同之处在于，在每一层上都进行了最优解的选择，`ret = Math.max(ret, cut(p, n-i)+p[i-1]);`这里上一层的最优解与下一层的最优解相关。

**动态规划解法：自顶向下（备忘录法）**
```java
public static int cut(int[] p) {
    int[] q = new int[p.length + 1]; // 这里长度为 num + 1;
    Arrays.fill(q, -1);
    return cut(int[] p, p.length, int[] q);
}
// 自顶向下解法，注意理解形参 n
public static int cut(int[] p, int n, int[] q) {
    if(n == 0) return 0;
    if(q [n] != -1) return q[n];
    int ret = 0;
    for (int i = 1; i <= n; i++) {
        ret = Math.max(ret, cut(p, n-i, q)+p[i-1]);
    }
	  q[n] = ret;
    return q[n];
}
```

有了上面求斐波拉契数列的基础，理解备忘录方法也就不难了。

备忘录方法无非是在递归的时候记录下已经调用过的子函数的值。这道钢条切割问题的经典之处在于自底向上的动态规划问题的处理，理解了这个也就理解了动态规划的精髓。

**动态规划解法：自底向上**
```java
public static int cutDP(int[] p, int n) {
    int[] q = new int[n+1];
    Arrays.fill(q, -1);
    int ret = 0;
    for (int i = 0; i <= n; i++) {
        ret = 0;
        for (int j = 1; j <= i; j++){
            ret = Math.max(ret, p[j-1]+q[i-j]);
        }
        q[i] = ret;
    }
    return q[n];
}
```

斐波拉切数列与切割钢条问题总结：
1. 利用自顶向下(内部包含一个递归)，该方法比自底向上少一个循环。原因即体现在递归上。
2. 动态规划的两种解法（自顶向下与自底向上），都利用一个数组存储了已经计算出来的节点信息，即比递归解法少了空间消耗。
3. 如果需要保存的节点个数确定，对比斐波拉契数列自底向上问题优化解法，可以进一步降低空间消耗。

### 国王和金矿

题目描述：

有一个国家发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？
![2412606803-5c2439799f9b1_articlex]({{ site.baseurl }}/assets/images/2412606803-5c2439799f9b1_articlex.png)

分析思路：

对于每个金矿，都有挖或者不挖两种选择。因此，问题的**最优子结构**有两个（求最大值），

1. 4金矿10工人的最优选择
2. 4金矿（10-选择挖金矿所需人数）工人的最优选择

国王和金矿问题中的**边界**：有两个

1. 当只有1座金矿时，只能挖这座唯一的金矿，且工人数充足，得到该金矿的数量
2. 当工人数不够挖这座金矿时，获得黄金数量为0

国王和金矿问题中的**状态转移方程**：我们令金矿数为n，工人数为w，金矿的黄金量为g[]，金矿的用工量为p[]。有如下关系式：

$$
F(n,w) = 0  \text {，(n <= 1, w < p[0])} \tag1
$$

$$
F(n,w) = g[0] \text {，(n == 1, w >= p[0])} \tag2
$$

$$
F(n,w) = F(n-1, w) \text {，(n > 1, w < p[n-1])} \tag3
$$

$$
F(n,w) = max(F(n-1, w), F(n-1, w-p[n-1]) + g[n-1]) \text {，(n > 1, w >= p[n-1])}  \tag4
$$


**动态规划解法（自底向上）**：
```java
int getMostGold(int n, int w, int[] g, int[] p){
    // 初始化两个数组用来记录结果
    int[] preResult = new int[w + 1];
    int[] result = new int[w + 1];
    // 填充边界格子的值
    for(int i = 0, i <= w, i++){
        if(i < p[0]) preResult = 0;
        else preResult = g[0];
    }
    if (n == 1) return preResult[w];
    // 填充其余格子的值，外层循环是金矿数量，内层循环是工人数
    for(int i = 1; i < n; i++){
        for(int j = 0; j <= w; j++){
            if ( j < p[i]) result[j] = preResult[j];
            else result[j] = Math.max(preResult[j], preResult[j-p[i]]+g[i]);
        }
        // 更新上一行值，为下一轮递推做准备
        for(int j = 0; j <= w; j++) preResult[j] = result[j];
    }
    return result[w];
}
```

上述方法利用两层迭代，来逐步推导出最终结果。方法的时间复杂度为$O(n*w)$，空间复杂度为$O(w)$。

对于动态规划方法来说，当输入的矿山数量多的时候，它的效率会非常高，但是当工人数多的时候，它的效率会低，而且可能低于简单的递归。

## 入门小节

一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！
- 每个阶段只有一个状态->递推；
- 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
- 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
- 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。

---

## 经典例题
- [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)
- [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

---
