---
title: "余数状态转移：只靠余数也能模拟大整数"
categories: [01_Algorithms]
tags: [math, algorithm]

math: true
layout: post
---

在处理「二进制流能否被某个数整除」这类问题时，一个核心数学技巧是 **余数状态转移**。其本质是利用同余定理，将「追加一位二进制数字」转化为「余数的递推更新」，从而避免维护大整数。

---

## 基本概念

**为什么要用余数状态转移？**

余数状态转移利用同余定理，将本应指数级增长的大整数，压缩为有限的模值递推，从而高效地处理拼接数字、整除检查等问题。

给定若干二进制位，我们的数随着输入变化：

$$
x_i = \text{binary}(nums[0..i])
$$

如果每次都计算完整二进制值，再判断是否能被 5 整除，会因为：

* 数字越来越大（可能达到上千位）
* 大整数构造成本高

如果，我们可以只维护模数（余数）的话，那么可枚举的区间就只有 $0,1,2,3,4$。

---

## 余数状态转移公式

若当前余数为 $r$，下一位为 $b$，则下一位的余数 $r'$为：

$$
r' = (2r + b) \bmod 5
$$

---

## 同余定理

> 在推导余数状态转移公式千，需要掌握同余定理相关知识。

若有：

$$
a \equiv b \pmod{m}
$$

则对于任意整数 $k$：

* 乘法同余：
  $$
  ka \equiv kb \pmod{m}
  $$
* 加法同余：
  $$
  a+c \equiv b+c \pmod{m}
  $$

---

## 数学推导

**二进制构造方式**

设当前数字（前 $i$ 位的二进制）为：

$$
x_i
$$

下一位 $b$ 到来后，新数字为：

$$
x_{i+1} = 2x_i + b
$$

---

**将等式映射到模运算世界**

定义：

$$
r_i = x_i \bmod 5
$$

由定义：

$$
x_i \equiv r_i \pmod{5}
$$

将等式
$$x_{i+1} = 2x_i + b$$
取模：

$$
x_{i+1} \bmod 5 = (2x_i + b) \bmod 5
$$

**接下来，利用同余定理替换 $x_{i+1}$ 和 $x_i$：**

因为：

$$
x_i \equiv r_i \pmod{5}
$$

所以：

$$
2x_i \equiv 2r_i \pmod{5}
$$

即：

$$
2x_i + b_i \equiv 2r_i + b_i \pmod{5}
$$

因此：

$$
x_{i+1} \equiv 2r_i + b \pmod{5}
$$

由定义可知：

r_{i+1} = x_{i+1} \bmod 5

也就是说：

$$
r_{i+1} = (2r_i + b) \bmod 5
$$

---

**公式为何绝对正确？**

其正确性来自于：

1. **二进制左移等价于乘 2（数学结构）**
2. **模运算保持加法、乘法相容（同余定理）**

所以更新余数完全等价于更新完整二进制数字，只是代价从“跟踪千位大数” → “跟踪 0~4 的余数”。

---

## 例题讲解

### [1018. 可被 5 整除的二进制前缀](https://leetcode.cn/problems/binary-prefix-divisible-by-5/description/)

```text
给定一个由 `0` 和 `1` 组成的二进制数组 nums（从左到右表示一个二进制数的逐位构建过程），对于每个位置 i（0 <= i < nums.length），你需要判断从 nums[0] 到 nums[i] 形成的二进制数是否能被 5 整除。

返回一个布尔数组 answer，其中 answer[i] == true 表示对应的前缀可以被 5 整除，否则为 false。

示例 1：
输入：nums = [0,1,1]
输出：[true,false,false]
解释：
- 前缀 0 → 0 % 5 = 0 → true  
- 前缀 01 → 1 % 5 = 1 → false  
- 前缀 011 → 3 % 5 = 3 → false

示例 2：
输入：nums = [1,1,1]
输出：[false,false,false]

提示：
1 <= nums.length <= 10^5
nums[i] ∈ {0, 1}
```

```python
class Solution:
    def prefixesDivBy5(self, nums: List[int]) -> List[bool]:
        ans = [False] * len(nums)
        x = 0
        for i, bit in enumerate(nums):
            x = (x << 1 | bit) % 5
            ans[i] = x == 0
        return ans
```

---

## 经典例题

| 题号   | 题目                                                                                          | 标签            |
| ---- | ------------------------------------------------------------------------------------------- | ------------- |
| 1018 | [可被 5 整除的二进制前缀](https://leetcode.cn/problems/binary-prefix-divisible-by-5/)                 | 余数 DP / 状态转移  |
| 1015 | [可被 K 整除的最小整数](https://leetcode.cn/problems/smallest-integer-divisible-by-k/)               | 数学 / 同余 / BFS |
| 1262 | [可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/)                  | 余数 DP / 分类讨论  |
| 2435 | [矩阵中和能被 K 整除的路径](https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/) | 网格 DP / 余数 DP |

---
