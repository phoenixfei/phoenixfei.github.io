---
title: "位操作技巧"
categories: [ds-algo]

layout: post
---

对整数的二进制位进行操作，如与（AND）、或（OR）、异或（XOR）、左移、右移等操作。

## 原码、反码、补码

| 名称                 | 含义                    | 说明         |
| ------------------ | --------------------- | ---------- |
| 原码 | 最高位为符号位，其余位为绝对值       | 人类直观表示方式   |
| 反码 | 正数同原码，负数符号位不变，其他位按位取反 | 早期计算机中间表示  |
| 补码 | 正数同原码，负数 = 对正数按位取反 +1 | 现代计算机标准表示法 |

> 所有现代计算机用的都是 **补码（Two's Complement）**，它的好处是：
> 
> * 正数和负数可以统一用一个加法电路处理
> * 没有两个“0”的表示（反码有+0和-0）
> * 减法可视为加上一个负数

---

## 举例（以8位整数为例）

**正数：`5` 的原码、反码、补码：**

| 编码类型 | 值    | 二进制解释      |
| ---- | ---- | ---------- |
| 原码   | `+5` | `00000101` |
| 反码   | `+5` | `00000101` |
| 补码   | `+5` | `00000101` |

> 正数在三种编码中是一样的

**负数：`-5` 的原码、反码、补码：**

| 编码类型 | 值    | 二进制解释                   |
| ---- | ---- | ----------------------- |
| 原码   | `-5` | `10000101`（符号1 + 绝对值）   |
| 反码   | `-5` | `11111010`（符号位不变，其它位取反） |
| 补码   | `-5` | `11111011`（反码 + 1）      |

> 现代计算机只使用补码存储整数！

---

**补码运算规则总结（重点）：**

1. 正数的补码 = 原码 = 反码
2. 负数的补码 = 原码符号位不变 + 其它位按位取反 + 最后 +1
3. `-x = ~x + 1` 反向生成负数（按位取反，末位加一）
4. 减法可转为加法：`a - b = a + (~b + 1)`

---

**特殊整数的原码、反码和补码：**

| 整数 | 原码      | 反码      | 补码      |
| ---- | --------- | --------- | --------- |
| 1    | 0000-0001 |           |           |
| -1   | 1000-0001 | 1111-1110 | 1111-1111 |
| -127 | 1111-1111 | 1000-0000 | 1000-0001 |
| 0    | 0000-0000 |           |           |
| -128 |           |           | 1000-0000 |

> 在二进制中，0有正0与负0两种表示方法。**但是，0只需要一个。**因此，-0被人为拿来表示一个最小的数。
> 
> -128的补码为1000-0000。这个补码不是真正的补码（人为规定），且没有原码与反码。

## 基本位操作符

| 符号   | 描述               | 位运算规则                                 |
|------| :----------------- | :----------------------------------------- |
| &    | 与                 | 两个位都为1时，结果才为1                   |
| \|   | 或                 | 两个位都为0时，结果才为0                   |
| ^    | 异或               | 两个位**相异时为1，相同时为0**             |
| ~    | 取反（单目运算符） | 0 变 1，1 变 0                             |
| \<<  | 左移               | 各二进位全部左移若干位，高位丢弃，低位补 0 |
| \>>  | 右移               | 各二进位全部右移若干位，**高位补符号位**   |
| \>>> | 无符号右移         | 各二进位全部右移若干位，**高位补0**        |

**注意：**
1. 位操作只能用于**整形（字符）**数据
2. 位操作的优先级比较低，因此尽量使用**扩号**来确保运算顺序
3. 另外位操作还有一些复合操作符，如 &=、\|=、 ^=、\<<=、\>>=

## 常用位操作技巧

### 判断奇偶性

```python
def is_odd(n):
    return (n & 1) == 1

print(is_odd(5))   # True
print(is_odd(8))   # False
```

解释：
* 任何整数的**最低位决定奇偶性**
* `x & 1` 提取最低位，如果是1，则为奇数

---

### 交换两个数（不使用临时变量）

```python
def swap(a, b):
    a = a ^ b
    b = a ^ b  # 相当于 b = (a ^ b) ^ b = a
    a = a ^ b  # 相当于 a = (a ^ b) ^ a = b
    return a, b

print(swap(5, 10))  # (10, 5)
```

解释：
* 利用异或的特性：`x ^ x = 0`, `x ^ 0 = x`
* 不需要使用额外内存

---

### 提取最低位的 1（lowbit）

```python
def lowbit(x):
    return x & -x

print(bin(12))        # 0b1100
print(bin(lowbit(12)))  # 0b100
```

解释：
* `-x` 在补码中等于 `~x + 1`，会把最低的1留下，其它清零
* 常用于树状数组、快速枚举子集

---

### 去除最低位的 1

```python
def remove_lowest_bit(x):
    return x & (x - 1)

print(bin(12))                # 0b1100
print(bin(remove_lowest_bit(12)))  # 0b1000
```

解释：
* `x - 1` 会把最低的1变成0，右边的0变成1
* 常用于**计数二进制中1的个数**

---

### 统计整数中1的个数（Hamming Weight）

```python
def count_ones(x):
    count = 0
    while x:
        x &= (x - 1)
        count += 1
    return count

print(count_ones(15))  # 4
```

解释：
* 每次 `x & (x - 1)` 去掉一个 1
* 时间复杂度 = 二进制中1的个数（比按位扫描快）

---

### 判断某一位是否为1

```python
def is_bit_set(x, k):
    return ((x >> k) & 1) == 1

print(is_bit_set(5, 0))  # True  (0001)
print(is_bit_set(5, 1))  # False
```

解释：
* 将第 `k` 位右移到最低位，然后与1做 & 运算

---

### 设置 / 清除 / 翻转某一位

```python
# 将第k位（从0开始索引）置为1
def set_kth_bit(x, k):
    return x | (1 << k)

# 将第k位（从0开始索引）置为0
def clear_kth_bit(x, k):
    return x & ~(1 << k)

# 将第k位（从0开始索引）翻转，即1->0；0->1
def toggle_kth_bit(x, k):
    return x ^ (1 << k)

print(bin(set_kth_bit(8, 1)))     # 0b1010
print(bin(clear_kth_bit(10, 1)))  # 0b1000
print(bin(toggle_kth_bit(10, 1))) # 0b1000
```

解释：
* `1 << k` 构造一个只有第 `k` 位是1 的掩码

---

### 判断是否是 2 的幂

```python
def is_power_of_two(x):
    return x > 0 and (x & (x - 1)) == 0

print(is_power_of_two(8))   # True
print(is_power_of_two(10))  # False
```

解释：
* 2 的幂在二进制中只有一个 1
* `x & (x - 1)` 可以去掉这个 1，所以结果应为 0

---

### Python 模拟无符号右移（逻辑右移）

```python
def logical_rshift(x, n, bits=32):
    if x < 0:
        x += 2 ** bits
    return (x >> n) & ((1 << (bits - n)) - 1)

print(logical_rshift(-4, 1))  # 2147483646
```

解释：
* Python 默认是**算术右移**（保留符号），逻辑右移需要手动补零

---

### 快速乘法（模拟位操作）

```python
def fast_mul(a, b, mod):
    res = 0
    while b:
        if b & 1:
            res = (res + a) % mod
        a = (a + a) % mod
        b >>= 1
    return res

print(fast_mul(7, 13, 1000))  # 91
```

解释：
* 避免整数乘法溢出，用“加+位移”模拟乘法。
* 可用于**快速幂、模乘**

---

### 位操作技巧一览（Python）

| 技巧                           | 作用               | 示例代码                   |
| ---------------------------- | ---------------- | ---------------------- |
| `x & 1`                      | 判断奇偶性            | `is_odd(x)`            |
| `x ^ y`                      | 无临时变量交换          | `swap(x, y)`           |
| `x & -x`                     | 提取最低位的 `1`       | `lowbit(x)`            |
| `x & (x - 1)`                | 去掉最低位的 `1`       | `remove_lowest_bit(x)` |
| `while x: x &= (x - 1)`      | 统计二进制中 `1` 的个数   | `count_ones(x)`        |
| `(x >> k) & 1`               | 判断第 `k` 位是否为 `1` | `is_bit_set(x, k)`     |
| `x \| (1 << k)`              | 设置第 `k` 位为 `1`   | `set_kth_bit(x, k)`    |
| `x & ~(1 << k)`              | 清除第 `k` 位        | `clear_kth_bit(x, k)`  |
| `x ^ (1 << k)`               | 翻转第 `k` 位        | `toggle_kth_bit(x, k)` |
| `x > 0 and x & (x - 1) == 0` | 判断是否是 `2` 的幂     | `is_power_of_two(x)`   |


## 高阶技巧

### 利用位操作实现加法

首先看十进制是如何做的： 5+7=12，三步走 

- 第一步：相加各位的值，不算进位，得到2。 
- 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。  
- 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 

同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 

- 第一步：相加各位的值，不算进位，得到010，**二进制每位相加就相当于各位做异或操作**，101^111。 
- 第二步：计算进位值，得到1010，**相当于各位进行与操作得到101，再向左移一位得到1010**，(101&111)<<1。  
- 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。  

```java
public int getSum(int num1,int num2) {
    while(num2 != 0){
        int temp = num1 ^ num2;
        num2 = (num1 & num2) << 1;
        num1 = temp;
    }
    return num1;
}
```

```python
def getSum(a: int, b: int) -> int:
    MAX = 0x7FFFFFFF  # 最大32位整数（正数）
    MASK = 0xFFFFFFFF  # 32位掩码，模拟无符号整数

    while b != 0:
        temp = (a ^ b) & MASK
        b = ((a & b) << 1) & MASK
        a = temp

    # 如果 a 超过了最大正整数范围，表示它是负数补码
    return a if a <= MAX else ~(a ^ MASK)
```

> 在 Python 中： int 是 不限制位数的“无限精度整数” ，你可以表示任意大的正数或负数。
> 
> 所以，必须用 MASK 和 MAX 来模拟补码行为。

---

### 子集枚举

```python
def subset_enum(arr):
    n = len(arr)
    for mask in range(1 << n):
        subset = []
        for i in range(n):
            if (mask >> i) & 1:
                subset.append(arr[i])
        print(subset)

subset_enum([1, 2, 3])
```

解释：
* 用一个整数的二进制位表示集合的每个元素是否被选中

---

### 状态压缩 DP 示例

```python
n = 3
dp = [[float('inf')] * n for _ in range(1 << n)]
dp[1][0] = 0  # 从城市0出发，状态为 001

# 示例只是状态压缩DP框架，如TSP问题中会使用
```

---
