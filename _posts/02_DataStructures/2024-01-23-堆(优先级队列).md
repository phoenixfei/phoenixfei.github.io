---
title: "堆（Heap）：优先级的秘密武器"
categories: [02_DataStructures]
tags: [heapq, queue, python]

math: true
layout: post
---

在算法的世界里，堆（Heap）是一种能让我们高效地找到“最值”的数据结构，它是优先级队列（Priority Queue）的核心实现。

> **堆是一种实现优先级队列的常用数据结构。**
> 
> 也就是说，**优先级队列是“概念”，堆是它的“实现方式”之一。**

---

### 基本介绍

堆是一种**完全二叉树**，满足特定的顺序性质：

* **大顶堆（Max-Heap）**：每个节点的值 ≥ 其子节点的值。
* **小顶堆（Min-Heap）**：每个节点的值 ≤ 其子节点的值。

堆常用于实现**优先队列**，可以在 `O(log n)` 时间内完成插入和删除最大/最小元素。

**堆的基本操作：**

| 操作          | 时间复杂度    | 描述            |
| ----------- | -------- | ------------- |
| 插入（push）    | O(log n) | 将元素插入堆中，向上调整堆 |
| 弹出（pop）     | O(log n) | 删除堆顶元素，向下调整堆  |
| 查看堆顶（peek）  | O(1)     | 查看最大或最小元素     |
| 建堆（heapify） | O(n)     | 将一个无序数组建成堆结构  |

---

### Python 的 `heapq`

* 默认实现的是**小顶堆**
* 若需大顶堆：插入元素时取负值 `-x`，取出时再取负

**常用 API 总览：**

| 函数名                             | 说明                     |
| ------------------------------- | ---------------------- |
| `heapq.heapify(list)`           | 原地将列表转为堆结构（小顶堆）        |
| `heapq.heappush(heap, item)`    | 向堆中插入一个元素              |
| `heapq.heappop(heap)`           | 弹出最小的元素                |
| `heapq.heappushpop(heap, item)` | 先 push 后 pop（效率比分别调用高） |
| `heapq.heapreplace(heap, item)` | 先 pop 后 push（效率比分别调用高） |
| `heapq.nlargest(k, iterable)`   | 取前 k 大                 |
| `heapq.nsmallest(k, iterable)`  | 取前 k 小                 |


```python
import heapq

# 小顶堆
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappop(heap)  # 2

# 大顶堆
max_heap = []
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -2)
-heapq.heappop(max_heap)  # 5
```

---

### 懒删除堆

在使用 **堆（heapq）** 作为优先队列时，经常会遇到两个麻烦：

1. **删除指定元素**：`heapq` 只能删除堆顶，不能直接删除堆中任意元素。
2. **更新元素**：如果某个元素的优先级（关键字）发生变化，需要把它更新为新值，但堆里还留着旧值。

如果我们硬要“中途删除”，需要在堆里查找并重新调整，这会导致 **O(n)** 的复杂度，丢掉了堆的高效性。

于是有了一个经典技巧：**懒删除（Lazy Deletion）**。

---

**懒删除的思路很简单：**

* **插入新值**：照常 `heappush`。
* **删除某个值**：不动堆，只在一个 `dict` 或 `set` 里标记该值“已删除”。
* **取堆顶/弹出**：如果堆顶值已经被标记删除，就丢掉它，继续弹下一个。

换句话说，堆中可能存在“过期元素”，但我们不急着清理它们，直到它们出现在堆顶时，才真正删除。

---

**应用场景**

**1. 最短路径（Dijkstra、A\*）**

在 Dijkstra 算法中，某个节点的距离可能被更新多次。

* 旧的距离我们没法直接从堆里删除。
* 采用懒删除：直接 push 新距离，等旧值被 pop 出来时，如果发现它不是“当前最优值”，就丢弃。

这是 Dijkstra 常见的 Python 实现方式。

---

**2. 滑动窗口最值**

例如：维护一个长度为 `k` 的滑动窗口，要求随时输出最大值。

* 窗口滑动时，移出的元素标记为“删除”。
* 窗口新加入的元素 push 到堆。
* 每次取堆顶时，如果堆顶已过期，就懒删除继续弹。

这样就能高效维护窗口内的最大/最小值。

---

**3. 动态集合最值查询**

我们想要支持操作：

* `add(x)`
* `remove(x)`
* `get_min()`

懒删除堆可以轻松做到，复杂度仍然对数级。

---

**实现原理**

一个典型的懒删除堆结构包含：

1. **一个最小堆**（`heapq` 实现）。
2. **一个字典/哈希表**（记录哪些元素“已删除但还没清理”）。

伪代码：

```
push(x):
    heap.push(x)

remove(x):
    invalid[x] += 1   # 标记删除

top():
    while heap 非空 且 heap.top 在 invalid 中:
        heap.pop()
        invalid[x] -= 1
        如果 invalid[x] == 0: 删除键
    return heap.top
```

---

**优点**

* 避免堆中间删除，操作简单。
* 插入、删除标记、弹出保持 **O(log n)**。
* 实现优先队列 + 删除/更新功能，非常实用。

**缺点**

* 堆中会存放一些“无效元素”，可能导致 **内存占用变大**。
* 如果长时间不访问堆顶，过期元素不会被清理。

一般在算法场景（如最短路、滑动窗口）中，这个缺点不明显。

**总结**

懒删除堆是一种 **以空间换时间** 的技巧。

* 它不改变堆的底层逻辑，而是在逻辑层面解决“删除/更新”问题。
* 在 Python 的算法实现中（尤其是 Dijkstra、滑动窗口、任务调度等），是非常高频的模式。

一句话总结：

> **遇到堆中间删除或更新时，别硬删，标记一下，等它到堆顶再删。**

---

### 手撕堆排序算法

堆排序利用堆的性质来进行排序，时间复杂度为 `O(n log n)`，不稳定排序。

**排序流程（大顶堆）**：

1. 建堆（大顶堆）
2. 不断将堆顶元素与末尾元素交换，并调整剩余部分为大顶堆

```python
def heap_sort(nums):
    # ----------- 建立大顶堆 -----------
    def heapify(nums, n, i):
        largest = i  # 初始化最大值为当前根
        left = 2 * i + 1  # 左孩子
        right = 2 * i + 2  # 右孩子

        # 如果左孩子存在且比当前最大还大
        if left < n and nums[left] > nums[largest]:
            largest = left

        # 如果右孩子存在且比当前最大还大
        if right < n and nums[right] > nums[largest]:
            largest = right

        # 如果最大值不是根，交换并继续 heapify
        if largest != i:
            nums[i], nums[largest] = nums[largest], nums[i]
            heapify(nums, n, largest)

    n = len(nums)

    # ----------- 第一步：建堆 -----------
    for i in range(n // 2 - 1, -1, -1):  # 从最后一个非叶子节点开始
        heapify(nums, n, i)

    # ----------- 第二步：排序 -----------
    for i in range(n - 1, 0, -1):
        # 当前堆顶是最大值，交换到末尾
        nums[0], nums[i] = nums[i], nums[0]
        # 重新调整堆
        heapify(nums, i, 0)
```

---

### 数据流的中位数

设计一个数据结构，支持动态地向数据流中插入数字，并能在任意时刻求出中位数。

要求：

* 支持高效插入（O(log n)）
* 支持高效查询中位数（O(1)）

接口示例：

```python
addNum(num: int) -> None
findMedian() -> float
```

---

**核心思路：双堆（最大堆 + 最小堆）**

中位数将数据分为两半：

* 左半部分：所有数字 ≤ 中位数
* 右半部分：所有数字 ≥ 中位数

因此我们可以用：

* **最大堆（left）**：保存较小的一半，堆顶为左边最大值；
* **最小堆（right）**：保存较大的一半，堆顶为右边最小值。

保持这两个堆平衡：

* `len(left)` 与 `len(right)` 之差不超过 1 ，在有奇数个数时，left 比 right 多 1 个数。
* 保证 `max(left) <= min(right)`

这样：

* 若总数为奇数 → 中位数是 left 的堆顶。
* 若为偶数 → 中位数为两堆堆顶的平均值。

---

**示意图**：

> Python中，默认为小顶堆；大顶堆通过存元素的负数值来设计。

```
左堆（最大堆）     右堆（最小堆）
[-3, -2, -1]     [4, 5, 6]
  ↑               ↑
最大值            最小值
```

中位数 = (3 + 4) / 2 = 3.5

---

**代码实现（Python）**

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.left = []  # 入堆的元素取相反数，变成最大堆
        self.right = []  # 最小堆

    def addNum(self, num: int) -> None:
        if len(self.left) == len(self.right):
            heappush(self.left, -heappushpop(self.right, num))
        else:
            heappush(self.right, -heappushpop(self.left, -num))

    def findMedian(self) -> float:
        if len(self.left) > len(self.right):
            return -self.left[0]
        return (self.right[0] - self.left[0]) / 2
```

---

### 经典例题

| 题号   | 题目                                                                                                | 标签              |
| ---- | ------------------------------------------------------------------------------------------------- | --------------- |
| 1353 | [最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)        | 贪心 / 堆 / 模板题    |
| 2163 | [删除元素后和的最小差值](https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/) | 贪心 / 堆 / 提升题    |
| 2349 | [设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/)                        | 懒删除堆 / 设计 / 提升题 |
| 3408 | [设计任务管理器](https://leetcode.cn/problems/design-task-manager/)                                      | 懒删除堆 / 设计 / 提升题 |
| 295  | [数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)                             | 双堆 / 数据流 / 模板题  |

---
