---
title: "字典树：高效字符串检索利器"
categories: [02_DataStructures]
tags: [tree]

math: true
layout: post
---

字典树（Trie，又称前缀树、单词查找树） 是一种高效的字符串存储与搜索数据结构。

它的核心思想是： 利用字符串的公共前缀来节省存储空间和加速搜索过程。换句话说，不是为每个字符串单独保存一条完整路径，而是让它们在公共前缀处共享节点。

---

## 结构示意

假设要存储以下单词：

```
apple, app, bat
```

字典树结构如下：

```
(root)
 ├── a
 │    └── p
 │         └── p  (end of "app")
 │              └── l
 │                   └── e  (end of "apple")
 └── b
      └── a
           └── t  (end of "bat")
```

每个节点通常包含：

* 若干子节点（对应后续字符）
* 一个标记 `isEnd` 表示是否为某个单词的结尾


---

## isEnd的作用和粒度

在 Trie 中，**每个节点代表一个前缀**，
而 `isEnd` 是「这个前缀是否恰好构成一个完整单词」的标志。

因此：

* **每个节点** 都有一个 `isEnd` 属性；
* 它 **不与其他子节点共享**；
* 只有当我们插入到单词的最后一个字符时，才将该节点的 `isEnd = True`。

---

假设我们插入单词：

```
apple
app
```

Trie 的逻辑结构如下：

```
(root)
 └─ a
     └─ p
         └─ p (isEnd = True)        ← 对应 "app"
             └─ l
                 └─ e (isEnd = True) ← 对应 "apple"
```

每个节点都**独立拥有**自己的 `isEnd` 属性：

* `"app"` 的最后一个节点 `p` 标记为 `isEnd = True`
* `"apple"` 的最后一个节点 `e` 也标记为 `isEnd = True`
* 其他节点只是中间前缀，不设 `isEnd`

---

假设我们插入单词：

```
abc
abd
```

```
(root)
 └─ a
     └─ b
         ├─ c (isEnd = True)   ← "abc" 结束在这里
         └─ d (isEnd = True)   ← "abd" 结束在这里
```

节点 `b` 不需要 `isEnd = True` 的原因：

* 节点 `b` 对应的前缀是 `"ab"`
* `"ab"` 并不是一个完整单词（只是公共前缀）

所以：
* 它的 `isEnd = False`
* 但它的 `children` 包含 `c` 和 `d`，分别表示两条后续路径

> `isEnd` 是节点自身的属性，**只用于标记“是否有单词恰好在这里结束”**， 与它有多少子节点、是否有分支无关。

---

## 基本操作

### 节点定义

在 Trie 中，**每个节点代表一个前缀**，
而 `isEnd` 是「这个前缀是否恰好构成一个完整单词」的标志。

因此：

* **每个节点** 都有一个 `isEnd` 属性；
* 它 **不与其他子节点共享**；
* 只有当我们插入到单词的最后一个字符时，才将该节点的 `isEnd = True`。

```java
class TrieNode {
    TrieNode[] children = new TrieNode[26];  // 存放子节点 
    boolean isEnd = false;                   // 当前节点是否是单词结尾
}
```

---

### 插入单词

逐字符向下建立节点，若路径不存在则创建新节点，最后标记为结尾。

```java
class Trie {
    TrieNode root = new TrieNode();

    void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isEnd = true;
    }
}
```

---

### 搜索单词

沿路径逐字符匹配，若途中节点不存在则返回 false；若走到末尾并且 `isEnd` 为 true，则单词存在。

```java
boolean search(String word) {
    TrieNode node = root;
    for (char c : word.toCharArray()) {
        int idx = c - 'a';
        if (node.children[idx] == null) return false;
        node = node.children[idx];
    }
    return node.isEnd;
}
```

---

### 判断前缀是否存在

与搜索类似，但不要求最后节点是单词结尾。

```java
boolean startsWith(String prefix) {
    TrieNode node = root;
    for (char c : prefix.toCharArray()) {
        int idx = c - 'a';
        if (node.children[idx] == null) return false;
        node = node.children[idx];
    }
    return true;
}
```

---

## 时间复杂度分析

| 操作   | 时间复杂度 | 说明      |
| ---- | ----- | ------- |
| 插入单词 | O(L)  | L 为单词长度 |
| 搜索单词 | O(L)  | 按字符遍历路径 |
| 前缀查询 | O(L)  | 同上      |

相比哈希表，Trie 更适合 **前缀搜索 / 模糊匹配 / 自动补全** 等场景。

**一句话总结**：
字典树（Trie）是一种利用前缀共享的树形结构，能在 **O(L)** 时间内实现单词插入与前缀搜索，是字符串处理领域最常用的数据结构之一。

---

## Python实现

```python
class TrieNode:
    def __init__(self):
        self.children = {}  # 存放子节点 {'c': TrieNode(), 'd': TrieNode(), ...}
        self.is_end = False # 当前节点是否是单词结尾
      
class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """插入单词"""
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()  # 若不存在则创建新节点
            node = node.children[ch]
        node.is_end = True  # 标记为单词结束

    def search(self, word):
        """查找完整单词是否存在"""
        node = self._find_node(word)
        return node is not None and node.is_end

    def startsWith(self, prefix):
        """是否存在以 prefix 为前缀的单词"""
        return self._find_node(prefix) is not None

    def _find_node(self, prefix):
        """辅助方法，查找前缀末尾的节点"""
        node = self.root
        for ch in prefix:
            if ch not in node.children:
                return None
            node = node.children[ch]
        return node
```

---

## 经典例题

| 题号  | 题目                                                                        | 标签               |
| --- | ------------------------------------------------------------------------- | ---------------- |
| 208 | [实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/) | Trie / 字典树 / 模板题 |
| 677 | [键值映射](https://leetcode.cn/problems/map-sum-pairs/)                       | Trie / 映射 / 提升题  |

---
