---
title: "LRU：最近最少使用缓存"
categories: [02_DataStructures]
tags: [tree]

math: true
layout: post
---

**LRU（Least Recently Used）** 是一种常见的 **缓存淘汰策略**，用于在缓存空间有限时，**优先淘汰最久未使用的数据**。

> 直观理解：如果某个数据很久没用过，而新的数据要加入缓存，就先把“最久没用的那个”移除。

**常用缓存策略：**

| 策略   | 淘汰逻辑   | 特点     |
| ---- | ------ | ------ |
| LRU  | 最久未使用的 | 最常用    |
| LFU  | 使用最少的  | 更精准但复杂 |
| FIFO | 最先进入的  | 简单但易失效 |
| MRU  | 最近使用的  | 特定场景有用 |

---

### 设计思路

一个典型的 LRU 缓存类应支持两个操作：
```python
get(key)      # 如果 key 存在于缓存中，返回对应的 value，并将其标记为最近使用
put(key, val) # 插入或更新 key 对应的值。如果超出容量，要删除最久未使用的数据
```

---

**设计思路：**

为了在 **O(1)** 时间完成 `get` 和 `put`，我们需要：
1. 哈希表（dict）
   * 快速定位某个 key 是否存在，以及对应的节点位置
2. 双向链表（Doubly Linked List）
   * 实现节点的快速插入与删除
   * 维护访问顺序，头部是最近访问，尾部是最久访问

---

### 方法一：Python的`OrderedDict`

**方法 1：使用 `collections.OrderedDict`**
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        # 初始化缓存容量
        self.capacity = capacity
        # 使用 OrderedDict 来保存缓存中的键值对，保持元素插入顺序
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        """
        获取 key 对应的值，如果存在，将其标记为最近使用，并返回对应的 value；否则返回 -1。
        """
        if key not in self.cache:
            # 当键不在缓存中，直接返回 -1
            return -1
        
        # 当键存在时，为了维护“最近使用”顺序，将该键移到 OrderedDict 的末尾
        self.cache.move_to_end(key)  # 默认 last=True，表示移到最后
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        """
        向缓存中插入或者更新键 key 对应的 value，并按照 LRU 策略维护缓存。
        """
        if key in self.cache:
            # 如果 key 已存在，先更新其值，同时将其移到末尾
            self.cache.move_to_end(key)
        self.cache[key] = value

        if len(self.cache) > self.capacity:
            # 当缓存超出容量限制时，淘汰最久未使用的元素
            # popitem(last=False) 会删除第一个插入的（或说最久未使用的）键值对
            self.cache.popitem(last=False)
```

### 方法二：手写双向链表 + 哈希表

```python
class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.key_to_node = dict()  # key -> Node

        # 初始化双向链表的伪头尾
        self.head = Node(0, 0)  # 伪头部（最近使用）
        self.tail = Node(0, 0)  # 伪尾部（最久未使用）
        self.head.next = self.tail
        self.tail.prev = self.head

    # 内部函数：从链表中移除一个节点
    def _remove(self, node):
        prev, nxt = node.prev, node.next
        prev.next = nxt
        nxt.prev = prev

    # 内部函数：将一个节点添加到 head 后
    def _add(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    # 获取值并标记为最近使用
    def get(self, key: int) -> int:
        if key not in self.key_to_node:
            return -1
        node = self.key_to_node[key]
        self._remove(node)   # 从原位置删除
        self._add(node)      # 插入到头部
        return node.val

    # 插入或更新值，并维护 LRU 策略
    def put(self, key: int, value: int) -> None:
        if key in self.key_to_node:
            self._remove(self.key_to_node[key])  # 删除旧节点

        new_node = Node(key, value)
        self._add(new_node)                # 添加新节点到头部
        self.key_to_node[key] = new_node         # 更新哈希表

        if len(self.key_to_node) > self.capacity:
            # 删除链表尾部节点（最久未使用）
            lru = self.tail.prev
            self._remove(lru)
            del self.key_to_node[lru.key]
```

---

### 经典例题

| 题号   | 题目                                                                      | 标签                 |
| ---- |-------------------------------------------------------------------------| ------------------ |
| 146  | [LRU缓存](https://leetcode.cn/problems/lru-cache/)                        | 模板题                |
| 460  | [LFU缓存](https://leetcode.cn/problems/lfu-cache/)                        | 变体题                |

---
