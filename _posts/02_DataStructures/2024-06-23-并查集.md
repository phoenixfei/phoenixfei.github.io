---
title: "并查集：高效管理集合的秘密武器"
categories: [02_DataStructures]
tags: [graph]

math: true
layout: post
---

并查集是一种维护集合间合并与查询关系的数据结构，尤其适用于处理连通性问题。常用于图的连通块判断、最小生成树（如 Kruskal 算法）、好友圈、冗余连接等场景。

---


### 设计思路

[并查集构建过程-视频讲解](https://www.bilibili.com/video/BV1zZRSYUEWV/)

**并查集的核心思想是：**将多个不相交的集合组织成一个森林，森林中的每棵树代表一个集合。通过 **合并（Union）** 操作将两个集合合并，或者通过 **查找（Find）** 操作判断两个元素是否属于同一个集合。

并查集有两个非常重要的操作：
1. **Find**：查询某个元素所在的集合（即找到该元素的根节点）。
2. **Union**：将两个元素所在的集合合并。

并查集常见的应用场景，特别是：
* **网络连通性问题**：比如图中的连通分量。
* **图的最小生成树算法**：如 Kruskal 算法。
* **动态连通性问题**：如判断两个节点是否在同一个集合中。
* **网络中联通组件的管理**：比如网络中是否存在可达路径。

---

为了提高并查集的效率，我们通常会使用以下两种优化技巧：
1. **路径压缩（Path Compression）**：
   * 在 **Find** 操作时，优化每次查找的路径，使得树变得扁平，从而加快后续的查找操作。
   * 具体方法：当我们查找一个节点的父节点时，将路径上的所有节点直接连接到根节点。
2. **按秩合并（Union by Rank）**：
   * 在 **Union** 操作时，总是将较小的树合并到较大的树上，避免树的高度过大。
   * 具体方法：每次合并时，将较小的树（深度较小）作为子树，挂到较大的树下。

> 秩（rank） 是一种用于优化合并操作的策略。它的本质是估算树的高度或大小，用来决定如何将两个集合合并，以保持整棵树尽量“扁平”，加快后续 find 操作的效率。

通过这两种优化，**并查集**的时间复杂度接近 **O(α(n))**，其中 `α(n)` 是 **阿克曼函数的反函数**，增长极其缓慢，几乎可以视为常数时间。

---

**操作说明：**
1. **初始化 `UnionFind(n)`**：
   * 初始化父节点数组 `parent`，每个节点的父节点指向自己。
   * 初始化秩数组 `rank`，用于优化合并操作，默认为 1。
2. **`find(x)`**：
   * 查找节点 `x` 的根节点。如果 `x` 不是根节点，就通过递归查询其父节点，同时进行路径压缩（将路径上的节点直接指向根节点）。
3. **`union(x, y)`**：
   * 查找节点 `x` 和节点 `y` 的根节点，若它们属于不同集合，则合并它们。
   * 合并时，采用按秩合并的策略，即将秩较小的树合并到秩较大的树下，从而保持树的高度较小，优化后续查询。
4. **`connected(x, y)`**：
   * 判断节点 `x` 和节点 `y` 是否属于同一个集合。如果它们的根节点相同，说明它们在同一集合。

### Python实现

```python
class UnionFind:
    def __init__(self, n):
        # 一开始有 n 个集合 {0}, {1}, ..., {n-1}
        self.parent = list(range(n))  # 父节点数组
        self.rank = [1] * n           # 秩（Rank）是一个近似表示树的高度的值（并非精确高度）
        self.cc = n                   # 连通分量数，初始化为 n
        # self._size = [1] * n        # 集合大小

    def find(self, x):
        # 查找 x 的根节点，并进行路径压缩
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]

    def union(self, x, y):
        # 按秩合并：将 x 和 y 合并
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX == rootY:
            return
            
        # 合并操作：按集合大小合并
        if self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        elif self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1
        self.cc -= 1  # 合并成功，连通分量减 1

    def connected(self, x, y):
        # 判断 x 和 y 是否在同一集合
        return self.find(x) == self.find(y)
```

### 经典例题
- [3608. 包含 K 个连通分量需要的最小时间](https://leetcode.cn/problems/minimum-time-for-k-connected-components/)

---
