---
title: "掌握链表：指针背后的秘密"
categories: [02_DataStructures]
tags: [linked list]

math: true
layout: post
---

链表（Linked List）是数据结构中的经典角色，它像一串珠子，每个节点都指向下一个，让你灵活地在序列中增删元素。

---

## 链表基础知识

链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个结点里存到下一个结点的指针（Pointer）。

每个节点包含两部分：

- **数据域（value）**：存储节点数据
- **指针域（next）**：指向下一个节点的引用（地址）

---

由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度。 但是，查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(longN)和O(1)。

使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

> 顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元素的线性结构。

---

**链表的分类**

| 链表类型         | 结构特点                              | 应用场景                      |
|------------------|-------------------------------------|------------------------------|
| **单向链表**     | 每个节点指向下一个节点                | 基础链表操作、简单数据流遍历 |
| **双向链表**     | 节点含有前驱和后继指针                | 双向遍历、LRU缓存等           |
| **循环链表**     | 尾节点指向头节点，形成环形             | 约瑟夫环、环状资源管理       |
| **带头节点链表** | 额外设置虚拟头节点（dummy node）       | 简化插入、删除等边界操作     |

**链表的优缺点**

| 优点                          | 缺点                         |
|-------------------------------|------------------------------|
| 动态大小，插入删除操作高效    | 访问节点需要从头遍历，查找慢 |
| 内存利用率高（按需分配节点）  | 额外空间占用（指针域）       |
| 不需要连续内存空间            | 反向访问不方便（单链表）     |

**链表常用操作**

| 操作             | 实现思路                               | 时间复杂度         |
|------------------|--------------------------------------|--------------------|
| 创建链表         | 依次创建节点，指针相连                 | O(n)               |
| 遍历链表         | 从头节点开始，顺序访问                  | O(n)               |
| 插入节点         | 修改前驱指针，连接新节点                | O(1)（已定位节点） |
| 删除节点         | 修改前驱指针，跳过删除节点              | O(1)（已定位节点） |
| 反转链表         | 改变指针方向，头插法或递归              | O(n)               |
| 查找节点         | 从头遍历，比较数据域                    | O(n)               |

**链表与数组的对比**

| 维度          | 链表                         | 数组                       |
|---------------|------------------------------|----------------------------|
| 内存布局      | 非连续，分散                   | 连续                       |
| 访问效率      | 只能顺序访问，随机访问慢       | 支持随机访问，O(1)          |
| 插入删除效率  | 插入删除快，调整指针即可       | 插入删除慢，需移动元素      |
| 空间开销      | 多存储指针，空间开销较大       | 无额外空间开销             |
| 大小调整      | 动态灵活                      | 固定大小或扩容开销大        |

---

## 链表结构定义

### 单链表

Java 单链表节点定义

```java
public class ListNode {
    int val;           // 数据域
    ListNode next;     // 指针域，指向下一个节点

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

````

Python 单链表节点定义

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

### 双向链表

Java 双向链表节点定义

```java
public class DoubleListNode {
    int val;
    DoubleListNode prev;  // 指向前驱节点
    DoubleListNode next;  // 指向后继节点

    DoubleListNode(int val) {
        this.val = val;
        this.prev = null;
        this.next = null;
    }
}
```

Python 双向链表节点定义

```python
class DoubleListNode:
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next
```

## 链表相关解题技巧

链表题目考察点多为“指针操作”和“结构变形”，总结提炼为以下七大核心套路：

| 技巧序号 | 技巧名称  | 关键作用                 | 常见用途 / 关键词     |
| ---- | ----- | -------------------- | -------------- |
| ①    | 虚拟头节点 | 简化边界处理、统一操作逻辑        | 删除、插入、合并链表     |
| ②    | 快慢指针  | 定位中点 / 检测环 / 找交点     | 判断环、中点、找环入口    |
| ③    | 链表反转  | 改变结构 / 回文判断 / 分段     | 整体反转、部分反转、K段反转 |
| ④    | 双指针   | 精准定位节点位置             | 删除倒数第 k 个、找交点  |
| ⑤    | 切断与重连 | 操作子链、链表重组            | 分段反转、分区、排序     |
| ⑥    | 原地操作  | 节省空间 / 保持 O(1) 空间复杂度 | 回文链表、重排链表      |
| ⑦    | 模拟计算  | 实现加法 / 进位处理 / 比较等    | 两数相加、加一、大小比较   |

---

**虚拟头节点（Dummy Node）**

* 作用：简化链表头部的插入和删除，避免空指针判断。
* 例题：

  * [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
  * [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

---

### 快慢指针（Floyd 判圈）

* 作用：判断是否有环、找中点、找环入口。
* 例题：

  * [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
  * [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
  * [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

---

### 链表反转

* 方法：迭代、递归、分组反转。
* 例题：

  * [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
  * [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)
  * [25. K 个一组反转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

---

### 双指针技巧

* 用途：定位倒数第 k 个节点，找两个链表的交点。
* 例题：

  * [19. 删除倒数第 N 个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
  * [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

---

### 切断与重连

* 用于链表的分段操作，如分区、排序、合并。
* 例题：

  * [25. K 个一组反转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
  * [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

---

### 原地操作

* 节省空间，常用在回文链表判断和链表重排。
* 例题：

  * [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)
  * [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

---

### 模拟计算

* 处理链表数字模拟加法、进位等。
* 例题：

  * [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)
  * [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/)

---

## 经典例题

| 题号  | 题目                                                          | 标签                   |
| --- | ----------------------------------------------------------- | -------------------- |
| 148 | [排序链表](https://leetcode.cn/problems/sort-list/description/) | 链表 / 分治 / 归并排序 / 模板题 |

---
