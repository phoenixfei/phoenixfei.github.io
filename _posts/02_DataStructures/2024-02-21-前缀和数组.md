---
title: "前缀和数组：高效求区间和的利器"
categories: [02_DataStructures]
tags: [array]

math: true
layout: post
---

**前缀和数组**（Prefix Sum Array）是算法中一个非常常用的技巧，常用于高效地处理**区间求和**等问题。

---

### 设计思路

给定一个数组 `nums`，其前缀和数组 `prefix` 的定义如下：

```python
prefix[0] = 0
prefix[i] = nums[0] + nums[1] + ... + nums[i-1]  # 从i=1开始
```

也就是说：

```python
prefix[i] = prefix[i-1] + nums[i-1]
```

这样，任何区间 `[l, r]` 的和可以通过：

```python
sum(l, r) = prefix[r+1] - prefix[l]
```

直接暴力求区间 `[l, r]` 的和，时间复杂度是 O(r - l + 1)，而前缀和将其优化为 O(1)，在有大量区间求和的情况下效率极高。

> 为啥前缀和数组长度为`n+1`呢？
> 
> 为了统一区间和的计算公式，方便处理 [0, r] 和 [l, r] 这种从任意位置开始的区间

**常见应用场景：**

| 场景            | 说明                |
| ------------- | ----------------- |
| 区间和查询         | 多次查询 `[l, r]` 区间和 |
| 子数组和相关问题      | 如“和为 K 的子数组”      |
| 差分数组（前缀和的逆操作） | 用于快速区间更新          |
| 二维前缀和         | 用于处理矩阵中的子矩阵求和     |

---

### Python实现

```python
# 原始数组
nums = [3, 2, 4, 5, 1]

# 构造前缀和数组
prefix = [0] * (len(nums) + 1)
for i in range(1, len(prefix)):
    prefix[i] = prefix[i-1] + nums[i-1]

# 查询区间 [1, 3] 的和
# 即 nums[1] + nums[2] + nums[3] = 2 + 4 + 5 = 11
l, r = 1, 3
print(prefix[r+1] - prefix[l])  # 输出 11
```

---

### 二维前缀和

定义二维矩阵 `a`：

$$
a =
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
$$

定义：

$$
sum[i+1][j+1]
$$

表示左上角为 $a[0][0]$，右下角为 $a[i][j]$ 的子矩阵元素和。

> 采用这种定义方式，无需单独处理第一行/第一列的元素和。

---

**如何初始化二维前缀和？**

初始化公式如下：

$$
sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + a[i][j]
$$


推导过程证明：

以 $a[2][2] = 9$ 为例：

$$
sum[3][3] =
\underbrace{sum[3][2]}_{\text{左边子矩阵}}
+ \underbrace{sum[2][3]}_{\text{上方子矩阵}}
- \underbrace{sum[2][2]}_{\text{重复部分}}
+ a[2][2]
$$

<img src="{{ site.baseurl }}/assets/images/two-dim-pre-sum1.png" alt="二维前缀和样例1" style="width:800px; height:auto;" />

---

**如何计算任意子矩阵元素和？**

例如计算子矩阵`b`：

$$
\begin{bmatrix}
\mathbf{5} & \mathbf{6} \\
\mathbf{8} & \mathbf{9}
\end{bmatrix}
$$

对应原矩阵`a`：

$$
\begin{bmatrix}
1 & 2 & 3 \\
4 & \mathbf{5} & \mathbf{6} \\
7 & \mathbf{8} & \mathbf{9}
\end{bmatrix}
$$

其中：

* 子矩阵左上角为 $a[r1][c1]$
* 子矩阵右下角为 $a[r2-1][c2-1]$

推导过程：

* 取右下角前缀和 `sum[r2][c2]`
* 减去上方部分 `sum[r1][c2]`
* 减去左边部分 `sum[r2][c1]`
* 由于左上角区域被多减了一次，需要加回来 `sum[r1][c1]`

公式：

$$
submatrix\_sum = sum[r2][c2] - sum[r2][c1] - sum[r1][c2] + sum[r1][c1]
$$

<img src="{{ site.baseurl }}/assets/images/two-dim-pre-sum2.png" alt="二维前缀和样例1" style="width:800px; height:auto;" />

---

### 经典例题
- [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
- [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

---
