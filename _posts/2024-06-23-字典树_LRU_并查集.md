---
title: "æ•°æ®ç»“æž„ï¼šå­—å…¸æ ‘/LRU/å¹¶æŸ¥é›†"
categories: [ds-algo]

math: true
layout: post
---

> æœ¬æ–‡å±žäºŽ **æ•°æ®ç»“æž„ç³»åˆ—åšå®¢**ã€‚æœ¬ç³»åˆ—æ—¨åœ¨ç³»ç»Ÿæ¢³ç†å¸¸è§æ•°æ®ç»“æž„çš„åŽŸç†ã€å®žçŽ°ä¸Žåº”ç”¨ï¼Œé€‚åˆåˆ·é¢˜ã€é¢è¯•åŠæ•™å­¦ä½¿ç”¨ã€‚

ðŸ”— **ç›®å½•å¯¼èˆªï¼š**
- [å‰ç¼€å’Œæ•°ç»„](/posts/å‰ç¼€å’Œ_å·®åˆ†_æ ‘çŠ¶_çº¿æ®µæ ‘/#å‰ç¼€å’Œæ•°ç»„)
- [å·®åˆ†æ•°ç»„](/posts/å‰ç¼€å’Œ_å·®åˆ†_æ ‘çŠ¶_çº¿æ®µæ ‘/#å·®åˆ†æ•°ç»„)
- [é˜Ÿåˆ—/æ ˆ](/posts/æ ˆ_é˜Ÿåˆ—_å•è°ƒæ ˆ_å †/#é˜Ÿåˆ—å’Œæ ˆ)
- [å•è°ƒæ ˆ](/posts/æ ˆ_é˜Ÿåˆ—_å•è°ƒæ ˆ_å †/#å•è°ƒæ ˆ)
- [å †(ä¼˜å…ˆçº§é˜Ÿåˆ—)](/posts/æ ˆ_é˜Ÿåˆ—_å•è°ƒæ ˆ_å †/#å †ä¼˜å…ˆçº§é˜Ÿåˆ—)
- [æ ‘çŠ¶æ•°ç»„](/posts/å‰ç¼€å’Œ_å·®åˆ†_æ ‘çŠ¶_çº¿æ®µæ ‘/#æ ‘çŠ¶æ•°ç»„)
- [çº¿æ®µæ ‘](/posts/å‰ç¼€å’Œ_å·®åˆ†_æ ‘çŠ¶_çº¿æ®µæ ‘/#çº¿æ®µæ ‘)
- [å¹¶æŸ¥é›†](/posts/å­—å…¸æ ‘_LRU_å¹¶æŸ¥é›†/#å¹¶æŸ¥é›†)
- [å­—å…¸æ ‘](/posts/å­—å…¸æ ‘_LRU_å¹¶æŸ¥é›†/#å­—å…¸æ ‘)
- [LRU(æœ€è¿‘æœ€å°‘ä½¿ç”¨)](/posts/å­—å…¸æ ‘_LRU_å¹¶æŸ¥é›†/#lru)

---

## å¹¶æŸ¥é›†

å¹¶æŸ¥é›†æ˜¯ä¸€ç§ç»´æŠ¤é›†åˆé—´åˆå¹¶ä¸ŽæŸ¥è¯¢å…³ç³»çš„æ•°æ®ç»“æž„ï¼Œå°¤å…¶é€‚ç”¨äºŽå¤„ç†è¿žé€šæ€§é—®é¢˜ã€‚å¸¸ç”¨äºŽå›¾çš„è¿žé€šå—åˆ¤æ–­ã€æœ€å°ç”Ÿæˆæ ‘ï¼ˆå¦‚ Kruskal ç®—æ³•ï¼‰ã€å¥½å‹åœˆã€å†—ä½™è¿žæŽ¥ç­‰åœºæ™¯ã€‚

[å¹¶æŸ¥é›†æž„å»ºè¿‡ç¨‹-è§†é¢‘è®²è§£](https://www.bilibili.com/video/BV1zZRSYUEWV/)

### è®¾è®¡æ€è·¯

**å¹¶æŸ¥é›†çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**å°†å¤šä¸ªä¸ç›¸äº¤çš„é›†åˆç»„ç»‡æˆä¸€ä¸ªæ£®æž—ï¼Œæ£®æž—ä¸­çš„æ¯æ£µæ ‘ä»£è¡¨ä¸€ä¸ªé›†åˆã€‚é€šè¿‡ **åˆå¹¶ï¼ˆUnionï¼‰** æ“ä½œå°†ä¸¤ä¸ªé›†åˆåˆå¹¶ï¼Œæˆ–è€…é€šè¿‡ **æŸ¥æ‰¾ï¼ˆFindï¼‰** æ“ä½œåˆ¤æ–­ä¸¤ä¸ªå…ƒç´ æ˜¯å¦å±žäºŽåŒä¸€ä¸ªé›†åˆã€‚

å¹¶æŸ¥é›†æœ‰ä¸¤ä¸ªéžå¸¸é‡è¦çš„æ“ä½œï¼š
1. **Find**ï¼šæŸ¥è¯¢æŸä¸ªå…ƒç´ æ‰€åœ¨çš„é›†åˆï¼ˆå³æ‰¾åˆ°è¯¥å…ƒç´ çš„æ ¹èŠ‚ç‚¹ï¼‰ã€‚
2. **Union**ï¼šå°†ä¸¤ä¸ªå…ƒç´ æ‰€åœ¨çš„é›†åˆåˆå¹¶ã€‚

å¹¶æŸ¥é›†å¸¸è§çš„åº”ç”¨åœºæ™¯ï¼Œç‰¹åˆ«æ˜¯ï¼š
* **ç½‘ç»œè¿žé€šæ€§é—®é¢˜**ï¼šæ¯”å¦‚å›¾ä¸­çš„è¿žé€šåˆ†é‡ã€‚
* **å›¾çš„æœ€å°ç”Ÿæˆæ ‘ç®—æ³•**ï¼šå¦‚ Kruskal ç®—æ³•ã€‚
* **åŠ¨æ€è¿žé€šæ€§é—®é¢˜**ï¼šå¦‚åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­ã€‚
* **ç½‘ç»œä¸­è”é€šç»„ä»¶çš„ç®¡ç†**ï¼šæ¯”å¦‚ç½‘ç»œä¸­æ˜¯å¦å­˜åœ¨å¯è¾¾è·¯å¾„ã€‚

---

ä¸ºäº†æé«˜å¹¶æŸ¥é›†çš„æ•ˆçŽ‡ï¼Œæˆ‘ä»¬é€šå¸¸ä¼šä½¿ç”¨ä»¥ä¸‹ä¸¤ç§ä¼˜åŒ–æŠ€å·§ï¼š
1. **è·¯å¾„åŽ‹ç¼©ï¼ˆPath Compressionï¼‰**ï¼š
   * åœ¨ **Find** æ“ä½œæ—¶ï¼Œä¼˜åŒ–æ¯æ¬¡æŸ¥æ‰¾çš„è·¯å¾„ï¼Œä½¿å¾—æ ‘å˜å¾—æ‰å¹³ï¼Œä»Žè€ŒåŠ å¿«åŽç»­çš„æŸ¥æ‰¾æ“ä½œã€‚
   * å…·ä½“æ–¹æ³•ï¼šå½“æˆ‘ä»¬æŸ¥æ‰¾ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ—¶ï¼Œå°†è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ç›´æŽ¥è¿žæŽ¥åˆ°æ ¹èŠ‚ç‚¹ã€‚
2. **æŒ‰ç§©åˆå¹¶ï¼ˆUnion by Rankï¼‰**ï¼š
   * åœ¨ **Union** æ“ä½œæ—¶ï¼Œæ€»æ˜¯å°†è¾ƒå°çš„æ ‘åˆå¹¶åˆ°è¾ƒå¤§çš„æ ‘ä¸Šï¼Œé¿å…æ ‘çš„é«˜åº¦è¿‡å¤§ã€‚
   * å…·ä½“æ–¹æ³•ï¼šæ¯æ¬¡åˆå¹¶æ—¶ï¼Œå°†è¾ƒå°çš„æ ‘ï¼ˆæ·±åº¦è¾ƒå°ï¼‰ä½œä¸ºå­æ ‘ï¼ŒæŒ‚åˆ°è¾ƒå¤§çš„æ ‘ä¸‹ã€‚

> ç§©ï¼ˆrankï¼‰ æ˜¯ä¸€ç§ç”¨äºŽä¼˜åŒ–åˆå¹¶æ“ä½œçš„ç­–ç•¥ã€‚å®ƒçš„æœ¬è´¨æ˜¯ä¼°ç®—æ ‘çš„é«˜åº¦æˆ–å¤§å°ï¼Œç”¨æ¥å†³å®šå¦‚ä½•å°†ä¸¤ä¸ªé›†åˆåˆå¹¶ï¼Œä»¥ä¿æŒæ•´æ£µæ ‘å°½é‡â€œæ‰å¹³â€ï¼ŒåŠ å¿«åŽç»­ find æ“ä½œçš„æ•ˆçŽ‡ã€‚

é€šè¿‡è¿™ä¸¤ç§ä¼˜åŒ–ï¼Œ**å¹¶æŸ¥é›†**çš„æ—¶é—´å¤æ‚åº¦æŽ¥è¿‘ **O(Î±(n))**ï¼Œå…¶ä¸­ `Î±(n)` æ˜¯ **é˜¿å…‹æ›¼å‡½æ•°çš„åå‡½æ•°**ï¼Œå¢žé•¿æžå…¶ç¼“æ…¢ï¼Œå‡ ä¹Žå¯ä»¥è§†ä¸ºå¸¸æ•°æ—¶é—´ã€‚

---

**æ“ä½œè¯´æ˜Žï¼š**
1. **åˆå§‹åŒ– `UnionFind(n)`**ï¼š
   * åˆå§‹åŒ–çˆ¶èŠ‚ç‚¹æ•°ç»„ `parent`ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æŒ‡å‘è‡ªå·±ã€‚
   * åˆå§‹åŒ–ç§©æ•°ç»„ `rank`ï¼Œç”¨äºŽä¼˜åŒ–åˆå¹¶æ“ä½œï¼Œé»˜è®¤ä¸º 1ã€‚
2. **`find(x)`**ï¼š
   * æŸ¥æ‰¾èŠ‚ç‚¹ `x` çš„æ ¹èŠ‚ç‚¹ã€‚å¦‚æžœ `x` ä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œå°±é€šè¿‡é€’å½’æŸ¥è¯¢å…¶çˆ¶èŠ‚ç‚¹ï¼ŒåŒæ—¶è¿›è¡Œè·¯å¾„åŽ‹ç¼©ï¼ˆå°†è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ç›´æŽ¥æŒ‡å‘æ ¹èŠ‚ç‚¹ï¼‰ã€‚
3. **`union(x, y)`**ï¼š
   * æŸ¥æ‰¾èŠ‚ç‚¹ `x` å’ŒèŠ‚ç‚¹ `y` çš„æ ¹èŠ‚ç‚¹ï¼Œè‹¥å®ƒä»¬å±žäºŽä¸åŒé›†åˆï¼Œåˆ™åˆå¹¶å®ƒä»¬ã€‚
   * åˆå¹¶æ—¶ï¼Œé‡‡ç”¨æŒ‰ç§©åˆå¹¶çš„ç­–ç•¥ï¼Œå³å°†ç§©è¾ƒå°çš„æ ‘åˆå¹¶åˆ°ç§©è¾ƒå¤§çš„æ ‘ä¸‹ï¼Œä»Žè€Œä¿æŒæ ‘çš„é«˜åº¦è¾ƒå°ï¼Œä¼˜åŒ–åŽç»­æŸ¥è¯¢ã€‚
4. **`connected(x, y)`**ï¼š
   * åˆ¤æ–­èŠ‚ç‚¹ `x` å’ŒèŠ‚ç‚¹ `y` æ˜¯å¦å±žäºŽåŒä¸€ä¸ªé›†åˆã€‚å¦‚æžœå®ƒä»¬çš„æ ¹èŠ‚ç‚¹ç›¸åŒï¼Œè¯´æ˜Žå®ƒä»¬åœ¨åŒä¸€é›†åˆã€‚

### Pythonå®žçŽ°

```python
class UnionFind:
    def __init__(self, n):
        # ä¸€å¼€å§‹æœ‰ n ä¸ªé›†åˆ {0}, {1}, ..., {n-1}
        self.parent = list(range(n))  # çˆ¶èŠ‚ç‚¹æ•°ç»„
        self.rank = [1] * n           # ç§©ï¼ˆRankï¼‰æ˜¯ä¸€ä¸ªè¿‘ä¼¼è¡¨ç¤ºæ ‘çš„é«˜åº¦çš„å€¼ï¼ˆå¹¶éžç²¾ç¡®é«˜åº¦ï¼‰
        self.cc = n                   # è¿žé€šåˆ†é‡æ•°ï¼Œåˆå§‹åŒ–ä¸º n
        # self._size = [1] * n        # é›†åˆå¤§å°

    def find(self, x):
        # æŸ¥æ‰¾ x çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶è¿›è¡Œè·¯å¾„åŽ‹ç¼©
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # è·¯å¾„åŽ‹ç¼©
        return self.parent[x]

    def union(self, x, y):
        # æŒ‰ç§©åˆå¹¶ï¼šå°† x å’Œ y åˆå¹¶
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX == rootY:
            return
            
        # åˆå¹¶æ“ä½œï¼šæŒ‰é›†åˆå¤§å°åˆå¹¶
        if self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        elif self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1
        self.cc -= 1  # åˆå¹¶æˆåŠŸï¼Œè¿žé€šåˆ†é‡å‡ 1

    def connected(self, x, y):
        # åˆ¤æ–­ x å’Œ y æ˜¯å¦åœ¨åŒä¸€é›†åˆ
        return self.find(x) == self.find(y)
```

### ç»å…¸ä¾‹é¢˜
- [3608. åŒ…å« K ä¸ªè¿žé€šåˆ†é‡éœ€è¦çš„æœ€å°æ—¶é—´](https://leetcode.cn/problems/minimum-time-for-k-connected-components/)

---

## å­—å…¸æ ‘

**å­—å…¸æ ‘ï¼ˆTrieï¼‰**ï¼Œåˆç§°**å‰ç¼€æ ‘**æˆ–**å•è¯æŸ¥æ‰¾æ ‘**ï¼Œæ˜¯ä¸€ç§æ ‘å½¢æ•°æ®ç»“æž„ï¼Œå¸¸ç”¨äºŽé«˜æ•ˆåœ°å¤„ç†å­—ç¬¦ä¸²é›†åˆï¼Œå°¤å…¶æ˜¯**å‰ç¼€åŒ¹é…**ã€**å­—ç¬¦ä¸²æœç´¢**å’Œ**è‡ªåŠ¨è¡¥å…¨**ç­‰é—®é¢˜ã€‚

å®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**åˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥èŠ‚çœå­˜å‚¨ç©ºé—´å’ŒåŠ å¿«æŸ¥è¯¢é€Ÿåº¦ã€‚**

### è®¾è®¡æ€è·¯

**Trie çš„ç»“æž„åŽŸç†ï¼š**
* æ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ã€‚
* ä»Žæ ¹èŠ‚ç‚¹åˆ°æŸä¸€èŠ‚ç‚¹çš„è·¯å¾„è¡¨ç¤ºä¸€ä¸ªå‰ç¼€ã€‚
* æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰å¤šä¸ªå­èŠ‚ç‚¹ï¼ˆé€šå¸¸æ˜¯ 26 ä¸ªè‹±æ–‡å­—æ¯çš„åˆ†æ”¯ï¼‰ã€‚
* ä¸€ä¸ª `is_end` æ ‡å¿—è¡¨ç¤ºè¯¥è·¯å¾„æ˜¯å¦ä¸ºä¸€ä¸ªå®Œæ•´å•è¯ã€‚


**Trie æ”¯æŒçš„åŸºæœ¬æ“ä½œï¼š**

| æ“ä½œ                   | è¯´æ˜Ž                  |
| -------------------- | ------------------- |
| `insert(word)`       | æ’å…¥å•è¯                |
| `search(word)`       | æŸ¥è¯¢æŸä¸ªå®Œæ•´å•è¯æ˜¯å¦å­˜åœ¨        |
| `startsWith(prefix)` | æ˜¯å¦å­˜åœ¨ä»¥ prefix ä¸ºå‰ç¼€çš„å•è¯ |


**åº”ç”¨åœºæ™¯ï¼š**
* **æœç´¢å¼•æ“Žè‡ªåŠ¨è¡¥å…¨**
* **æ‹¼å†™æ£€æŸ¥**
* **å‰ç¼€åŒ¹é…ç»Ÿè®¡ï¼ˆå¦‚ LeetCode 208ï¼‰**
* **æ•æ„Ÿè¯è¿‡æ»¤**

---

### Pythonå®žçŽ°

```python
class TrieNode:
    def __init__(self):
        self.children = {}  # å­˜å‚¨å­èŠ‚ç‚¹ï¼Œkey æ˜¯å­—ç¬¦
        self.is_end = False  # æ ‡è®°æ˜¯å¦æ˜¯ä¸€ä¸ªå®Œæ•´å•è¯çš„ç»“å°¾

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """æ’å…¥å•è¯"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()  # è‹¥ä¸å­˜åœ¨åˆ™åˆ›å»ºæ–°èŠ‚ç‚¹
            node = node.children[char]
        node.is_end = True  # æ ‡è®°ä¸ºå•è¯ç»“æŸ

    def search(self, word):
        """æŸ¥æ‰¾å®Œæ•´å•è¯æ˜¯å¦å­˜åœ¨"""
        node = self._find_node(word)
        return node is not None and node.is_end

    def startsWith(self, prefix):
        """æ˜¯å¦å­˜åœ¨ä»¥ prefix ä¸ºå‰ç¼€çš„å•è¯"""
        return self._find_node(prefix) is not None

    def _find_node(self, prefix):
        """è¾…åŠ©æ–¹æ³•ï¼ŒæŸ¥æ‰¾å‰ç¼€æœ«å°¾çš„èŠ‚ç‚¹"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
```
---

### Javaå®žçŽ°

```java
// åˆ©ç”¨ç®€å•çš„å…³è”æ•°ç»„å®žçŽ°Trieæ ‘
class TrieNode {
    TrieNode[] links = new TrieNode[26];
    boolean isleaf  = false;
}

class Trie {

    TrieNode root;

    Trie() {
        root = new TrieNode();
    }

    // å®žçŽ°æ’å…¥æ–¹æ³•
    public void insert(String word) {
        insert(word, root);
    }

    public void insert(String word, TrieNode node) {
        if (node == null) {
            return;
        }
        if (word.length() == 0) {
            node.isleaf = true;
            return;
        }
        int index = word.charAt(0) - 'a';
        if (node.links[index] == null) {
            node.links[index] = new TrieNode();
        }
        insert(word.substring(1), node.links[index]);
    }

    // å®žçŽ° æŸ¥æ‰¾ åŠŸèƒ½
    public boolean search(String word) {
        return search(word, root);
    }

    private boolean search(String word, TrieNode node) {
        if (node == null) {
            return false;
        }
        if (word.length() == 0) return node.isleaf;
        int index = word.charAt(0) - 'a';
        return search(word.substring(1), node.links[index]);
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return startsWith(prefix, root);
    }

    private boolean startsWith(String prefix, TrieNode node) {
        if (node == null) {
            return false;
        }
        if (prefix.length() == 0) return true;
        int index = prefix.charAt(0) - 'a';
        return startsWith(prefix.substring(1), node.links[index]);
    }
}
```

### ç»å…¸ä¾‹é¢˜
- [é”®å€¼æ˜ å°„](https://leetcode-cn.com/problems/map-sum-pairs/)
- [å®žçŽ°ä¸€ä¸ª Trie (å‰ç¼€æ ‘)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

---

## LRU

**LRUï¼ˆLeast Recently Usedï¼‰** æ˜¯ä¸€ç§å¸¸è§çš„ **ç¼“å­˜æ·˜æ±°ç­–ç•¥**ï¼Œç”¨äºŽåœ¨ç¼“å­˜ç©ºé—´æœ‰é™æ—¶ï¼Œ**ä¼˜å…ˆæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®**ã€‚

> ç›´è§‚ç†è§£ï¼šå¦‚æžœæŸä¸ªæ•°æ®å¾ˆä¹…æ²¡ç”¨è¿‡ï¼Œè€Œæ–°çš„æ•°æ®è¦åŠ å…¥ç¼“å­˜ï¼Œå°±å…ˆæŠŠâ€œæœ€ä¹…æ²¡ç”¨çš„é‚£ä¸ªâ€ç§»é™¤ã€‚

**å¸¸ç”¨ç¼“å­˜ç­–ç•¥ï¼š**

| ç­–ç•¥   | æ·˜æ±°é€»è¾‘   | ç‰¹ç‚¹     |
| ---- | ------ | ------ |
| LRU  | æœ€ä¹…æœªä½¿ç”¨çš„ | æœ€å¸¸ç”¨    |
| LFU  | ä½¿ç”¨æœ€å°‘çš„  | æ›´ç²¾å‡†ä½†å¤æ‚ |
| FIFO | æœ€å…ˆè¿›å…¥çš„  | ç®€å•ä½†æ˜“å¤±æ•ˆ |
| MRU  | æœ€è¿‘ä½¿ç”¨çš„  | ç‰¹å®šåœºæ™¯æœ‰ç”¨ |

### è®¾è®¡æ€è·¯

ä¸€ä¸ªå…¸åž‹çš„ LRU ç¼“å­˜ç±»åº”æ”¯æŒä¸¤ä¸ªæ“ä½œï¼š
```python
get(key)      # å¦‚æžœ key å­˜åœ¨äºŽç¼“å­˜ä¸­ï¼Œè¿”å›žå¯¹åº”çš„ valueï¼Œå¹¶å°†å…¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨
put(key, val) # æ’å…¥æˆ–æ›´æ–° key å¯¹åº”çš„å€¼ã€‚å¦‚æžœè¶…å‡ºå®¹é‡ï¼Œè¦åˆ é™¤æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®
```

---

**è®¾è®¡æ€è·¯ï¼š**

ä¸ºäº†åœ¨ **O(1)** æ—¶é—´å®Œæˆ `get` å’Œ `put`ï¼Œæˆ‘ä»¬éœ€è¦ï¼š
1. å“ˆå¸Œè¡¨ï¼ˆdictï¼‰
   * å¿«é€Ÿå®šä½æŸä¸ª key æ˜¯å¦å­˜åœ¨ï¼Œä»¥åŠå¯¹åº”çš„èŠ‚ç‚¹ä½ç½®
2. åŒå‘é“¾è¡¨ï¼ˆDoubly Linked Listï¼‰
   * å®žçŽ°èŠ‚ç‚¹çš„å¿«é€Ÿæ’å…¥ä¸Žåˆ é™¤
   * ç»´æŠ¤è®¿é—®é¡ºåºï¼Œå¤´éƒ¨æ˜¯æœ€è¿‘è®¿é—®ï¼Œå°¾éƒ¨æ˜¯æœ€ä¹…è®¿é—®

---

### Pythonå®žçŽ°

**æ–¹æ³• 1ï¼šä½¿ç”¨ `collections.OrderedDict`**
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        # åˆå§‹åŒ–ç¼“å­˜å®¹é‡
        self.capacity = capacity
        # ä½¿ç”¨ OrderedDict æ¥ä¿å­˜ç¼“å­˜ä¸­çš„é”®å€¼å¯¹ï¼Œä¿æŒå…ƒç´ æ’å…¥é¡ºåº
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        """
        èŽ·å– key å¯¹åº”çš„å€¼ï¼Œå¦‚æžœå­˜åœ¨ï¼Œå°†å…¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨ï¼Œå¹¶è¿”å›žå¯¹åº”çš„ valueï¼›å¦åˆ™è¿”å›ž -1ã€‚
        """
        if key not in self.cache:
            # å½“é”®ä¸åœ¨ç¼“å­˜ä¸­ï¼Œç›´æŽ¥è¿”å›ž -1
            return -1
        
        # å½“é”®å­˜åœ¨æ—¶ï¼Œä¸ºäº†ç»´æŠ¤â€œæœ€è¿‘ä½¿ç”¨â€é¡ºåºï¼Œå°†è¯¥é”®ç§»åˆ° OrderedDict çš„æœ«å°¾
        self.cache.move_to_end(key)  # é»˜è®¤ last=Trueï¼Œè¡¨ç¤ºç§»åˆ°æœ€åŽ
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        """
        å‘ç¼“å­˜ä¸­æ’å…¥æˆ–è€…æ›´æ–°é”® key å¯¹åº”çš„ valueï¼Œå¹¶æŒ‰ç…§ LRU ç­–ç•¥ç»´æŠ¤ç¼“å­˜ã€‚
        """
        if key in self.cache:
            # å¦‚æžœ key å·²å­˜åœ¨ï¼Œå…ˆæ›´æ–°å…¶å€¼ï¼ŒåŒæ—¶å°†å…¶ç§»åˆ°æœ«å°¾
            self.cache.move_to_end(key)
        self.cache[key] = value

        if len(self.cache) > self.capacity:
            # å½“ç¼“å­˜è¶…å‡ºå®¹é‡é™åˆ¶æ—¶ï¼Œæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„å…ƒç´ 
            # popitem(last=False) ä¼šåˆ é™¤ç¬¬ä¸€ä¸ªæ’å…¥çš„ï¼ˆæˆ–è¯´æœ€ä¹…æœªä½¿ç”¨çš„ï¼‰é”®å€¼å¯¹
            self.cache.popitem(last=False)
```

**æ–¹æ³• 2ï¼šæ‰‹å†™åŒå‘é“¾è¡¨ + å“ˆå¸Œè¡¨**
```python
class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = dict()  # key -> Node

        # åˆå§‹åŒ–åŒå‘é“¾è¡¨çš„ä¼ªå¤´å°¾
        self.head = Node(0, 0)  # ä¼ªå¤´éƒ¨ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
        self.tail = Node(0, 0)  # ä¼ªå°¾éƒ¨ï¼ˆæœ€ä¹…æœªä½¿ç”¨ï¼‰
        self.head.next = self.tail
        self.tail.prev = self.head

    # å†…éƒ¨å‡½æ•°ï¼šä»Žé“¾è¡¨ä¸­ç§»é™¤ä¸€ä¸ªèŠ‚ç‚¹
    def _remove(self, node):
        prev, nxt = node.prev, node.next
        prev.next = nxt
        nxt.prev = prev

    # å†…éƒ¨å‡½æ•°ï¼šå°†ä¸€ä¸ªèŠ‚ç‚¹æ·»åŠ åˆ° head åŽ
    def _add(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    # èŽ·å–å€¼å¹¶æ ‡è®°ä¸ºæœ€è¿‘ä½¿ç”¨
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._remove(node)   # ä»ŽåŽŸä½ç½®åˆ é™¤
        self._add(node)      # æ’å…¥åˆ°å¤´éƒ¨
        return node.val

    # æ’å…¥æˆ–æ›´æ–°å€¼ï¼Œå¹¶ç»´æŠ¤ LRU ç­–ç•¥
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])  # åˆ é™¤æ—§èŠ‚ç‚¹

        new_node = Node(key, value)
        self._add(new_node)                # æ·»åŠ æ–°èŠ‚ç‚¹åˆ°å¤´éƒ¨
        self.cache[key] = new_node         # æ›´æ–°å“ˆå¸Œè¡¨

        if len(self.cache) > self.capacity:
            # åˆ é™¤é“¾è¡¨å°¾éƒ¨èŠ‚ç‚¹ï¼ˆæœ€ä¹…æœªä½¿ç”¨ï¼‰
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]
```

---
