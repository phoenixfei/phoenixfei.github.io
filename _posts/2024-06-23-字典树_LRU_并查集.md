---
title: "数据结构：字典树/LRU/并查集"
categories: [ds-algo]

math: true
layout: post
---

> 本文属于 **数据结构系列博客**。本系列旨在系统梳理常见数据结构的原理、实现与应用，适合刷题、面试及教学使用。

🔗 **目录导航：**
- [前缀和数组](/posts/前缀和_差分_树状_线段树/#前缀和数组)
- [差分数组](/posts/前缀和_差分_树状_线段树/#差分数组)
- [队列/栈](/posts/栈_队列_单调栈_堆/#队列和栈)
- [单调栈](/posts/栈_队列_单调栈_堆/#单调栈)
- [堆(优先级队列)](/posts/栈_队列_单调栈_堆/#堆优先级队列)
- [树状数组](/posts/前缀和_差分_树状_线段树/#树状数组)
- [线段树](/posts/前缀和_差分_树状_线段树/#线段树)
- [并查集](/posts/字典树_LRU_并查集/#并查集)
- [字典树](/posts/字典树_LRU_并查集/#字典树)
- [LRU(最近最少使用)](/posts/字典树_LRU_并查集/#lru)

---

## 并查集

并查集是一种维护集合间合并与查询关系的数据结构，尤其适用于处理连通性问题。常用于图的连通块判断、最小生成树（如 Kruskal 算法）、好友圈、冗余连接等场景。

[并查集构建过程-视频讲解](https://www.bilibili.com/video/BV1zZRSYUEWV/)

### 设计思路

**并查集的核心思想是：**将多个不相交的集合组织成一个森林，森林中的每棵树代表一个集合。通过 **合并（Union）** 操作将两个集合合并，或者通过 **查找（Find）** 操作判断两个元素是否属于同一个集合。

并查集有两个非常重要的操作：
1. **Find**：查询某个元素所在的集合（即找到该元素的根节点）。
2. **Union**：将两个元素所在的集合合并。

并查集常见的应用场景，特别是：
* **网络连通性问题**：比如图中的连通分量。
* **图的最小生成树算法**：如 Kruskal 算法。
* **动态连通性问题**：如判断两个节点是否在同一个集合中。
* **网络中联通组件的管理**：比如网络中是否存在可达路径。

---

为了提高并查集的效率，我们通常会使用以下两种优化技巧：
1. **路径压缩（Path Compression）**：
   * 在 **Find** 操作时，优化每次查找的路径，使得树变得扁平，从而加快后续的查找操作。
   * 具体方法：当我们查找一个节点的父节点时，将路径上的所有节点直接连接到根节点。
2. **按秩合并（Union by Rank）**：
   * 在 **Union** 操作时，总是将较小的树合并到较大的树上，避免树的高度过大。
   * 具体方法：每次合并时，将较小的树（深度较小）作为子树，挂到较大的树下。

> 秩（rank） 是一种用于优化合并操作的策略。它的本质是估算树的高度或大小，用来决定如何将两个集合合并，以保持整棵树尽量“扁平”，加快后续 find 操作的效率。

通过这两种优化，**并查集**的时间复杂度接近 **O(α(n))**，其中 `α(n)` 是 **阿克曼函数的反函数**，增长极其缓慢，几乎可以视为常数时间。

---

**操作说明：**
1. **初始化 `UnionFind(n)`**：
   * 初始化父节点数组 `parent`，每个节点的父节点指向自己。
   * 初始化秩数组 `rank`，用于优化合并操作，默认为 1。
2. **`find(x)`**：
   * 查找节点 `x` 的根节点。如果 `x` 不是根节点，就通过递归查询其父节点，同时进行路径压缩（将路径上的节点直接指向根节点）。
3. **`union(x, y)`**：
   * 查找节点 `x` 和节点 `y` 的根节点，若它们属于不同集合，则合并它们。
   * 合并时，采用按秩合并的策略，即将秩较小的树合并到秩较大的树下，从而保持树的高度较小，优化后续查询。
4. **`connected(x, y)`**：
   * 判断节点 `x` 和节点 `y` 是否属于同一个集合。如果它们的根节点相同，说明它们在同一集合。

### Python实现

```python
class UnionFind:
    def __init__(self, n):
        # 一开始有 n 个集合 {0}, {1}, ..., {n-1}
        self.parent = list(range(n))  # 父节点数组
        self.rank = [1] * n           # 秩（Rank）是一个近似表示树的高度的值（并非精确高度）
        self.cc = n                   # 连通分量数，初始化为 n
        # self._size = [1] * n        # 集合大小

    def find(self, x):
        # 查找 x 的根节点，并进行路径压缩
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # 路径压缩
        return self.parent[x]

    def union(self, x, y):
        # 按秩合并：将 x 和 y 合并
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX == rootY:
            return
            
        # 合并操作：按集合大小合并
        if self.rank[rootX] > self.rank[rootY]:
            self.parent[rootY] = rootX
        elif self.rank[rootX] < self.rank[rootY]:
            self.parent[rootX] = rootY
        else:
            self.parent[rootY] = rootX
            self.rank[rootX] += 1
        self.cc -= 1  # 合并成功，连通分量减 1

    def connected(self, x, y):
        # 判断 x 和 y 是否在同一集合
        return self.find(x) == self.find(y)
```

### 经典例题
- [3608. 包含 K 个连通分量需要的最小时间](https://leetcode.cn/problems/minimum-time-for-k-connected-components/)

---

## 字典树

**字典树（Trie）**，又称**前缀树**或**单词查找树**，是一种树形数据结构，常用于高效地处理字符串集合，尤其是**前缀匹配**、**字符串搜索**和**自动补全**等问题。

它的核心思想是：**利用字符串的公共前缀来节省存储空间和加快查询速度。**

### 设计思路

**Trie 的结构原理：**
* 每个节点表示一个字符。
* 从根节点到某一节点的路径表示一个前缀。
* 每个节点可以有多个子节点（通常是 26 个英文字母的分支）。
* 一个 `is_end` 标志表示该路径是否为一个完整单词。


**Trie 支持的基本操作：**

| 操作                   | 说明                  |
| -------------------- | ------------------- |
| `insert(word)`       | 插入单词                |
| `search(word)`       | 查询某个完整单词是否存在        |
| `startsWith(prefix)` | 是否存在以 prefix 为前缀的单词 |


**应用场景：**
* **搜索引擎自动补全**
* **拼写检查**
* **前缀匹配统计（如 LeetCode 208）**
* **敏感词过滤**

---

### Python实现

```python
class TrieNode:
    def __init__(self):
        self.children = {}  # 存储子节点，key 是字符
        self.is_end = False  # 标记是否是一个完整单词的结尾

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """插入单词"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()  # 若不存在则创建新节点
            node = node.children[char]
        node.is_end = True  # 标记为单词结束

    def search(self, word):
        """查找完整单词是否存在"""
        node = self._find_node(word)
        return node is not None and node.is_end

    def startsWith(self, prefix):
        """是否存在以 prefix 为前缀的单词"""
        return self._find_node(prefix) is not None

    def _find_node(self, prefix):
        """辅助方法，查找前缀末尾的节点"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
```
---

### Java实现

```java
// 利用简单的关联数组实现Trie树
class TrieNode {
    TrieNode[] links = new TrieNode[26];
    boolean isleaf  = false;
}

class Trie {

    TrieNode root;

    Trie() {
        root = new TrieNode();
    }

    // 实现插入方法
    public void insert(String word) {
        insert(word, root);
    }

    public void insert(String word, TrieNode node) {
        if (node == null) {
            return;
        }
        if (word.length() == 0) {
            node.isleaf = true;
            return;
        }
        int index = word.charAt(0) - 'a';
        if (node.links[index] == null) {
            node.links[index] = new TrieNode();
        }
        insert(word.substring(1), node.links[index]);
    }

    // 实现 查找 功能
    public boolean search(String word) {
        return search(word, root);
    }

    private boolean search(String word, TrieNode node) {
        if (node == null) {
            return false;
        }
        if (word.length() == 0) return node.isleaf;
        int index = word.charAt(0) - 'a';
        return search(word.substring(1), node.links[index]);
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return startsWith(prefix, root);
    }

    private boolean startsWith(String prefix, TrieNode node) {
        if (node == null) {
            return false;
        }
        if (prefix.length() == 0) return true;
        int index = prefix.charAt(0) - 'a';
        return startsWith(prefix.substring(1), node.links[index]);
    }
}
```

### 经典例题
- [键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)
- [实现一个 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

---

## LRU

**LRU（Least Recently Used）** 是一种常见的 **缓存淘汰策略**，用于在缓存空间有限时，**优先淘汰最久未使用的数据**。

> 直观理解：如果某个数据很久没用过，而新的数据要加入缓存，就先把“最久没用的那个”移除。

**常用缓存策略：**

| 策略   | 淘汰逻辑   | 特点     |
| ---- | ------ | ------ |
| LRU  | 最久未使用的 | 最常用    |
| LFU  | 使用最少的  | 更精准但复杂 |
| FIFO | 最先进入的  | 简单但易失效 |
| MRU  | 最近使用的  | 特定场景有用 |

### 设计思路

一个典型的 LRU 缓存类应支持两个操作：
```python
get(key)      # 如果 key 存在于缓存中，返回对应的 value，并将其标记为最近使用
put(key, val) # 插入或更新 key 对应的值。如果超出容量，要删除最久未使用的数据
```

---

**设计思路：**

为了在 **O(1)** 时间完成 `get` 和 `put`，我们需要：
1. 哈希表（dict）
   * 快速定位某个 key 是否存在，以及对应的节点位置
2. 双向链表（Doubly Linked List）
   * 实现节点的快速插入与删除
   * 维护访问顺序，头部是最近访问，尾部是最久访问

---

### Python实现

**方法 1：使用 `collections.OrderedDict`**
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        # 初始化缓存容量
        self.capacity = capacity
        # 使用 OrderedDict 来保存缓存中的键值对，保持元素插入顺序
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        """
        获取 key 对应的值，如果存在，将其标记为最近使用，并返回对应的 value；否则返回 -1。
        """
        if key not in self.cache:
            # 当键不在缓存中，直接返回 -1
            return -1
        
        # 当键存在时，为了维护“最近使用”顺序，将该键移到 OrderedDict 的末尾
        self.cache.move_to_end(key)  # 默认 last=True，表示移到最后
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        """
        向缓存中插入或者更新键 key 对应的 value，并按照 LRU 策略维护缓存。
        """
        if key in self.cache:
            # 如果 key 已存在，先更新其值，同时将其移到末尾
            self.cache.move_to_end(key)
        self.cache[key] = value

        if len(self.cache) > self.capacity:
            # 当缓存超出容量限制时，淘汰最久未使用的元素
            # popitem(last=False) 会删除第一个插入的（或说最久未使用的）键值对
            self.cache.popitem(last=False)
```

**方法 2：手写双向链表 + 哈希表**
```python
class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = dict()  # key -> Node

        # 初始化双向链表的伪头尾
        self.head = Node(0, 0)  # 伪头部（最近使用）
        self.tail = Node(0, 0)  # 伪尾部（最久未使用）
        self.head.next = self.tail
        self.tail.prev = self.head

    # 内部函数：从链表中移除一个节点
    def _remove(self, node):
        prev, nxt = node.prev, node.next
        prev.next = nxt
        nxt.prev = prev

    # 内部函数：将一个节点添加到 head 后
    def _add(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    # 获取值并标记为最近使用
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._remove(node)   # 从原位置删除
        self._add(node)      # 插入到头部
        return node.val

    # 插入或更新值，并维护 LRU 策略
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])  # 删除旧节点

        new_node = Node(key, value)
        self._add(new_node)                # 添加新节点到头部
        self.cache[key] = new_node         # 更新哈希表

        if len(self.cache) > self.capacity:
            # 删除链表尾部节点（最久未使用）
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]
```

---
