---
title: "MySQL 逻辑架构"
categories: [big data]
tags: [MySQL]

layout: post
---

MySQL 的**逻辑架构**可以分为三层，从上到下分别是：连接层、SQL层与存储引擎层。

---

## 整体三层结构

1. **客户端连接层**

   * 处理客户端与服务端之间的通信。
   * 主要包括：

     * **连接管理**：接收客户端请求，进行认证（用户名、密码、权限）。
     * **线程处理**：MySQL 为每个连接分配一个线程（传统模型），通过线程池管理。
     * **缓存与权限验证**：在这里也会做初步的权限检查。

2. **服务层（SQL 层）**

   * 这是 MySQL 的“核心大脑”，主要负责 SQL 的解析、优化、执行。
   * 核心组件：

     * **查询解析器（Parser）**

       * 解析 SQL 语句，生成语法树。
     * **查询优化器（Optimizer）**

       * 选择合适的执行计划，比如是否走索引、用哪种连接方式。
       * MySQL 使用基于 **成本模型（Cost-based Optimizer, CBO）** 的优化器。
     * **查询执行器（Executor）**

       * 按照优化器选择的执行计划逐步执行。
     * **缓存（Query Cache）**

       * 老版本 MySQL（≤5.7）中存在查询缓存，存储 SQL 与结果映射，但由于并发性能差，MySQL 8.0 已移除。

3. **存储引擎层（Data Layer）**

   * 真正与数据打交道的部分。
   * MySQL **插件式存储引擎**：不同表可以选择不同引擎。
   * 常见存储引擎：

     * **InnoDB**：默认引擎，支持事务、行级锁、外键。
     * **MyISAM**：早期默认引擎，支持全文索引，不支持事务与行级锁。
     * **Memory**：基于内存，速度快但不持久化。
   * 存储引擎对上层 SQL 层提供统一接口（Handler API）。

---

## 客户端连接层

**连接层** 就在最上面，主要负责和客户端打交道。它的作用可以分成几个关键点：

1. **连接管理**

   * 你用 `mysql -u root -p` 或通过应用程序（JDBC、Python MySQL 驱动等）发起连接时，MySQL 会先走这个层。
   * 它会验证 **用户名、密码、主机地址**（来自 `mysql.user` 表）。
   * 如果连接数超过 `max_connections`，这里会直接拒绝。

2. **线程管理**

   * 每个连接都会分配一个 **线程**（默认是线程池模型也可以配置）。
   * 这个线程负责处理该连接的一切请求，直到连接断开。

3. **权限检查**（初步）

   * 连接建立时会先做一次权限认证，之后执行 SQL 时还会在 SQL 层做更细粒度的检查。

4. **连接协议**

   * 支持 TCP/IP、Unix socket、本地命名管道（Windows）等多种方式。
   * 可以启用 SSL/TLS 做加密传输。

---

### 线程池

**不是每个连接都要绑定一个独立的线程**，而是多个连接的 SQL 请求可以轮流用同一个线程来执行。

**1. 传统模式（一个连接 = 一个线程）**

* 你开 1000 个连接，就会有 1000 个线程。
* 哪怕这些连接有些是空闲的，线程也一直占着内存（线程栈等）和调度资源。

> 在高并发场景下，线程的创建、销毁、切换会带来很大开销，容易导致性能抖动。

**2. 线程池模式（连接与线程解耦）**

* 你可以开 1000 个连接，但线程池里可能只有 20 个工作线程。
* 当一个连接发来 SQL 请求时，线程池会分配一个空闲线程去执行。
* 执行完后，这个线程不会“归还”给该连接，而是放回线程池，等待下一个可能来自**同一个连接或其他连接**的请求。

> 多个连接可复用同一线程，减少线程上下文切换。

**举个生活例子**，像餐厅里的服务员：

* **传统模式**：一个顾客进来，就安排一个专属服务员，从头到尾只服务这个顾客，即使顾客中途不点单，服务员也在旁边等着。
* **线程池模式**：餐厅只有有限的服务员，谁需要点单，就找空闲的服务员来帮忙。顾客点完单，服务员马上去服务下一个顾客。

---

如果**没有线程池**：

* 每来一个连接，MySQL都会**创建一个新的线程**来服务这个连接。
* 1000个连接意味着**瞬间创建1000个线程**。
* 线程的创建和销毁都非常耗时，特别是：
  * 分配内存（线程栈）
  * 线程上下文切换（CPU从一个线程切换到另一个线程）
  * 系统调用开销

**线程池的作用**：
其实就是**减少频繁创建和销毁线程的开销，提高并发处理效率**。

> 线程池限制了最大活跃线程数，超出部分请求会进入等待队列排队。
> 
> 虽然可能增加短暂等待，但大幅提升系统稳定性，避免因为线程过多导致的资源耗尽和性能崩溃。

---

线程池如何完成与客户端连接认证？

> 客户端连接认证**不依赖线程**，而是在连接建立的那一刻完成的。

可以这么理解：

1. **客户端发起连接请求**

   * TCP 三次握手建立连接
   * MySQL 监听线程（也叫主线程或 accept 线程）接收到这个连接

2. **认证发生**

   * MySQL 在接收连接后，会让认证模块读取用户名、密码（经过加密握手）
   * 验证成功后，MySQL 会在\*\*连接对象（Connection对象）\*\*里记录：

     * 用户名
     * 权限信息
     * 默认数据库
     * 会话变量等

3. **线程池模式下的执行**

   * 连接对象是**长久存在**的（直到断开）
   * 当线程池中的某个线程被分配给这个连接来执行 SQL 时，线程只是**临时借用**连接对象的上下文信息（包括认证结果和权限）去执行
   * 执行完 SQL，线程归还到池中，连接对象依然保存着认证状态

---
