---
title: "数据结构：前缀和数组/差分数组/树状数组/线段树"
categories: [ds-algo]

math: true
layout: post
---

> 本文属于 **数据结构系列博客**。本系列旨在系统梳理常见数据结构的原理、实现与应用，适合刷题、面试及教学使用。

🔗 **目录导航：**
- [前缀和数组](/posts/前缀和_差分_树状_线段树/#前缀和数组)
- [差分数组](/posts/前缀和_差分_树状_线段树/#差分数组)
- [队列/栈](/posts/栈_队列_单调栈_堆/#队列和栈)
- [单调栈](/posts/栈_队列_单调栈_堆/#单调栈)
- [堆(优先级队列)](/posts/栈_队列_单调栈_堆/#堆优先级队列)
- [树状数组](/posts/前缀和_差分_树状_线段树/#树状数组)
- [线段树](/posts/前缀和_差分_树状_线段树/#线段树)
- [并查集](/posts/字典树_LRU_并查集/#并查集)
- [字典树](/posts/字典树_LRU_并查集/#字典树)
- [LRU(最近最少使用)](/posts/字典树_LRU_并查集/#lru)

---

## 前缀和数组

**前缀和数组**（Prefix Sum Array）是算法中一个非常常用的技巧，常用于高效地处理**区间求和**等问题。

### 设计思路

给定一个数组 `nums`，其前缀和数组 `prefix` 的定义如下：

```python
prefix[0] = 0
prefix[i] = nums[0] + nums[1] + ... + nums[i-1]  # 从i=1开始
```

也就是说：

```python
prefix[i] = prefix[i-1] + nums[i-1]
```

这样，任何区间 `[l, r]` 的和可以通过：

```python
sum(l, r) = prefix[r+1] - prefix[l]
```

直接暴力求区间 `[l, r]` 的和，时间复杂度是 O(r - l + 1)，而前缀和将其优化为 O(1)，在有大量区间求和的情况下效率极高。

> 为啥前缀和数组长度为`n+1`呢？
> 
> 为了统一区间和的计算公式，方便处理 [0, r] 和 [l, r] 这种从任意位置开始的区间

**常见应用场景：**

| 场景            | 说明                |
| ------------- | ----------------- |
| 区间和查询         | 多次查询 `[l, r]` 区间和 |
| 子数组和相关问题      | 如“和为 K 的子数组”      |
| 差分数组（前缀和的逆操作） | 用于快速区间更新          |
| 二维前缀和         | 用于处理矩阵中的子矩阵求和     |

---

### Python实现

```python
# 原始数组
nums = [3, 2, 4, 5, 1]

# 构造前缀和数组
prefix = [0] * (len(nums) + 1)
for i in range(1, len(prefix)):
    prefix[i] = prefix[i-1] + nums[i-1]

# 查询区间 [1, 3] 的和
# 即 nums[1] + nums[2] + nums[3] = 2 + 4 + 5 = 11
l, r = 1, 3
print(prefix[r+1] - prefix[l])  # 输出 11
```

---

### 经典例题
- [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
- [303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

---

## 差分数组

差分数组是一种用于快速处理区间修改的技巧，特别适合频繁进行区间加法操作的问题。相比前缀和，它是“逆操作”，适合修改而不是查询。

### 设计思路

考虑数组 $a=[1,3,3,5,8]$，对其中的相邻元素两两作差（右边减左边），得到数组 $[2,0,2,3]$。然后在开头补上 $a[0]$，得到差分数组：

$$
d = [1,2,0,2,3]
$$

这有什么用呢？如果从左到右累加 d 中的元素，我们就「还原」回了 a 数组 $[1,3,3,5,8]$。

这又有什么用呢？现在把连续子数组 $a[1]$, $a[2]$, $a[3]$ 都加上 10，得到 $a′=[1,13,13,15,8]$ 。再次两两作差，并在开头补上 $a′[0]$，得到差分数组：

$$
d′ = [1,12,0,2,−7]
$$

对比 $d$ 和 $d′$ ，可以发现只有 $d[1]$ 和 $d[4]$ 变化了，这意味着对 $a$ 中连续子数组的操作，可以转变成对差分数组 $d$ 中两个数的操作。

---

对于数组 $a$, 定义其**差分数组 (difference array)** $d$ 为:

$$
d[i] = \begin{cases}
a[0], & i = 0 \\
a[i] - a[i-1], & i \ge 1
\end{cases}
$$

**性质 1:** 从左到右累加 $d$ 的元素, 可以得到数组 $a$。

**性质 2:** 如下两个操作是等价的。

* 把 $a$ 的子数组 $a[i], a[i+1], \dots, a[j]$ 都加上 $x$。
* 把 $d[i]$ 增加 $x$, 把 $d[j+1]$ 减少 $x$。

利用性质 2, 我们只需要 $O(1)$ 的时间就可以完成对 $a$ 的子数组的操作。最后利用性质 1 从差分数组复原出数组 $a$。

**注:** 也可以这样理解, $d[i]$ 表示把下标 $\ge i$ 的数都加上 $d[i]$。

![差分数组图示]({{ site.baseurl }}/assets/images/1747885435-uDDcwT-lc1094-c.png)

**差分数组的常见应用：**
* 区间加法问题
* 模拟前缀变化
* 一维转二维的“二维差分”技巧（用于快速处理矩形区域更新）

---

### Python实现

```python
n = len(nums)
diff = [0] * (n + 1)

# 区间加操作
def range_add(l, r, val):
    diff[l] += val
    diff[r + 1] -= val  # 不怕越界，因为有 n+1 长度

# 最终还原数组
res = [0] * n
res[0] = diff[0]
for i in range(1, n):
    res[i] = res[i - 1] + diff[i]
```

---

## 树状数组

树状数组是一个一维数组（通常称为 `tree` 或 `bit`），它本质上是对原始数组的前缀和进行“分块压缩”保存，使得我们可以在 `O(log n)` 的时间内：

* **查询某个位置前的所有数的和**（前缀和）
* **快速更新某个位置的值**

它是 **数组的一种增强结构**，可以看作是用空间换时间的“前缀和优化方案”。

---

### 设计思路

**为什么叫“树状”？**

虽然结构是数组，它的“跳跃规则”就像是树：
* 每个位置 i 代表的是一个区间的和（区间大小 = `lowbit(i)`）
* 利用 `lowbit(x)` 快速跳转到父区间或子区间，和树遍历类似

`lowbit(x)` 是什么？
```python
def lowbit(x):
    return x & -x
```

功能：得到 x 的二进制中最右侧的 `1` 所代表的数值
例如：

| x  | 二进制  | lowbit(x) |
| -- | ---- | --------- |
| 6  | 110  | 2         |
| 12 | 1100 | 4         |
| 8  | 1000 | 8         |

---

**举个例子：构建 BIT 结构**

设原始数组：`arr = [0, 3, 2, -1, 6, 5, 4, -3]`（从下标 1 开始）

构建 BIT 结构（只记录区间和）：

| i | lowbit(i) | 管辖的元素         | tree\[i] 存什么            |
| - | --------- | ------------- | ----------------------- |
| 1 | 1         | \[1]          | arr\[1]                 |
| 2 | 2         | \[1, 2]       | arr\[1] + arr\[2]       |
| 3 | 1         | \[3]          | arr\[3]                 |
| 4 | 4         | \[1, 2, 3, 4] | arr\[1]+...+arr\[4]     |
| 5 | 1         | \[5]          | arr\[5]                 |
| 6 | 2         | \[5, 6]       | arr\[5] + arr\[6]       |
| 7 | 1         | \[7]          | arr\[7]                 |
| 8 | 8         | \[1..8]       | arr\[1] + ... + arr\[8] |

每个节点代表一个前缀块的和，通过 `lowbit(i)` 快速跳转。

---

树状数组擅长处理以下类型问题：

| 类型              | 举例                          |
| --------------- | --------------------------- |
| **前缀和 / 区间和查询** | 查询 `[1..r]` 或 `[l..r]` 区间的和 |
| **频率统计 / 出现次数** | 出现多少个小于等于 `x` 的数            |
| **逆序对计数**       | 比某数小的元素有多少个                 |
| **动态第 K 小**     | 使用 BIT 二分查找第 K 大/小          |

---

操作时间复杂度：

| 操作    | 时间复杂度      |
| ----- | ---------- |
| 单点修改  | `O(log n)` |
| 前缀和查询 | `O(log n)` |

相比于前缀和数组 `O(1)` 查询但 `O(n)` 更新的缺陷，树状数组做到了更新与查询都快。

---

### Python实现
**使用 1-based 下标**
```python
class FenwickTree:
    def __init__(self, size):
        # 树状数组使用 1-based index，因此 size = n 时，tree 大小 = n+1
        self.n = size
        self.tree = [0] * (self.n + 1)

    def lowbit(self, x):
        # 获取最低有效位，例：6 -> 2（0b110 -> 0b10）
        return x & -x

    def update(self, index, delta):
        """将 arr[index] += delta"""
        while index <= self.n:
            self.tree[index] += delta
            index += self.lowbit(index)

    def query(self, index):
        """返回 arr[1] + arr[2] + ... + arr[index] 的前缀和"""
        result = 0
        while index > 0:
            result += self.tree[index]
            index -= self.lowbit(index)
        return result

    def range_query(self, left, right):
        """返回 arr[left] + ... + arr[right] 的区间和"""
        return self.query(right) - self.query(left - 1)
```

**使用示例：**
```python
arr = [2, 3, 5, 1, 4]
n = len(arr)
fenw = FenwickTree(n)

# 外部查询或更新函数时，索引都必须加1处理

# 挨个元素更新，即初始化
for i, val in enumerate(arr):
    fenw.update(i + 1, val)  # 由于内部是1-based实现

# 查询原数组闭区间[0,2]
print(fenw.query(3))  # 输出 10
# 查询原数组闭区间[1,3]
print(fenw.range_query(2, 4))  # 输出 9

# 更新：把索引2位置元素更新为10（原来是5）
idx = 2
fenw.update(idx+1, 10 - arr[idx])

# 再查询一次，可知更新有效
print(fenw.query(3))  # 输出 15
print(fenw.range_query(2, 4))  # 输出 14
```

---

## 线段树

线段树是一种高级数据结构，适用于频繁的区间查询和单点/区间修改问题。其本质是一个平衡二叉树，每个节点维护一个区间的信息。

**应用场景：**
* 区间和 / 区间最大值 / 区间最小值
* 区间加减 / 区间赋值（懒标记）

---

### 设计思路

**核心思想：**

每个节点表示一个区间 `[l, r]`，维护这个区间的信息，比如：
* 区间和
* 区间最大值/最小值
* 区间乘积/异或
* 甚至是复杂的结构（最大前缀和、懒惰标记等）


它将数组的每个元素看作一个区间 `[i, i]`，不断二分构建区间树，如：
```
原数组: nums = [2, 1, 5, 3]

对应区间：
        [0,3]
       /     \
    [0,1]    [2,3]
   /   \     /   \
 [0,0][1,1][2,2][3,3]
```

---

**基本操作详解及复杂度：**
* 建树 `build`, `O(n)`：从底层（叶子节点）递归构建向上，常用 DFS。
* 查询 `query`, `O(log n)`：如果目标区间包含在当前节点区间，返回当前节点值；否则递归到左右子树查找。
* 更新 `update`, `O(log n)`：修改某个元素或区间，递归更新对应的区间信息。


**线段树 vs 树状数组：**

| 项目    | 树状数组  | 线段树    |
| ----- | ----- | ------ |
| 支持操作  | 区间和类  | 任意区间统计 |
| 区间修改  | 需变形支持 | 可自然支持  |
| 空间复杂度 | O(n)  | O(n)   |
| 实现复杂度 | 简单    | 较复杂    |
| 灵活性   | 较差    | 非常强    |

---

### Python实现
**无懒惰标记**
```python
class SegmentTree:
    def __init__(self, nums):
        self.n = len(nums)
        self.tree = [0] * (self.n * 4)
        self.build(nums, 0, 0, self.n - 1) # 从根节点 build，区间为 [0, n-1]

    def build(self, nums, node, l, r):
        if l == r:
            self.tree[node] = nums[l]  # 叶子节点，赋值为原数组中的元素
        else:
            mid = (l + r) // 2
            # 递归构建左子树（编号：2*node+1），区间：[l, mid]
            self.build(nums, node * 2 + 1, l, mid)
            # 递归构建右子树（编号：2*node+2），区间：[mid+1, r]
            self.build(nums, node * 2 + 2, mid + 1, r)
            # 当前节点的值为左右子树的合并结果（此处为区间和）
            self.tree[node] = self.tree[node * 2 + 1] + self.tree[node * 2 + 2]
        
    def update(self, index, val, node=0, l=0, r=None):
        if r is None:
            r = self.n - 1
        if l == r:
            self.tree[node] = val  # 找到叶子节点，更新值
        else:
            mid = (l + r) // 2
            if index <= mid:
                self.update(index, val, node * 2 + 1, l, mid)
            else:
                self.update(index, val, node * 2 + 2, mid + 1, r)
            # 更新当前节点的值（从子树中更新）
            self.tree[node] = self.tree[node * 2 + 1] + self.tree[node * 2 + 2]

    def query(self, ql, qr, node=0, l=0, r=None):
        if r is None:
            r = self.n - 1
        if ql > r or qr < l:
            return 0  # 查询区间与当前区间完全不相交
        if ql <= l and r <= qr:
            return self.tree[node]  # 当前区间被查询区间完全包含，直接返回
        mid = (l + r) // 2
        return self.query(ql, qr, node * 2 + 1, l, mid) + \
               self.query(ql, qr, node * 2 + 2, mid + 1, r)
```

**使用示例：**
```python
arr = [2, 3, 5, 1, 4]

# 直接传入nums，进行初始化线段树
seg_tree = SegmentTree(arr)

# 外部查询或更新函数时，索引无需额外处理

# 查询原数组闭区间[0,2]
print(seg_tree.query(0, 2))  # 输出 10
# 查询原数组闭区间[1,3]
print(seg_tree.query(1, 3))  # 输出 9

# 更新：把索引2位置元素更新为10（原来是5）
seg_tree.update(2, 10)

# 再查询一次，可知更新有效
print(seg_tree.query(0, 2))  # 输出 15
print(seg_tree.query(1, 3))  # 输出 14
```

---
