---
title: "从辗转相除法到最小公倍数"
categories: [math]

math: true
layout: post
---

最大公约数（GCD）和最小公倍数（LCM）

GCD与LCM是整数运算中最基本且常用的数论工具，广泛用于整除判断与数值关系建模。

---

## GCD与LCM介绍

Greatest Common Divisor，最大公约数。

两个整数 $a$ 和 $b$ 的最大公约数（GCD）是能同时整除这两个数的最大正整数，记作：

$$
\gcd(a, b)
$$

---

Least Common Multiple，最小公倍数

两个整数 $a$ 和 $b$ 的最小公倍数（LCM）是能被它们同时整除的最小正整数，记作：

$$
\text{lcm}(a, b)
$$

---

## 辗转相除法

辗转相除法是一种用于计算两个整数最大公约数（GCD）的高效算法，基于一个非常简洁而强大的性质：

对于任意两个正整数 $a$ 和 $b$（假设 $a \geq b$），有：

$$
\gcd(a, b) = \gcd(b, a \mod b)
$$

这个过程会不断地用较小的数去除较大的数，并把余数作为新的除数，直到余数为 0。最后的非零除数就是 GCD。

---

**算法流程：**

以计算 $\gcd(48, 18)$ 为例，来看具体步骤：

1. $48 \mod 18 = 12$，变为 $\gcd(18, 12)$
2. $18 \mod 12 = 6$，变为 $\gcd(12, 6)$
3. $12 \mod 6 = 0$，结束。结果是 **6**

最终结果：GCD = 6

---

## Python 实现

迭代版本
```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a
```

递归版本
```python
def gcd(a, b):
    return a if b == 0 else gcd(b, a % b)
```

内置函数
```python
import math

print(math.gcd(10, 2))  # 2
print(math.lcm(10, 2))  # 10
```

---

辗转相除法的时间复杂度是：

$$
O(\log \min(a, b))
$$

这是因为每次操作都会将较大数减小，且它和斐波那契数列有很深的联系。最坏情况下的输入对是连续的斐波那契数（比如 21 和 13），此时迭代次数最多。

---

## 更相减损术

* 基本思想是：不断用两数中的较大数减去较小数，直到两数相等。
* 时间复杂度远高于辗转相除法，在接近的数值时性能极差。


* **更相减损术计算 $\gcd(48, 18)$**：

```text
48 - 18 = 30  
30 - 18 = 12  
18 - 12 = 6  
12 - 6 = 6  
6 - 6 = 0  
=> GCD = 6（共5次）
```

* **辗转相除法仅需 3 步！**

---

## 辗转相除法证明

**为什么 $\gcd(a, b) = \gcd(b, a \mod b)$ 成立？**

设：

$$
a = bq + r \quad \text{（q 为商，r 为余数）}
$$

任何能整除 $a$ 和 $b$ 的数 $d$，必然也能整除 $r = a - bq$
反过来，能整除 $b$ 和 $r$ 的数，也能整除 $a = bq + r$
因此：

$$
\gcd(a, b) = \gcd(b, r)
$$

---
