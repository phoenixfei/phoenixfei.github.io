---
title: "数据结构：堆/队列/栈/单调栈"
categories: [ds-algo]
tags: [data-structure]

math: true
layout: post
---

> 本文属于 **数据结构系列博客**。本系列旨在系统梳理常见数据结构的原理、实现与应用，适合刷题、面试及教学使用。

🔗 **目录导航：**
- [前缀和数组](/posts/前缀和_差分_树状_线段树/#前缀和数组)
- [差分数组](/posts/前缀和_差分_树状_线段树/#差分数组)
- [队列/栈](/posts/栈_队列_单调栈_堆/#队列和栈)
- [单调栈](/posts/栈_队列_单调栈_堆/#单调栈)
- [堆(优先级队列)](/posts/栈_队列_单调栈_堆/#堆优先级队列)
- [树状数组](/posts/前缀和_差分_树状_线段树/#树状数组)
- [线段树](/posts/前缀和_差分_树状_线段树/#线段树)
- [并查集](/posts/字典树_LRU_并查集/#并查集)
- [字典树](/posts/字典树_LRU_并查集/#字典树)
- [LRU(最近最少使用)](/posts/字典树_LRU_并查集/#lru)

---

## 队列和栈

**栈（Stack） vs 队列（Queue）：**

| 特性        | 栈（Stack）                     | 队列（Queue）               |
| --------- | ---------------------------- | ----------------------- |
| 存取顺序      | 后进先出（LIFO）                   | 先进先出（FIFO）              |
| 插入操作      | `push(x)` 放入“栈顶”             | `enqueue(x)` 放入“队尾”     |
| 删除操作      | `pop()` 从“栈顶”移除              | `dequeue()` 从“队头”移除     |
| 访问方式      | 只能访问栈顶                       | 只能访问队头                  |
| 常用场景      | 括号匹配、表达式求值、回溯等               | 排队系统、BFS遍历、任务调度等        |
| Python 实现 | `list` 或 `collections.deque` | `collections.deque`（推荐） |

---

**队列**

**特点：**
* **先进先出（FIFO）**
* 类比：排队系统、打印队列

**Python 实现（推荐使用 `collections.deque`）：**
```python
from collections import deque

queue = deque()

queue.append(1)       # 入队（尾部）
queue.append(2)
front = queue[0]      # 查看队头
queue.popleft()       # 出队（头部）
```

* `append(x)` 入队（右端）
* `popleft()` 出队（左端）

`collections.deque`同样可用于实现“**双端队列**”：
```python
queue.appendleft(x)   # 左边入队
queue.pop()           # 右边出队
```

---

**栈**

**特点：**
* **后进先出（LIFO）**
* 类比：盘子堆、撤销操作

**Python 实现（推荐使用 `list`）：**
```python
stack = []

stack.append(1)    # push 入栈
stack.append(2)
top = stack[-1]    # 查看栈顶
stack.pop()        # pop 出栈
```

* `append(x)` 入栈
* `pop()` 出栈
* `stack[-1]` 查看栈顶

---

## 单调栈

单调栈是指栈内元素单调递增或递减的栈结构。

**常见应用场景：**

| 应用场景      | 简要描述                     |
| --------- | ------------------------ |
| 下一个更大元素（或更小元素） | 从一个数组中找到每个元素右边第一个比它大的数   |
| 柱状图中最大的矩形 | 求解每根柱子左右第一个比它矮的柱子，计算最大面积 |
| 滑动窗口最值    | 单调队列变形                   |
| 某个元素的左/右边界 | 找到数组中每个元素左边第一个比它小/大的数    |

**单调递增（递减）栈：**

| 类型    | 特点                | 适用场景                |
| ----- | ----------------- | ------------------- |
| 单调递增栈 | 栈内元素从栈底到栈顶递增（小→大） | 寻找**下一个更小元素**、维护最小值 |
| 单调递减栈 | 栈内元素从栈底到栈顶递减（大→小） | 寻找**下一个更大元素**、维护最大值 |

**举例说明：**
以数组 `[2, 1, 5, 6, 2, 3]` 为例，**寻找每个元素右侧第一个比它大的元素**，若不存在，则记为 -1。

维护一个 **单调递减栈**，栈中存的是**索引**。遍历数组时，如果当前元素比栈顶对应的元素大，就说明找到了“下一个更大的元素”。

---

### 算法过程

输入数组：`nums = [2, 1, 5, 6, 2, 3]`

遍历过程：

1. i = 0, nums\[0] = 2
   → 栈空，入栈 \[0]

2. i = 1, nums\[1] = 1
   → 栈顶 nums\[0]=2 > 1，不满足条件，入栈 \[0, 1]

3. i = 2, nums\[2] = 5

   * 栈顶 nums\[1]=1 < 5 → 弹出，res\[1] = 5
   * 栈顶 nums\[0]=2 < 5 → 弹出，res\[0] = 5
     → 入栈 \[2]

4. i = 3, nums\[3] = 6

   * 栈顶 nums\[2]=5 < 6 → 弹出，res\[2] = 6
     → 入栈 \[3]

5. i = 4, nums\[4] = 2
   → 栈顶 nums\[3]=6 > 2，不弹出，入栈 \[3, 4]

6. i = 5, nums\[5] = 3

   * 栈顶 nums\[4]=2 < 3 → 弹出，res\[4] = 3
     → 栈顶 nums\[3]=6 > 3，不弹出，入栈 \[3, 5]

最终结果：`res = [5, 5, 6, -1, 3, -1]`

---

### Python 实现

```python
def next_greater(nums):
    res = [-1] * len(nums)
    stack = []
    for i, num in enumerate(nums):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            res[idx] = nums[i]
        stack.append(i)
    return res
```

### 经典例题
* [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/) 
* [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)
* [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
* [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
* [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)
* [2197. 替换数组中的非互质数](https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/description/)

---


## 堆(优先级队列)

堆是一种**完全二叉树**，满足特定的顺序性质：

* **大顶堆（Max-Heap）**：每个节点的值 ≥ 其子节点的值。
* **小顶堆（Min-Heap）**：每个节点的值 ≤ 其子节点的值。

堆常用于实现**优先队列**，可以在 `O(log n)` 时间内完成插入和删除最大/最小元素。

**堆的基本操作：**

| 操作          | 时间复杂度    | 描述            |
| ----------- | -------- | ------------- |
| 插入（push）    | O(log n) | 将元素插入堆中，向上调整堆 |
| 弹出（pop）     | O(log n) | 删除堆顶元素，向下调整堆  |
| 查看堆顶（peek）  | O(1)     | 查看最大或最小元素     |
| 建堆（heapify） | O(n)     | 将一个无序数组建成堆结构  |

---

### Python的`heapq`

* 默认实现的是**小顶堆**
* 若需大顶堆：插入元素时取负值 `-x`，取出时再取负

**常用 API 总览：**

| 函数名                             | 说明                     |
| ------------------------------- | ---------------------- |
| `heapq.heapify(list)`           | 原地将列表转为堆结构（小顶堆）        |
| `heapq.heappush(heap, item)`    | 向堆中插入一个元素              |
| `heapq.heappop(heap)`           | 弹出最小的元素                |
| `heapq.heappushpop(heap, item)` | 先 push 后 pop（效率比分别调用高） |
| `heapq.heapreplace(heap, item)` | 先 pop 后 push（效率比分别调用高） |
| `heapq.nlargest(k, iterable)`   | 取前 k 大                 |
| `heapq.nsmallest(k, iterable)`  | 取前 k 小                 |


```python
import heapq

# 小顶堆
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappop(heap)  # 2

# 大顶堆
max_heap = []
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -2)
-heapq.heappop(max_heap)  # 5
```

---

### 懒删除堆（Lazy Deletion Heap）

在使用 **堆（heapq）** 作为优先队列时，经常会遇到两个麻烦：

1. **删除指定元素**：`heapq` 只能删除堆顶，不能直接删除堆中任意元素。
2. **更新元素**：如果某个元素的优先级（关键字）发生变化，需要把它更新为新值，但堆里还留着旧值。

如果我们硬要“中途删除”，需要在堆里查找并重新调整，这会导致 **O(n)** 的复杂度，丢掉了堆的高效性。

于是有了一个经典技巧：**懒删除（Lazy Deletion）**。

---

**懒删除的思路很简单：**

* **插入新值**：照常 `heappush`。
* **删除某个值**：不动堆，只在一个 `dict` 或 `set` 里标记该值“已删除”。
* **取堆顶/弹出**：如果堆顶值已经被标记删除，就丢掉它，继续弹下一个。

换句话说，堆中可能存在“过期元素”，但我们不急着清理它们，直到它们出现在堆顶时，才真正删除。

---

**应用场景**

**1. 最短路径（Dijkstra、A\*）**

在 Dijkstra 算法中，某个节点的距离可能被更新多次。

* 旧的距离我们没法直接从堆里删除。
* 采用懒删除：直接 push 新距离，等旧值被 pop 出来时，如果发现它不是“当前最优值”，就丢弃。

这是 Dijkstra 常见的 Python 实现方式。

---

**2. 滑动窗口最值**

例如：维护一个长度为 `k` 的滑动窗口，要求随时输出最大值。

* 窗口滑动时，移出的元素标记为“删除”。
* 窗口新加入的元素 push 到堆。
* 每次取堆顶时，如果堆顶已过期，就懒删除继续弹。

这样就能高效维护窗口内的最大/最小值。

---

**3. 动态集合最值查询**

我们想要支持操作：

* `add(x)`
* `remove(x)`
* `get_min()`

懒删除堆可以轻松做到，复杂度仍然对数级。

---

**实现原理**

一个典型的懒删除堆结构包含：

1. **一个最小堆**（`heapq` 实现）。
2. **一个字典/哈希表**（记录哪些元素“已删除但还没清理”）。

伪代码：

```
push(x):
    heap.push(x)

remove(x):
    invalid[x] += 1   # 标记删除

top():
    while heap 非空 且 heap.top 在 invalid 中:
        heap.pop()
        invalid[x] -= 1
        如果 invalid[x] == 0: 删除键
    return heap.top
```

---

**优点**

* 避免堆中间删除，操作简单。
* 插入、删除标记、弹出保持 **O(log n)**。
* 实现优先队列 + 删除/更新功能，非常实用。

**缺点**

* 堆中会存放一些“无效元素”，可能导致 **内存占用变大**。
* 如果长时间不访问堆顶，过期元素不会被清理。

一般在算法场景（如最短路、滑动窗口）中，这个缺点不明显。

**总结**

懒删除堆是一种 **以空间换时间** 的技巧。

* 它不改变堆的底层逻辑，而是在逻辑层面解决“删除/更新”问题。
* 在 Python 的算法实现中（尤其是 Dijkstra、滑动窗口、任务调度等），是非常高频的模式。

一句话总结：

> **遇到堆中间删除或更新时，别硬删，标记一下，等它到堆顶再删。**

---

### 堆排序简介

堆排序利用堆的性质来进行排序，时间复杂度为 `O(n log n)`，不稳定排序。

**排序流程（大顶堆）**：

1. 建堆（大顶堆）
2. 不断将堆顶元素与末尾元素交换，并调整剩余部分为大顶堆

```python
def heap_sort(nums):
    # ----------- 建立大顶堆 -----------
    def heapify(nums, n, i):
        largest = i  # 初始化最大值为当前根
        left = 2 * i + 1  # 左孩子
        right = 2 * i + 2  # 右孩子

        # 如果左孩子存在且比当前最大还大
        if left < n and nums[left] > nums[largest]:
            largest = left

        # 如果右孩子存在且比当前最大还大
        if right < n and nums[right] > nums[largest]:
            largest = right

        # 如果最大值不是根，交换并继续 heapify
        if largest != i:
            nums[i], nums[largest] = nums[largest], nums[i]
            heapify(nums, n, largest)

    n = len(nums)

    # ----------- 第一步：建堆 -----------
    for i in range(n // 2 - 1, -1, -1):  # 从最后一个非叶子节点开始
        heapify(nums, n, i)

    # ----------- 第二步：排序 -----------
    for i in range(n - 1, 0, -1):
        # 当前堆顶是最大值，交换到末尾
        nums[0], nums[i] = nums[i], nums[0]
        # 重新调整堆
        heapify(nums, i, 0)
```

### 经典例题
- [1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)
- [2163. 删除元素后和的最小差值](https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/)

**懒删除堆**
- [2349. 设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/)
- [3408. 设计任务管理器](https://leetcode.cn/problems/design-task-manager/)

---
