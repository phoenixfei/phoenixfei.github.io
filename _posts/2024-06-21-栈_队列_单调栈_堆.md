---
title: "数据结构：堆/队列/栈/单调栈"
categories: [ds-algo]

math: true
layout: post
---

> 本文属于 **数据结构系列博客**。本系列旨在系统梳理常见数据结构的原理、实现与应用，适合刷题、面试及教学使用。

🔗 **目录导航：**
- [前缀和数组](/posts/前缀和_差分_树状_线段树/#前缀和数组)
- [差分数组](/posts/前缀和_差分_树状_线段树/#差分数组)
- [队列/栈](/posts/栈_队列_单调栈_堆/#队列和栈)
- [单调栈](/posts/栈_队列_单调栈_堆/#单调栈)
- [堆(优先级队列)](/posts/栈_队列_单调栈_堆/#堆优先级队列)
- [树状数组](/posts/前缀和_差分_树状_线段树/#树状数组)
- [线段树](/posts/前缀和_差分_树状_线段树/#线段树)
- [并查集](/posts/字典树_LRU_并查集/#并查集)
- [字典树](/posts/字典树_LRU_并查集/#字典树)
- [LRU(最近最少使用)](/posts/字典树_LRU_并查集/#lru)

---

## 队列和栈

**栈（Stack） vs 队列（Queue）：**

| 特性        | 栈（Stack）                     | 队列（Queue）               |
| --------- | ---------------------------- | ----------------------- |
| 存取顺序      | 后进先出（LIFO）                   | 先进先出（FIFO）              |
| 插入操作      | `push(x)` 放入“栈顶”             | `enqueue(x)` 放入“队尾”     |
| 删除操作      | `pop()` 从“栈顶”移除              | `dequeue()` 从“队头”移除     |
| 访问方式      | 只能访问栈顶                       | 只能访问队头                  |
| 常用场景      | 括号匹配、表达式求值、回溯等               | 排队系统、BFS遍历、任务调度等        |
| Python 实现 | `list` 或 `collections.deque` | `collections.deque`（推荐） |

---

**队列**

**特点：**
* **先进先出（FIFO）**
* 类比：排队系统、打印队列

**Python 实现（推荐使用 `collections.deque`）：**
```python
from collections import deque

queue = deque()

queue.append(1)       # 入队（尾部）
queue.append(2)
front = queue[0]      # 查看队头
queue.popleft()       # 出队（头部）
```

* `append(x)` 入队（右端）
* `popleft()` 出队（左端）

`collections.deque`同样可用于实现“**双端队列**”：
```python
queue.appendleft(x)   # 左边入队
queue.pop()           # 右边出队
```

---

**栈**

**特点：**
* **后进先出（LIFO）**
* 类比：盘子堆、撤销操作

**Python 实现（推荐使用 `list`）：**
```python
stack = []

stack.append(1)    # push 入栈
stack.append(2)
top = stack[-1]    # 查看栈顶
stack.pop()        # pop 出栈
```

* `append(x)` 入栈
* `pop()` 出栈
* `stack[-1]` 查看栈顶

---

## 单调栈

单调栈是指栈内元素单调递增或递减的栈结构。

**常见应用场景：**

| 应用场景      | 简要描述                     |
| --------- | ------------------------ |
| 下一个更大元素（或更小元素） | 从一个数组中找到每个元素右边第一个比它大的数   |
| 柱状图中最大的矩形 | 求解每根柱子左右第一个比它矮的柱子，计算最大面积 |
| 滑动窗口最值    | 单调队列变形                   |
| 某个元素的左/右边界 | 找到数组中每个元素左边第一个比它小/大的数    |

**单调递增（递减）栈：**

| 类型    | 特点                | 适用场景                |
| ----- | ----------------- | ------------------- |
| 单调递增栈 | 栈内元素从栈底到栈顶递增（小→大） | 寻找**下一个更小元素**、维护最小值 |
| 单调递减栈 | 栈内元素从栈底到栈顶递减（大→小） | 寻找**下一个更大元素**、维护最大值 |

**举例说明：**
以数组 `[2, 1, 5, 6, 2, 3]` 为例，**寻找每个元素右侧第一个比它大的元素**，若不存在，则记为 -1。

维护一个 **单调递减栈**，栈中存的是**索引**。遍历数组时，如果当前元素比栈顶对应的元素大，就说明找到了“下一个更大的元素”。

---

### 算法过程

输入数组：`nums = [2, 1, 5, 6, 2, 3]`

遍历过程：

1. i = 0, nums\[0] = 2
   → 栈空，入栈 \[0]

2. i = 1, nums\[1] = 1
   → 栈顶 nums\[0]=2 > 1，不满足条件，入栈 \[0, 1]

3. i = 2, nums\[2] = 5

   * 栈顶 nums\[1]=1 < 5 → 弹出，res\[1] = 5
   * 栈顶 nums\[0]=2 < 5 → 弹出，res\[0] = 5
     → 入栈 \[2]

4. i = 3, nums\[3] = 6

   * 栈顶 nums\[2]=5 < 6 → 弹出，res\[2] = 6
     → 入栈 \[3]

5. i = 4, nums\[4] = 2
   → 栈顶 nums\[3]=6 > 2，不弹出，入栈 \[3, 4]

6. i = 5, nums\[5] = 3

   * 栈顶 nums\[4]=2 < 3 → 弹出，res\[4] = 3
     → 栈顶 nums\[3]=6 > 3，不弹出，入栈 \[3, 5]

最终结果：`res = [5, 5, 6, -1, 3, -1]`

---

### Python 实现

```python
def next_greater(nums):
    res = [-1] * len(nums)
    stack = []
    for i, num in enumerate(nums):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            res[idx] = nums[i]
        stack.append(i)
    return res
```

### 经典例题
* [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/) 
* [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)
* [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
* [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
* [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

---


## 堆(优先级队列)

堆是一种**完全二叉树**，满足特定的顺序性质：

* **大顶堆（Max-Heap）**：每个节点的值 ≥ 其子节点的值。
* **小顶堆（Min-Heap）**：每个节点的值 ≤ 其子节点的值。

堆常用于实现**优先队列**，可以在 `O(log n)` 时间内完成插入和删除最大/最小元素。

**堆的基本操作：**

| 操作          | 时间复杂度    | 描述            |
| ----------- | -------- | ------------- |
| 插入（push）    | O(log n) | 将元素插入堆中，向上调整堆 |
| 弹出（pop）     | O(log n) | 删除堆顶元素，向下调整堆  |
| 查看堆顶（peek）  | O(1)     | 查看最大或最小元素     |
| 建堆（heapify） | O(n)     | 将一个无序数组建成堆结构  |

---

### Python的`heapq`

* 默认实现的是**小顶堆**
* 若需大顶堆：插入元素时取负值 `-x`，取出时再取负

**常用 API 总览：**

| 函数名                             | 说明                     |
| ------------------------------- | ---------------------- |
| `heapq.heapify(list)`           | 原地将列表转为堆结构（小顶堆）        |
| `heapq.heappush(heap, item)`    | 向堆中插入一个元素              |
| `heapq.heappop(heap)`           | 弹出最小的元素                |
| `heapq.heappushpop(heap, item)` | 先 push 后 pop（效率比分别调用高） |
| `heapq.heapreplace(heap, item)` | 先 pop 后 push（效率比分别调用高） |
| `heapq.nlargest(k, iterable)`   | 取前 k 大                 |
| `heapq.nsmallest(k, iterable)`  | 取前 k 小                 |


```python
import heapq

# 小顶堆
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 2)
heapq.heappop(heap)  # 2

# 大顶堆
max_heap = []
heapq.heappush(max_heap, -5)
heapq.heappush(max_heap, -2)
-heapq.heappop(max_heap)  # 5
```

---

### 堆排序简介

堆排序利用堆的性质来进行排序，时间复杂度为 `O(n log n)`，不稳定排序。

**排序流程（大顶堆）**：

1. 建堆（大顶堆）
2. 不断将堆顶元素与末尾元素交换，并调整剩余部分为大顶堆

```python
def heap_sort(nums):
    # ----------- 建立大顶堆 -----------
    def heapify(nums, n, i):
        largest = i  # 初始化最大值为当前根
        left = 2 * i + 1  # 左孩子
        right = 2 * i + 2  # 右孩子

        # 如果左孩子存在且比当前最大还大
        if left < n and nums[left] > nums[largest]:
            largest = left

        # 如果右孩子存在且比当前最大还大
        if right < n and nums[right] > nums[largest]:
            largest = right

        # 如果最大值不是根，交换并继续 heapify
        if largest != i:
            nums[i], nums[largest] = nums[largest], nums[i]
            heapify(nums, n, largest)

    n = len(nums)

    # ----------- 第一步：建堆 -----------
    for i in range(n // 2 - 1, -1, -1):  # 从最后一个非叶子节点开始
        heapify(nums, n, i)

    # ----------- 第二步：排序 -----------
    for i in range(n - 1, 0, -1):
        # 当前堆顶是最大值，交换到末尾
        nums[0], nums[i] = nums[i], nums[0]
        # 重新调整堆
        heapify(nums, i, 0)
```

### 经典例题
- [1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)
- [2163. 删除元素后和的最小差值](https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/)

---
