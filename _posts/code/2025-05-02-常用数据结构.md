---
title: "Java & Python基础数据结构"
categories: [code]
tags: [programming, java, python]

math: true
layout: post
---

从核心结构、功能对等实现以及差异说明，介绍**Java 与 Python 常用数据结构**，适合从 Java 转向 Python 或同时使用两者的开发者参考。

---

## 1. 数组与动态数组

**Java**

* 原生数组：`int[] arr = new int[5];`
  长度固定，定义时必须确定大小。
* 动态数组：`ArrayList<Integer> list = new ArrayList<>();`
  底层是动态扩容的数组，支持随机访问和高效的末尾插入。

**Python**

* 使用 `list` 同时承担数组和动态数组的角色：`arr = [1, 2, 3]`
  支持任意类型混合，动态扩容。

**主要特性**

* **有序**，可按下标访问。
* Java 原生数组不可扩容，`ArrayList` 自动扩容。
* Python `list` 更灵活，但类型检查靠运行时。

**常用方法**

* Java：`add()`, `get()`, `set()`, `remove()`
* Python：`append()`, `pop()`, `sort()`, 切片操作

---

## 2. 链表

**Java**

* `LinkedList`：双向链表实现，支持队列和栈操作。

**Python**

* 没有内置链表类型，可用 `collections.deque` 实现双端队列（底层为双向链表或块链表）。
* 单链表需自行定义节点类。

**特点**

* **有序**，插入删除高效，随机访问较慢。

**常用方法**

* Java：`addFirst()`, `addLast()`, `removeFirst()`
* Python：`appendleft()`, `popleft()`

---

## 3. 栈（Stack）

**Java**

* 旧版：`Stack` 类（线程安全但较慢）
* 推荐：`Deque` 接口实现（如 `ArrayDeque`）

**Python**

* 可用 `list` 模拟（`append()` 入栈，`pop()` 出栈）
* 高性能可用 `collections.deque`

**特点**

* **LIFO**（后进先出）结构。

---

### 具体用法

**Java**
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class StackExample {
    public static void main(String[] args) {
        // 创建栈
        Deque<Integer> stack = new ArrayDeque<>();

        // 入栈
        stack.push(1);
        stack.push(2);
        stack.push(3);

        // 查看栈顶
        System.out.println(stack.peek()); // 输出 3

        // 出栈
        System.out.println(stack.pop()); // 输出 3
        System.out.println(stack.pop()); // 输出 2
    }
}
```

**常用方法**
* `push(x)` → 入栈
* `pop()` → 出栈并返回栈顶
* `peek()` → 查看栈顶元素
* `isEmpty()` → 判断是否为空

---

## 4. 队列（Queue）

**Java**

* `Queue` 接口的实现类：`LinkedList`、`ArrayDeque`
* 支持 `offer()`, `poll()`, `peek()`

**Python**

* `collections.deque` 是首选（`append()` 入队，`popleft()` 出队）
* 多线程场景可用 `queue.Queue`

**特点**

* **FIFO**（先进先出）结构。

---

### 具体用法

**Java**
```java
import java.util.ArrayDeque;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        // 创建队列
        Queue<Integer> queue = new ArrayDeque<>();

        // 入队
        queue.offer(1);
        queue.offer(2);
        queue.offer(3);

        // 查看队首
        System.out.println(queue.peek()); // 输出 1

        // 出队
        System.out.println(queue.poll()); // 输出 1
        System.out.println(queue.poll()); // 输出 2
    }
}
```

**常用方法**
* `offer(x)` → 入队（失败返回 `false`）
* `poll()` → 出队并返回队首（空则返回 `null`）
* `peek()` → 查看队首元素
* `isEmpty()` → 判断是否为空

---

## 5. 优先队列（堆）

**Java**

* `PriorityQueue`：默认小顶堆，可传比较器实现大顶堆。

**Python**

* `heapq` 模块：最小堆实现，需用 `heappush()`、`heappop()`
* 大顶堆可通过存储负值实现。

**特点**

* 按优先级取元素，非全局有序。

Java 中的优先级队列主要是指 `PriorityQueue` 类，它实现了一个基于堆的数据结构，可以按照元素的自然顺序或自定义比较器顺序来排序，保证每次取出的元素都是当前队列中优先级最高（最小或最大）的元素。

---

### 具体用法

```java
import java.util.PriorityQueue;

public class Demo {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        pq.add(30);
        pq.add(10);
        pq.add(20);

        System.out.println("PriorityQueue elements:");
        while (!pq.isEmpty()) {
            System.out.println(pq.poll());  // 输出顺序：10, 20, 30
        }
    }
}
```

**常用方法**

| 方法                 | 说明                               |
| ------------------ | -------------------------------- |
| `add(E e)`         | 添加元素，元素不能为 null，若容量不够自动扩容。       |
| `offer(E e)`       | 添加元素，效果同 `add()`，但适合用于队列接口调用。    |
| `peek()`           | 查看队头元素（优先级最高的元素），不删除，若为空返回 null。 |
| `poll()`           | 取出并删除队头元素，若为空返回 null。            |
| `remove(Object o)` | 删除指定元素，若存在。                      |
| `size()`           | 返回当前元素个数。                        |
| `isEmpty()`        | 判断队列是否为空。                        |
| `clear()`          | 清空队列。                            |
| `iterator()`       | 返回队列元素的迭代器，注意迭代顺序不一定是优先级顺序。      |

---

Java 默认 `PriorityQueue` 是最小堆，如果你想实现最大堆（即优先级最高是最大值），可以传入自定义比较器：

```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);

maxHeap.add(30);
maxHeap.add(10);
maxHeap.add(20);

while (!maxHeap.isEmpty()) {
    System.out.println(maxHeap.poll());  // 输出顺序：30, 20, 10
}
```

---

## 6. 哈希表（映射）

**Java**

* `HashMap`：无序键值对存储，平均 O(1) 查找。
* `LinkedHashMap`：保留插入顺序。
* `TreeMap`：按键排序（红黑树实现）。

**Python**

* `dict`：Python3.7+ 保证插入顺序。
* `collections.OrderedDict`：有序字典（旧版本需要）。

**特点**

* 键唯一，哈希表存储。

---

## 7. 集合（Set）

**Java**

* `HashSet`：无序，基于 `HashMap` 实现。
* `TreeSet`：有序集合（红黑树）。

**Python**

* `set`：无序，基于哈希表。
* `frozenset`：不可变集合。

**特点**

* 元素唯一，查找高效。

---

## 8. 字符串

**Java**

* `String`：不可变
* `StringBuilder`/`StringBuffer`：可变，适合频繁拼接

**Python**

* `str`：不可变
* 拼接频繁时可用 `list` 再 `''.join()`

**特点**

* 不可变性提高安全性，频繁修改需可变结构优化性能。

---

## 9. 双端队列

**Java**

* `ArrayDeque`：高效实现
* 支持两端插入删除

**Python**

* `collections.deque`：线程安全，高效两端操作

---

### 具体用法

**Java**
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class DequeExample {
    public static void main(String[] args) {
        Deque<Integer> deque = new ArrayDeque<>();

        // 队尾入队
        deque.offerLast(1);
        deque.offerLast(2);

        // 队首入队
        deque.offerFirst(0);

        // 队首出队
        System.out.println(deque.pollFirst()); // 输出 0

        // 队尾出队
        System.out.println(deque.pollLast()); // 输出 2
    }
}
```

**常用方法**
* `offerFirst(x)` / `offerLast(x)`
* `pollFirst()` / `pollLast()`
* `peekFirst()` / `peekLast()`

---
