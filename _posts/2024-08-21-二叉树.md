---
title: "掌握二叉树：结构、遍历与递归思维"
categories: [ds-algo]
tags: [data-structure]

math: true
layout: post
---

“二叉树” 是数据结构中非常核心的内容，常见于各种算法题，特别是在递归、动态规划、图算法等领域有广泛应用。

## 树的实现

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

## 一些常见的树

### 满二叉树

- **国内定义**：一个二叉树，每一层的结点数都达到最大值。也就是说，如果一个二叉树的层数为k，且结点总数为$2^k-1$，则它就是满二叉树（Full Binary Tree）。
- **国外定义**：如果一个二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

**国内外定义有歧义**。国内做法：

- 在国际交流场合，包括学术会议发表论文等都应该使用国际定义；
- 在国内的各种考试场合，如研究生考试、软考，使用国内教程的定义。

### 完全二叉树

Complete Binary Tree，除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。

### 完美二叉树

Perfect Binary Tree，除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。

![v2-37769edff7e51a865dadf6d111afc5f1_hd]({{ site.baseurl }}/assets/images/v2-37769edff7e51a865dadf6d111afc5f1_hd.jpg)

总结：中国定义的满二叉树就是国际定义的完美二叉树。

### 二叉查找树

Binary Search Tree，也称为**[二叉搜索树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)**，是指一棵空树或者具有以下性质的树：

1. 若任意节点的左子树不空，则左子树所有节点的值小于它根节点的值；
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点。

二叉查找树**中序遍历**结果**有序**。

### 红黑树

[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)，Red-black Tree，是一种自平衡二叉查找树，典型的用途是**关联数组**。

在二叉查找树强制的一般要求外，对于任何有效的红黑树，我们增加了如下额外的要求：
* 节点是红色或黑色。
* 根是黑色。
* 所有叶子都是黑色（叶子是NIL节点）。
* 每个红色节点必须有两个黑色的子节点。
  * 或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。
  * 或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。
  * 或者说红色节点的父节点和子节点均是黑色的。
* 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

![1920px-Red-black_tree_example.svg]({{ site.baseurl }}/assets/images/1920px-Red-black_tree_example.svg.png)

## 遍历

### 层次遍历

层序遍历就是按照 从上到下、从左到右 的顺序，一层一层访问二叉树的节点。 它是 广度优先搜索 (BFS) 在二叉树上的应用。

- [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        ans = []
        q = deque([root])
        while q:
            vals = []
            for _ in range(len(q)):
                node = q.popleft()
                vals.append(node.val)
                if node.left:  q.append(node.left)
                if node.right: q.append(node.right)
            ans.append(vals)
        return ans
```

---

### 先/中/后序遍历

- 先序(根左右)：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树
- 中序(左根右)：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树
- 后序(左右根)：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值

> Tips：无论先序、中序、后序，对节点的考查（不一定输出）顺序都是一样的。

![2405011-5f5b0b136713f744]({{ site.baseurl }}/assets/images/2405011-5f5b0b136713f744-1558060683243.jpg)

---

**通过递归实现先/中/后序遍历**：
代码模板一致，仅节点处理的顺序不同

**通过迭代实现先/中/后序遍历**：
因为需要在遍历完节点的左子树时接着遍历节点的右子树，为了能找到该节点，需要使用**栈**来进行暂存。

---

**先序遍历**
- [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

递归实现
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            ans.append(node.val)
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return ans
```

迭代实现
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        cur = root
        stack = []
        while cur or stack:
            while cur:
                stack.append(cur)
                ans.append(cur.val)
                cur = cur.left
            cur = stack.pop().right
        return ans
```

---

**中序遍历**
- [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

递归实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            dfs(node.left)
            ans.append(node.val)
            dfs(node.right)
        dfs(root)
        return ans
```

迭代实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = []
        cur = root
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack.pop()
            ans.append(cur.val)
            cur = cur.right
        return ans
```

---

**后序遍历**
- [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

递归实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            dfs(node.left)
            dfs(node.right)
            ans.append(node.val)
        dfs(root)
        return ans
```

迭代实现

后序遍历与先序、中序遍历不一样之处在于：**后序遍历在输出当前节点值时，需要考虑其左右之树是否已经遍历完成。**

> 所以，需要设置一个lastVisit游标。当lastVisit等于当前节点的右子树，表示该节点的左右子树都已经遍历完成，才可以输出当前节点值。

![2405011-a3b88566f13549af]({{ site.baseurl }}/assets/images/2405011-a3b88566f13549af.jpg)

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = []
        cur = root
        last_vst = None
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack[-1]
            if cur.right is None or cur.right == last_vst:
                ans.append(cur.val)
                cur = stack.pop()
                last_vst = cur
                cur = None
            else:
                cur = cur.right
        return ans
```

---

## 递归与分治

二叉树问题几乎是 **递归和分治思想的最佳练习场**。很多题目看似复杂，其实就是把 **大问题分解为左右子树的小问题** 来解决。


**递归与分治的区别：**
* **递归 (Recursion)**：函数调用自身，解决规模更小的子问题。二叉树的遍历（前序、中序、后序）就是典型递归。
* **分治 (Divide and Conquer)**：将一个问题拆解成 **若干独立子问题**，分别求解，再合并结果。

> 在二叉树中，通常就是 **把整棵树问题拆成左子树 + 右子树**。

换句话说：
* **递归是实现手段**
* **分治是算法思想**

> 二叉树的递归解法，几乎都隐含着分治思想。

---

**树的递归遍历**就是“递归与分治”思想的最基本的应用。

以中序遍历为例：递归结构刚好契合“左子树—根—右子树”的定义。

```python
def inorder(root: TreeNode):
    if root is None:
        return
    inorder(root.left)       # 左
    print(root.val, end=" ") # 根
    inorder(root.right)      # 右
```

**典型流程：**

1. **拆解问题**：当前节点要做什么？左右子树分别要做什么？
2. **递归求解子问题**：递归调用左右子树。
3. **合并结果**：把左右子树结果与根节点结合。

---

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

**题目：**
给定一个二叉树 root ，返回其最大深度。
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None: return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

* **分解**：树的深度 = 左子树深度、右子树深度的最大值 + 1。
* **合并**：取最大值。

---

### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

**题目：**
给定一个二叉树，判断它是否是平衡二叉树。

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def get_height(node):
            if node is None:
                return 0
            left_height = get_height(node.left)
            if left_height == -1:
                return -1
            right_height = get_height(node.right)
            if right_height == -1 or abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1
        return get_height(root) != -1
```

* **分解**：判断一棵树是否平衡，需要左右子树都平衡，且高度差 ≤ 1。
* **合并**：用高度作为子问题结果，结合左右子树的判断。

---

### 小结

二叉树的题目，本质就是 **定义函数 → 拆成左右子树递归 → 合并答案**。

递归是代码形式，分治是思维模式。

写二叉树递归与分治类题目，可以套 3 个步骤：

1. **明确函数定义**：

   * 输入参数是什么？
   * 输出代表什么（如高度、布尔值、路径和等）？

2. **拆解子问题**：

   * 当前节点要做的事？
   * 左右子树分别怎么处理？

3. **合并子结果**：

   * 左右子树结果 + 根节点 → 返回给上层。

---

## 回溯/路径搜索

在二叉树题目中，**回溯（Backtracking）** 主要应用于 **路径相关问题**。其核心思想是：

* **沿着根到叶的路径进行探索**；
* **在进入子树前做选择，退出子树时撤销选择**。

这样可以枚举所有可能的路径，常见于 **路径和、所有路径、路径匹配** 等题型。

---

**方法思路**
1. **递归下探**：将当前节点加入路径。
2. **到达叶子 / 终止条件**：检查当前路径是否满足要求（如和为 target）。
3. **回溯撤销**：退出该节点时，把它从路径中移除，回到上层继续搜索。

这类题和普通递归的区别在于：
* 普通递归只关心**结果值**（如深度、高度）；
* 回溯递归则需要维护一条**路径状态**，并在递归返回时撤销。

---

### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

**题目**：
给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
叶子节点 是指没有子节点的节点。

**思路要点**：
* `path` 维护一条从根到当前节点的路径。
* 每次进入节点 → `path.append()`
* 递归子树 → 搜索继续
* 回溯 → `path.pop()`

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        ans = []
        path = []

        def dfs(node):
            if node is None:
                return
            path.append(str(node.val))
            if node.left is None and node.right is None:
                ans.append("->".join(path))
            else:
                dfs(node.left)
                dfs(node.right)
            path.pop()
        dfs(root)
        return ans
```

---

### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

**题目**：
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。

**思路要点**：
* `left` 记录剩余和。
* 到叶子时判断 `left == 0`。
* 回溯清理路径，保证路径状态不污染。

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        ans = []
        path = []
        def dfs(node, left):
            if node is None:
                return 
            path.append(node.val)
            left -= node.val
            if node.left is None and node.right is None and left == 0:
                ans.append(path.copy())
            else:
                dfs(node.left, left)
                dfs(node.right, left)
            path.pop()
        dfs(root, targetSum)
        return ans
```

---

### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

**题目**：
给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**思路要点**：
* 这种题更偏 **前缀和 + 回溯**，需要在递归中维护状态。
* 写法复杂，但本质依旧是路径搜索。

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        ans = 0
        cnt = defaultdict(int)
        cnt[0] = 1

        def dfs(node: Optional[TreeNode], s: int) -> None:
            if node is None:
                return

            nonlocal ans
            s += node.val
            # 把 node 当作路径的终点，统计有多少个起点
            ans += cnt[s - targetSum]

            cnt[s] += 1
            dfs(node.left, s)
            dfs(node.right, s)
            cnt[s] -= 1  # 恢复现场

        dfs(root, 0)
        return ans
```

---

### 小结

* **回溯 / 路径搜索** 适合处理「路径相关」问题：
  * 要么找 **是否存在** 某条路径；
  * 要么收集 **所有路径**。

* 特点是 **路径状态随递归维护**，需要 **进入时选择、退出时撤销**。

* 和普通递归/分治、树形 DP 最大的不同是：
  * **回溯强调路径（动态过程）**，
  * **分治强调结果合并（静态子问题）**，
  * **树形 DP 强调状态转移（优化子结构）**。

---

## 树形DP

二叉树的 **树形 DP（Tree DP）** 是二叉树题目里比较高级的一个方向，常见于 **路径计算、最大独立集、状态转移优化** 等。

树形 DP 是 **在树的结构上进行动态规划**。

* 子问题：通常是 **以某个节点为根的子树** 的最优解。
* 状态转移：通过 **合并子树的结果** 来得到父节点的最优解。

> 关键在于 **后序遍历**（因为要等左右子树算完，才能算父节点）。

---


### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

```text
二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。
```

* 定义 `f(u)` = 以 `u` 为根的子树，**从 `u` 出发的最大路径和**。
* 转移：

  ```
  f(u) = max(0, f(left)) + max(0, f(right)) + u.val
  ```

  （如果子树贡献为负，就不要它）
* 全局维护最大值。

---

### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

```text
给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。
```

* 定义 `depth(u)` = 节点 `u` 的最大深度。
* 每次计算直径 = `depth(left) + depth(right)`。
* 全局维护最大值。

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def dfs(node: Optional[TreeNode]) -> int:
            if node is None:
                return -1  # 对于叶子来说，链长就是 -1+1=0
            l_len = dfs(node.left) + 1  # 左子树最大链长+1
            r_len = dfs(node.right) + 1  # 右子树最大链长+1
            nonlocal ans
            ans = max(ans, l_len + r_len)  # 两条链拼成路径
            return max(l_len, r_len)  # 当前子树最大链长
        dfs(root)
        return ans
```

---

### 最大独立集（树上选点问题）

在二叉树中选点，不能选相邻的父子节点，求最大权值和。

* 定义状态：

  * `dp[u][0]` = 不选 `u` 的最大值
  * `dp[u][1]` = 选 `u` 的最大值
* 转移：

  ```
  dp[u][0] = sum( max(dp[v][0], dp[v][1]) )   // 子节点随意
  dp[u][1] = u.val + sum( dp[v][0] )          // 子节点不能选
  ```

---

### 路径计数 / 分割方案

从根到叶子的路径和 == target 的条数。

* 思路：

  * 用递归函数返回「从当前节点出发能组成 target 的方案数」。
  * 或者在 DFS 时记录路径，然后用回溯做加法/减法。

---

### 状态机 DP on 树

* 类似「在树上染色」或「覆盖问题」。
* 思路就是 **节点状态有限，依赖子树状态，进行合并**。

---

### 小结

二叉树的树形 DP 常见套路：

1. **后序遍历**（左右子树算完再算父节点）。
2. **定义子问题**（通常是某个节点的最优解）。
3. **设计状态转移**（结合左右子树结果）。
4. **全局变量维护答案** 或 **dp 数组返回答案**。

---
