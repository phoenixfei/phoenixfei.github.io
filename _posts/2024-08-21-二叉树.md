---
title: "掌握二叉树：结构、遍历与递归思维"
categories: [ds-algo]
tags: [data-structure]

math: true
layout: post
---

“二叉树” 是数据结构中非常核心的内容，常见于各种算法题，特别是在递归、动态规划、图算法等领域有广泛应用。

## 树的实现

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

## 一些常见的树

### 满二叉树

- **国内定义**：一个二叉树，每一层的结点数都达到最大值。也就是说，如果一个二叉树的层数为k，且结点总数为$2^k-1$，则它就是满二叉树（Full Binary Tree）。
- **国外定义**：如果一个二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

**国内外定义有歧义**。国内做法：

- 在国际交流场合，包括学术会议发表论文等都应该使用国际定义；
- 在国内的各种考试场合，如研究生考试、软考，使用国内教程的定义。

### 完全二叉树

Complete Binary Tree，除了最后一层之外的其他每一层都被完全填充，并且所有结点都保持向左对齐。

### 完美二叉树

Perfect Binary Tree，除了叶子结点之外的每一个结点都有两个孩子，每一层(当然包含最后一层)都被完全填充。

![v2-37769edff7e51a865dadf6d111afc5f1_hd]({{ site.baseurl }}/assets/images/v2-37769edff7e51a865dadf6d111afc5f1_hd.jpg)

总结：中国定义的满二叉树就是国际定义的完美二叉树。

### 二叉查找树

Binary Search Tree，也称为**[二叉搜索树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)**，是指一棵空树或者具有以下性质的树：

1. 若任意节点的左子树不空，则左子树所有节点的值小于它根节点的值；
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点。

二叉查找树**中序遍历**结果**有序**。

### 红黑树

[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)，Red-black Tree，是一种自平衡二叉查找树，典型的用途是**关联数组**。

在二叉查找树强制的一般要求外，对于任何有效的红黑树，我们增加了如下额外的要求：
* 节点是红色或黑色。
* 根是黑色。
* 所有叶子都是黑色（叶子是NIL节点）。
* 每个红色节点必须有两个黑色的子节点。
  * 或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。
  * 或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。
  * 或者说红色节点的父节点和子节点均是黑色的。
* 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

![1920px-Red-black_tree_example.svg]({{ site.baseurl }}/assets/images/1920px-Red-black_tree_example.svg.png)

## 遍历

### 层次遍历

层序遍历就是按照 从上到下、从左到右 的顺序，一层一层访问二叉树的节点。 它是 广度优先搜索 (BFS) 在二叉树上的应用。

- [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        ans = []
        q = deque([root])
        while q:
            vals = []
            for _ in range(len(q)):
                node = q.popleft()
                vals.append(node.val)
                if node.left:  q.append(node.left)
                if node.right: q.append(node.right)
            ans.append(vals)
        return ans
```

---

### 先/中/后序遍历

- 先序(根左右)：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树
- 中序(左根右)：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树
- 后序(左右根)：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值

> Tips：无论先序、中序、后序，对节点的考查（不一定输出）顺序都是一样的。

![2405011-5f5b0b136713f744]({{ site.baseurl }}/assets/images/2405011-5f5b0b136713f744-1558060683243.jpg)

---

**通过递归实现先/中/后序遍历**：
代码模板一致，仅节点处理的顺序不同

**通过迭代实现先/中/后序遍历**：
因为需要在遍历完节点的左子树时接着遍历节点的右子树，为了能找到该节点，需要使用**栈**来进行暂存。

---

**先序遍历**
- [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

递归实现
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            ans.append(node.val)
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return ans
```

迭代实现
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        cur = root
        stack = []
        while cur or stack:
            while cur:
                stack.append(cur)
                ans.append(cur.val)
                cur = cur.left
            cur = stack.pop().right
        return ans
```

---

**中序遍历**
- [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

递归实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            dfs(node.left)
            ans.append(node.val)
            dfs(node.right)
        dfs(root)
        return ans
```

迭代实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = []
        cur = root
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack.pop()
            ans.append(cur.val)
            cur = cur.right
        return ans
```

---

**后序遍历**
- [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

递归实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            dfs(node.left)
            dfs(node.right)
            ans.append(node.val)
        dfs(root)
        return ans
```

迭代实现

后序遍历与先序、中序遍历不一样之处在于：**后序遍历在输出当前节点值时，需要考虑其左右之树是否已经遍历完成。**

> 所以，需要设置一个lastVisit游标。当lastVisit等于当前节点的右子树，表示该节点的左右子树都已经遍历完成，才可以输出当前节点值。

![2405011-a3b88566f13549af]({{ site.baseurl }}/assets/images/2405011-a3b88566f13549af.jpg)

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = []
        cur = root
        last_vst = None
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack[-1]
            if cur.right is None or cur.right == last_vst:
                ans.append(cur.val)
                cur = stack.pop()
                last_vst = cur
                cur = None
            else:
                cur = cur.right
        return ans
```

---

## 递归与分治

> 二叉树天然适合递归：根节点 + 左子树 + 右子树

* **题型**：

  * 求树的高度 / 节点数
  * 子树判断 / 相同树判断
  * 翻转二叉树

* **题目**：
  * [LeetCode 104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
  * [LeetCode 226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
  * [LeetCode 100. 相同的树](https://leetcode.cn/problems/same-tree/)

---

## 回溯/路径搜索

> 在 DFS 过程中记录路径，常用于“路径和/所有路径”问题。

* **题型**：

  * 根到叶路径
  * 路径总和

* **题目**：

  * [LeetCode 112. 路径总和](https://leetcode.cn/problems/path-sum/)
  * [LeetCode 113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
  * [LeetCode 257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

---

## 树形DP

> 在每个节点上用状态表示子树结果，然后组合左右子树解答。

* **题型**：

  * 树的直径
  * 树上的最大路径和
  * 树形打家劫舍

* **题目**：

  * [LeetCode 543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
  * [LeetCode 124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
  * [LeetCode 337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

---

## 构造与还原

> 通过遍历结果（前序+中序 / 后序+中序）还原二叉树。

* **题目**：

  * [LeetCode 105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
  * [LeetCode 106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

---

## 经典题目

### 修剪二叉搜索树

[修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)。通过修剪二叉搜索树，使得所有节点的值在`[L, R]`中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

```java
public TreeNode trimBST(TreeNode root, int L, int R) {
    if(root == null) return null;
    if(root.val < L) return trimBST(root.right, L, R);
    if(root.val > R) return trimBST(root.left, L, R);
    root.left = trimBST(root.left, L, R);
    root.right = trimBST(root.right, L, R);
    return root;
}
```

### 二叉搜索树中第K小的元素

[二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)。给定一个二叉搜索树，查找其中第 **k** 个最小的元素。

方法1：**根据节点的个数求解**

```java
public int kthSmallest(TreeNode root, int k) {
    int cnt = count(root.left);
    if(cnt == k-1) return root.val;
    else if(cnt > k-1) return kthSmallest(root.left, k);
    else return kthSmallest(root.right, k-cnt-1);
}
// 统计树的节点个数
private int count(TreeNode node) {
    if(node == null) return 0;
    return 1 + count(node.left) + count(node.right);
}
```

给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。

方法2：**根据中序遍历求解**：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。所以，按照中序遍历顺序找到第k个结点就是结果。

方法2-1：**递归解法**

```java
private int index = 0;
TreeNode KthNode(TreeNode root, int k){
    if(root != null){
        TreeNode cur = KthNode(root.left, k);
        if(cur != null)	return cur; // 左子树中找到符合要求的节点返回
        index ++;
        if(index == k)	return root; // 从最左节点开始，count+1；
        cur = KthNode(root.right, k);
        if(cur != null)	return cur; //左子树没找到，在右子树找到了符合要求的节点返回
    }
    return null;
}
```

方法2-2：**迭代解法**

```java
TreeNode KthNode(TreeNode root, int k){
    if(root == null || k <= 0) return null;
    Stack<TreeNode> stack = new Stack<TreeNode>();
    while(root != null || !stack.isEmpty()){
        while(root != null){
            stack.push(root);
            root = root.left;
        }
        TreeNode cur = stack.pop();
        k--;
        if(k == 0)	return cur;
        root = cur.right;
    }
    return null;
}
```

### 判断是否为平衡二叉树

给定一个二叉树，判断它是否是[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)。

一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。

```java
boolean flag = true;

public boolean IsBalanced_Solution(TreeNode root) {
    depth(root);
    return flag;
}

public int depth(TreeNode root){
    if(root == null) return 0;
    int left = depth(root.left);
    int right = depth(root.right);
    if(Math.abs(left - right) > 1) flag = false;
    return Math.max(left, right) + 1;
}
```

### 相同节点值的最大路径长度

[相同节点值的最大路径长度](https://leetcode-cn.com/problems/longest-univalue-path/)。给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

```java
private int path = 0;

public int longestUnivaluePath(TreeNode root) {
    dfs(root);
    return path;
}

private int dfs(TreeNode root){
    if (root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    int leftPath = root.left != null && root.left.val == root.val ? left + 1 : 0;
    int rightPath = root.right != null && root.right.val == root.val ? right + 1 : 0;
    path = Math.max(path, leftPath + rightPath);
    return Math.max(leftPath, rightPath);
}
```

### 把二叉搜索树转换为累加树

[把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)。给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

```java
private int sum = 0;
public TreeNode convertBST(TreeNode root) {
    rightSum(root);
    return root;
}
// 从最右侧开始对每个节点的值进行求和
private void rightSum(TreeNode node) {
    if(node == null) return;
    rightSum(node.right);
    sum += node.val;
    node.val = sum;
    rightSum(node.left);
}
```

---
