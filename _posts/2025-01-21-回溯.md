---
title: "回溯"
categories: [ds-algo]

math: true
layout: post
---

**回溯法**（backtracking）是暴力搜索法中的一种。

## 如何理解回溯法

对于某些计算问题而言，回溯法是一种可以找到所有（或一部分）解的一般性算法，尤其适用于约束满足问题。

在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解。

---

## 基本思想

回溯法解决的问题都可以抽象为树形结构！集合的大小就构成了树的宽度，递归的深度就构成了树的深度。

在包含问题的所有解的空间树树中，按照**深度优先搜索**的策略，从根节点出发深度搜索解空间树。当搜索到某一结点时，要判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

若用回溯法求解问题的任一解时，只要搜索到问题的一个解就可以结束。

---

## 求解步骤

1. 针对所有问题，确定问题的解空间：

   首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

2. 确定结点的扩展搜索规则

3. 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索

---

## 算法框架

**实际上，回溯算法就是一个N叉树的前序遍历加上后续遍历而已。**

同时，回溯算法是有模板的。用递归表示N叉树的深度遍历，在每次深度遍历的过程中，又横向遍历每一层所有的条件。

```python
# 二叉树遍历框架
def traverse(root):
    if root is None: return
    # 前序遍历代码写在这
    traverse(root.left)
    # 中序遍历代码写在这 
    traverse(root.right)
    # 后序遍历代码写在这

# N 叉树遍历框架
def traverse(root):
    if root is None: return
    for child in root.children:
        # 前序遍历代码写在这
        traverse(child)
        # 后序遍历代码写在这
```

补充：树的遍历框架虽然简答，但是再怎么强调都不为过。因为见的算法多了之后，你会发现，有关递归的算法，都离不开“树”的遍历这一抽象模型。**只不过对于不同的算法，在前（中）后序遍历的时候，所做的事不同**。

> 比如，斐波拉契的例子就是一个二叉树，凑零钱的例子就是个N叉树，N为硬币面值的种数。看他们的递归解法代码，就会发现，都是上述代码模板的变形而已。

言归正传，回溯算法就是N叉树的遍历，这个N等于当前可做的选择（choices）的总数，同时，在前序遍历的位置作出当前选择（choose过程），然后开始递归。最后，在后序遍历的位置取消当前选择（unchoose过程）。回溯算法伪代码模板如下所示：

```python
"""
choiceList：当前可以进行的选择列表
track：可以理解为决策路径，即已经做出一系列选择
answer：用来储存我们的符合条件决策路径
"""

def backtrack(choiceList, track, answer):
    if track is OK:
        answer.add(track)
    else:
        for choice in choiceList:
            # choose：选择一个 choice 加入 track
            backtrack(choice, track, answer)
            # unchoose：从 track 中撤销上面的选择
```

---

## 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

* 组合问题：N个数里面按一定规则找出k个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个N个数的集合里有多少符合条件的子集
* 排列问题：N个数按一定规则全排列，有几种排列方式
* 棋盘问题：N皇后，解数独等等

---
