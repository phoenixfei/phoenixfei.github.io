---
title: "集合操作的高效利器：位运算"
categories: [03_ProgrammingTips]
tags: [bitwise, set]

math: true
layout: post
---

在算法中，我们经常需要对集合进行交、并、差等操作，而直接使用列表或集合往往效率不高。

位运算可以将集合压缩成二进制整数，用几行代码高效完成各种集合操作，简洁又优雅。

---

## 二进制与集合

[参考链接](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)

在集合论中，有诸如：
* **交集**：$$ A \cap B $$
* **并集**：$$ A \cup B $$
* **差集**：$$ A \setminus B $$
* **子集**：$$ A \subseteq B $$

这些操作在编程中通常使用哈希表（如 `set` 或 `unordered_set`）实现。例如，求两个集合的交集时，一种常见方法是：**逐个遍历哈希表中的元素，判断是否存在于另一个集合中**。

不过，这种方式在元素范围已知且不大的情况下，并不是最高效的做法。

> **这时，二进制（位运算）就登场了！**

---

## 用二进制表示集合

我们可以用一个整数的二进制形式来表示集合：

* 假设全集是 `{0, 1, 2, ..., n-1}`，我们用第 `i` 位是否为 1 来表示元素 `i` 是否在集合中。
* 如果第 `i` 位为 `1`，表示元素 `i` 存在于集合中。
* 如果为 `0`，则表示不存在。


例如，集合 `{0, 2, 3}` 对应的二进制是：

```
 1 1 0 1（二进制） = 13（十进制）
 ↑ ↑   ↑
 3 2   0
```

反过来，二进制数 `1101`（即十进制的 13）也可以还原为集合 `{0, 2, 3}`。

正式地说，**一个只包含非负整数的集合 $S$**，可以用如下方式压缩成一个整数：

$$
f(S) = \sum_{i \in S} 2^i
$$

也就是说，将集合中每个元素 $i$ 映射为 $2^i$，然后对这些值求和。

集合 $S = \{0, 2, 3\}$，其压缩形式为：

$$
f(S) = 2^0 + 2^2 + 2^3 = 1 + 4 + 8 = 13
$$

对应的二进制为：

```
1101 (2)
```

这个整数不仅代表集合 `{0, 2, 3}`，还可以用于位运算加速集合相关操作（如交集、并集、差集等）。

利用位运算「并行计算」的特点，我们可以高效地做一些和集合有关的运算。按照常见的应用场景，可以分为以下四类：

* 集合与集合
* 集合与元素
* 遍历集合
* 枚举集合

---

## 集合与集合

其中 `&` 表示按位与，`∣` 表示按位或，`⊕` 表示按位异或，`∼` 表示按位取反。

两个集合的「对称差」是只属于其中一个集合，而不属于另一个集合的元素组成的集合，也就是不在交集中的元素组成的集合。

| 术语        | 集合表示               | 位运算表示               | 集合示例                                         | 位运算示例                         |
|-------------|------------------------|--------------------------|--------------------------------------------------|------------------------------------|
| **交集**    | $$A \cap B$$           | `a & b`                  | $$\{0,2,3\} \cap \{0,1,2\} = \{0,2\}$$            | `1101 & 0111 = 0101`               |
| **并集**    | $$A \cup B$$           | `a \| b`                 | $$\{0,2,3\} \cup \{0,1,2\} = \{0,1,2,3\}$$        | `1101 | 0111 = 1111`               |
| **对称差**  | $$A \bigtriangleup B$$ | `a ^ b`                  | $$\{0,2,3\} \bigtriangleup \{0,1,2\} = \{1,3\}$$  | `1101 ^ 0111 = 1010`               |
| **差集**    | $$A \setminus B$$      | `a & ~b`                 | $$\{0,2,3\} \setminus \{1,2\} = \{0,3\}$$         | `1101 & ~0110 = 1001`              |
| **差（子集）** | $$A \setminus B,\quad B \subseteq A$$ | `a ^ b` | $$\{0,2,3\} \setminus \{0,2\} = \{3\}$$          | `1101 ^ 0101 = 1000`               |
| **包含于**  | $$A \subseteq B$$      | `a & b = a` <br> `a \| b = b` | $$\{0,2\} \subseteq \{0,2,3\}$$                  | `0101 & 1101 = 0101` <br> `0101 | 1101 = 1101` |

> 包含于（判断子集）的两种位运算写法是等价的，在编程时只需判断其中任意一种。此外，还可以用 `(a & ~b) == 0` 判断，如果成立，也表示 A 是 B 的子集。

---

## 集合与元素

通常会用到移位运算。

其中 `<<` 表示左移，`>>` 表示右移。

> 注：左移 i 位相当于乘以 $2^i$，右移 i 位相当于除以 $2^i$。

**集合操作与位运算对照表：**

| 操作               | 集合表示                              | 位运算表示                | 示例                                                             | 位表示示例                |
|--------------------|-------------------------------------|--------------------------|----------------------------------------------------------------|--------------------------|
| 空集               | $$\emptyset$$                       | `0`                      |                                                                |                          |
| 单元素集合          | $$\{i\}$$                         | `1 << i`                 | $$\{2\}$$                                                      | `1 << 2`                 |
| 全集               | $$U = \{0,1,\ldots,n-1\}$$          | `(1 << n) - 1`           | $$\{0,1,2,3\}$$                                                | `1 << 4 - 1`             |
| 补集               | $$\complement_U S = U \setminus S$$ | `((1 << n) - 1) ^ s`     | $$U = \{0, 1, 2, 3\} $$ <br/>$$ \complement_U \{1, 2\} = \{0, 3\}$$ | `1111 ^ 0110 = 1001`     |
| 属于               | $$i \in S$$                         | `(s >> i) & 1 == 1`      | $$2 \in \{0,2,3\}$$                                            | `(1101 >> 2) & 1 = 1`    |
| 不属于             | $$i \notin S$$                      | `(s >> i) & 1 == 0`      | $$1 \notin \{0,2,3\}$$                                         | `(1101 >> 1) & 1 = 0`    |
| 添加元素           | $$S \cup \{i\}$$                    | `s | (1 << i)`                                                      | $$\{0, 3\} \cup \{2\}$$                                     | `1001 | (1 << 2)`        |
| 删除元素           | $$S \setminus \{i\}$$               | `s & ~(1 << i)`          | $$\{0,2,3\} \setminus \{2\}$$                                  | `1101 & ~(1 << 2)`       |
| 删除元素<br/>一定在集合中 | $$S \setminus \{i\},\quad i \in S$$ | `s ^ (1 << i)`           | $$\{0,2,3\} \setminus \{2\}$$                                  | `1101 ^ (1 << 2)`        |
| 删除最小元素         |                                     | `s & (s - 1)`            |                                                                | `1100 & 1011 = 1000`     |

编程语言提供了一些和二进制有关的库函数，例如：

| 功能     | 描述                 | Python API 
| ------ | ------------------ | ------------------ |
| 集合大小   | 计算二进制中的 1 的个数      |  `s.bit_count()` |
| 集合最大元素 | 计算二进制长度，减一即最大元素下标  | `s.bit_length() - 1` |
| 集合最小元素 | 计算末尾 0 的个数，即最小元素下标 | `(s&-s).bit_length()-1` |

---

## 遍历集合

假设集合元素范围为 0 到 n−1，通常有两种遍历集合的方法：

**逐元素判断**：枚举范围中的元素 `i`，判断其是否在集合 `s` 中：

```python
for i in range(n):
    if (s >> i) & 1:  # 判断 i 是否在 s 中
        # 处理 i 的逻辑
```

**直接遍历集合 `s` 中的元素**：不断地计算集合最小元素、去掉最小元素，直到集合为空。

```python
t = s
while t:
    lowbit = t & -t
    t ^= lowbit
    i = lowbit.bit_length() - 1
    # 处理 i 的逻辑
```

---
