---
title: "位操作全解：从基础到高阶"
categories: [03_ProgrammingTips]
tags: [bitwise]

math: true
layout: post
---

对整数的二进制位进行操作，如与（AND）、或（OR）、异或（XOR）、左移、右移等操作。

## 原码、反码与补码

| 名称                 | 含义                        | 说明         |
| ------------------ |---------------------------| ---------- |
| 原码 | 最高位为符号位（0 正 1 负），其余位为数值部分 | 人类直观表示方式   |
| 反码 | 正数：和原码一样；负数：原码符号位不变，数值位按位取反    | 早期计算机中间表示  |
| 补码 | 正数：和原码一样；负数：**反码** + 1   | 现代计算机标准表示法 |

> 所有现代计算机用的都是 **补码（Two's Complement）**，它的好处是：
> 
> * 加减法统一，用一个加法器搞定
> * 符号位参与运算，无需特别处理）
> * 零只有一种表示方式
> * 补码的范围更对称，易于溢出检测


---

## 二机制数示例 

在计算机语言中，不同语言、不同类型的整数，其二进制长度也有所不同。
为方便演示二进制的具体格式和编码内容，以8位二进制数进行举例说明。

| 语言     | 整数类型   | 位数             | 是否固定？ | 备注                      |
| ------ | ------ | -------------- | --- | ----------------------- |
| Python | `int`  | **无限精度**（动态增长） |  非固定 | 只受限于内存；`2**1000` 也是合法整数 |
| Java   | `int`  | 32 位（补码）       |  固定 | -2³¹ 到 2³¹-1            |
| Java   | `long` | 64 位（补码）       |  固定 | -2⁶³ 到 2⁶³-1            |

**正数：`5` 的原码、反码、补码：**

| 编码类型 | 值    | 二进制解释      |
| ---- | ---- | ---------- |
| 原码   | `+5` | `00000101` |
| 反码   | `+5` | `00000101` |
| 补码   | `+5` | `00000101` |

> 正数在三种编码中是一样的

**负数：`-5` 的原码、反码、补码：**

| 编码类型 | 值    | 二进制解释                   |
| ---- | ---- | ----------------------- |
| 原码   | `-5` | `10000101`（符号1 + 绝对值）   |
| 反码   | `-5` | `11111010`（符号位不变，其它位取反） |
| 补码   | `-5` | `11111011`（反码 + 1）      |

> 现代计算机只使用补码存储整数！

---

**补码运算规则总结（重点）：**

1. 正数的补码 = 原码 = 反码
2. 负数的补码 = 原码符号位不变 + 其它位按位取反 + 最后 +1
3. `-x = ~x + 1` 反向生成负数（按位取反，末位加一）
4. 减法可转为加法：`a - b = a + (~b + 1)`

---

**二进制0：**

| 表示方式 | +0         | -0         | 是否不同 |
| --- | ---------- | ---------- | --- |
| 原码  | `00000000` | `10000000` |  不同 |
| 反码  | `00000000` | `11111111` |  不同 |
| 补码  | `00000000` | `00000000` |  相同 |

**计算过程：**

> 按照补码规则，**负数 = 反码 + 1**

计算 `-0` 的补码：
1. 0 的原码：`00000000`
2. 按位取反：`11111111`
3. 加 1：`11111111 + 1 = 00000000`（进位丢掉）

最终得到：`00000000`
> 所以 **-0 的补码 = +0 的补码 = `00000000`**

---

## 位操作运算符

1. 位操作只能用于**整形（字符）**数据
2. 位操作的优先级比较低，因此尽量使用**扩号**来确保运算顺序
3. 位操作也有一些复合操作符，如 &=、\|=、 ^=、\<<=、\>>=

| 符号   | 描述               | 位运算规则                                 |
|------| :----------------- | :----------------------------------------- |
| &    | 与                 | 两个位都为1时，结果才为1                   |
| \|   | 或                 | 两个位都为0时，结果才为0                   |
| ^    | 异或               | 两个位**相异时为1，相同时为0**             |
| ~    | 取反（单目运算符） | 0 变 1，1 变 0                             |
| \<<  | 左移               | 各二进位全部左移若干位，高位丢弃，低位补 0 |
| \>>  | 右移               | 各二进位全部右移若干位，**高位补符号位**   |
| \>>> | 无符号右移         | 各二进位全部右移若干位，**高位补0**        |


## 基础位操作技巧

### 判断奇偶性

```python
def is_odd(n):
    return (n & 1) == 1

print(is_odd(5))   # True
print(is_odd(8))   # False
```

解释：
* 任何整数的**最低位决定奇偶性**
* `x & 1` 提取最低位，如果是1，则为奇数

---

### 交换两个数（不使用临时变量）

```python
def swap(a, b):
    a = a ^ b
    b = a ^ b  # 相当于 b = (a ^ b) ^ b = a
    a = a ^ b  # 相当于 a = (a ^ b) ^ a = b
    return a, b

print(swap(5, 10))  # (10, 5)
```

解释：
* 利用异或的特性：`x ^ x = 0`, `x ^ 0 = x`
* 不需要使用额外内存

---

### 提取最低位的 1（lowbit）

```python
def lowbit(x):
    return x & -x

print(bin(12))        # 0b1100
print(bin(lowbit(12)))  # 0b100
```

解释：
* `-x` 在补码中等于 `~x + 1`，会把最低的1留下，其它清零
* 常用于树状数组、快速枚举子集

---

### 去除最低位的 1

```python
def remove_lowest_bit(x):
    return x & (x - 1)

print(bin(12))                # 0b1100
print(bin(remove_lowest_bit(12)))  # 0b1000
```

解释：
* `x - 1` 会把最低的1变成0，右边的0变成1
* 常用于**计数二进制中1的个数**

---

### 统计整数中1的个数（Hamming Weight）

```python
def count_ones(x):
    count = 0
    while x:
        x &= (x - 1)
        count += 1
    return count

print(count_ones(15))  # 4
```

解释：
* 每次 `x & (x - 1)` 去掉一个 1
* 时间复杂度 = 二进制中1的个数（比按位扫描快）

---

### 判断某一位是否为1

```python
def is_bit_set(x, k):
    return ((x >> k) & 1) == 1

print(is_bit_set(5, 0))  # True  (0001)
print(is_bit_set(5, 1))  # False
```

解释：
* 将第 `k` 位右移到最低位，然后与1做 & 运算

---

### 设置 / 清除 / 翻转某一位

```python
# 将第k位（从0开始索引）置为1
def set_kth_bit(x, k):
    return x | (1 << k)

# 将第k位（从0开始索引）置为0
def clear_kth_bit(x, k):
    return x & ~(1 << k)

# 将第k位（从0开始索引）翻转，即1->0；0->1
def toggle_kth_bit(x, k):
    return x ^ (1 << k)

print(bin(set_kth_bit(8, 1)))     # 0b1010
print(bin(clear_kth_bit(10, 1)))  # 0b1000
print(bin(toggle_kth_bit(10, 1))) # 0b1000
```

解释：
* `1 << k` 构造一个只有第 `k` 位是1 的掩码

---

### 判断是否是 2 的幂

```python
def is_power_of_two(x):
    return x > 0 and (x & (x - 1)) == 0

print(is_power_of_two(8))   # True
print(is_power_of_two(10))  # False
```

解释：
* 2 的幂在二进制中只有一个 1
* `x & (x - 1)` 可以去掉这个 1，所以结果应为 0

**经典例题**
- [326. 3 的幂](https://leetcode.cn/problems/power-of-three/)
- [1780. 判断一个数字是否可以表示成三的幂的和](https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/)
- [342. 4的幂](https://leetcode.cn/problems/power-of-four/)

---

## 复杂位操作技巧

### 位操作快速乘法

```python
def fast_mul(a, b, mod):
    res = 0
    while b:
        if b & 1:
            res = (res + a) % mod
        a = (a + a) % mod
        b >>= 1
    return res

print(fast_mul(7, 13, 1000))  # 91
```

解释：
* 避免整数乘法溢出，用“加+位移”模拟乘法。
* 可用于**快速幂、模乘**

---

### 位操作实现加法

首先看十进制是如何做的： 5+7=12，三步走 

- 第一步：相加各位的值，不算进位，得到2。 
- 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。  
- 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 

同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 

- 第一步：相加各位的值，不算进位，得到010，**二进制每位相加就相当于各位做异或操作**，101^111。 
- 第二步：计算进位值，得到1010，**相当于各位进行与操作得到101，再向左移一位得到1010**，(101&111)<<1。  
- 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。  

```java
public int getSum(int num1,int num2) {
    while(num2 != 0){
        int temp = num1 ^ num2;
        num2 = (num1 & num2) << 1;
        num1 = temp;
    }
    return num1;
}
```

```python
def getSum(a: int, b: int) -> int:
    MAX = 0x7FFFFFFF  # 最大32位整数（正数）
    MASK = 0xFFFFFFFF  # 32位掩码，模拟无符号整数

    while b != 0:
        temp = (a ^ b) & MASK
        b = ((a & b) << 1) & MASK
        a = temp

    # 如果 a 超过了最大正整数范围，表示它是负数补码
    return a if a <= MAX else ~(a ^ MASK)
```

> 在 Python 中： int 是 不限制位数的“无限精度整数” ，你可以表示任意大的正数或负数。
> 
> 所以，必须用 MASK 和 MAX 来模拟补码行为。

---

### 子集枚举

```python
def subset_enum(arr):
    n = len(arr)
    for mask in range(1 << n):
        subset = []
        for i in range(n):
            if (mask >> i) & 1:
                subset.append(arr[i])
        print(subset)

subset_enum([1, 2, 3])
```

解释：
* 用一个整数的二进制位表示集合的每个元素是否被选中

---

### 状压DP 

```python
n = 3
dp = [[float('inf')] * n for _ in range(1 << n)]
dp[1][0] = 0  # 从城市0出发，状态为 001

# 示例只是状态压缩DP框架，如TSP问题中会使用
```

---

## 二进制与集合

[参考链接](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)

在集合论中，有诸如：
* **交集**：$$ A \cap B $$
* **并集**：$$ A \cup B $$
* **差集**：$$ A \setminus B $$
* **子集**：$$ A \subseteq B $$

这些操作在编程中通常使用哈希表（如 `set` 或 `unordered_set`）实现。例如，求两个集合的交集时，一种常见方法是：**逐个遍历哈希表中的元素，判断是否存在于另一个集合中**。

不过，这种方式在元素范围已知且不大的情况下，并不是最高效的做法。

> **这时，二进制（位运算）就登场了！**

---

### 用二进制表示集合

我们可以用一个整数的二进制形式来表示集合：

* 假设全集是 `{0, 1, 2, ..., n-1}`，我们用第 `i` 位是否为 1 来表示元素 `i` 是否在集合中。
* 如果第 `i` 位为 `1`，表示元素 `i` 存在于集合中。
* 如果为 `0`，则表示不存在。


例如，集合 `{0, 2, 3}` 对应的二进制是：

```
 1 1 0 1（二进制） = 13（十进制）
 ↑ ↑   ↑
 3 2   0
```

反过来，二进制数 `1101`（即十进制的 13）也可以还原为集合 `{0, 2, 3}`。

正式地说，**一个只包含非负整数的集合 $S$**，可以用如下方式压缩成一个整数：

$$
f(S) = \sum_{i \in S} 2^i
$$

也就是说，将集合中每个元素 $i$ 映射为 $2^i$，然后对这些值求和。

集合 $S = \{0, 2, 3\}$，其压缩形式为：

$$
f(S) = 2^0 + 2^2 + 2^3 = 1 + 4 + 8 = 13
$$

对应的二进制为：

```
1101 (2)
```

这个整数不仅代表集合 `{0, 2, 3}`，还可以用于位运算加速集合相关操作（如交集、并集、差集等）。

利用位运算「并行计算」的特点，我们可以高效地做一些和集合有关的运算。按照常见的应用场景，可以分为以下四类：

* 集合与集合
* 集合与元素
* 遍历集合
* 枚举集合

---

### 集合与集合

其中 `&` 表示按位与，`∣` 表示按位或，`⊕` 表示按位异或，`∼` 表示按位取反。

两个集合的「对称差」是只属于其中一个集合，而不属于另一个集合的元素组成的集合，也就是不在交集中的元素组成的集合。

| 术语        | 集合表示               | 位运算表示               | 集合示例                                         | 位运算示例                         |
|-------------|------------------------|--------------------------|--------------------------------------------------|------------------------------------|
| **交集**    | $$A \cap B$$           | `a & b`                  | $$\{0,2,3\} \cap \{0,1,2\} = \{0,2\}$$            | `1101 & 0111 = 0101`               |
| **并集**    | $$A \cup B$$           | `a \| b`                 | $$\{0,2,3\} \cup \{0,1,2\} = \{0,1,2,3\}$$        | `1101 | 0111 = 1111`               |
| **对称差**  | $$A \bigtriangleup B$$ | `a ^ b`                  | $$\{0,2,3\} \bigtriangleup \{0,1,2\} = \{1,3\}$$  | `1101 ^ 0111 = 1010`               |
| **差集**    | $$A \setminus B$$      | `a & ~b`                 | $$\{0,2,3\} \setminus \{1,2\} = \{0,3\}$$         | `1101 & ~0110 = 1001`              |
| **差（子集）** | $$A \setminus B,\quad B \subseteq A$$ | `a ^ b` | $$\{0,2,3\} \setminus \{0,2\} = \{3\}$$          | `1101 ^ 0101 = 1000`               |
| **包含于**  | $$A \subseteq B$$      | `a & b = a` <br> `a \| b = b` | $$\{0,2\} \subseteq \{0,2,3\}$$                  | `0101 & 1101 = 0101` <br> `0101 | 1101 = 1101` |

> 包含于（判断子集）的两种位运算写法是等价的，在编程时只需判断其中任意一种。此外，还可以用 `(a & ~b) == 0` 判断，如果成立，也表示 A 是 B 的子集。

---

### 集合与元素

通常会用到移位运算。

其中 `<<` 表示左移，`>>` 表示右移。

> 注：左移 i 位相当于乘以 $2^i$，右移 i 位相当于除以 $2^i$。

**集合操作与位运算对照表：**

| 操作               | 集合表示                              | 位运算表示                | 示例                                                             | 位表示示例                |
|--------------------|-------------------------------------|--------------------------|----------------------------------------------------------------|--------------------------|
| 空集               | $$\emptyset$$                       | `0`                      |                                                                |                          |
| 单元素集合          | $$\{i\}$$                         | `1 << i`                 | $$\{2\}$$                                                      | `1 << 2`                 |
| 全集               | $$U = \{0,1,\ldots,n-1\}$$          | `(1 << n) - 1`           | $$\{0,1,2,3\}$$                                                | `1 << 4 - 1`             |
| 补集               | $$\complement_U S = U \setminus S$$ | `((1 << n) - 1) ^ s`     | $$U = \{0, 1, 2, 3\} $$ <br/>$$ \complement_U \{1, 2\} = \{0, 3\}$$ | `1111 ^ 0110 = 1001`     |
| 属于               | $$i \in S$$                         | `(s >> i) & 1 == 1`      | $$2 \in \{0,2,3\}$$                                            | `(1101 >> 2) & 1 = 1`    |
| 不属于             | $$i \notin S$$                      | `(s >> i) & 1 == 0`      | $$1 \notin \{0,2,3\}$$                                         | `(1101 >> 1) & 1 = 0`    |
| 添加元素           | $$S \cup \{i\}$$                    | `s | (1 << i)`                                                      | $$\{0, 3\} \cup \{2\}$$                                     | `1001 | (1 << 2)`        |
| 删除元素           | $$S \setminus \{i\}$$               | `s & ~(1 << i)`          | $$\{0,2,3\} \setminus \{2\}$$                                  | `1101 & ~(1 << 2)`       |
| 删除元素<br/>一定在集合中 | $$S \setminus \{i\},\quad i \in S$$ | `s ^ (1 << i)`           | $$\{0,2,3\} \setminus \{2\}$$                                  | `1101 ^ (1 << 2)`        |
| 删除最小元素         |                                     | `s & (s - 1)`            |                                                                | `1100 & 1011 = 1000`     |

编程语言提供了一些和二进制有关的库函数，例如：

| 功能     | 描述                 | Python API 
| ------ | ------------------ | ------------------ |
| 集合大小   | 计算二进制中的 1 的个数      |  `s.bit_count()` |
| 集合最大元素 | 计算二进制长度，减一即最大元素下标  | `s.bit_length() - 1` |
| 集合最小元素 | 计算末尾 0 的个数，即最小元素下标 | `(s&-s).bit_length()-1` |

---

### 遍历集合

假设集合元素范围为 0 到 n−1，通常有两种遍历集合的方法：

**逐元素判断**：枚举范围中的元素 `i`，判断其是否在集合 `s` 中：

```python
for i in range(n):
    if (s >> i) & 1:  # 判断 i 是否在 s 中
        # 处理 i 的逻辑
```

**直接遍历集合 `s` 中的元素**：不断地计算集合最小元素、去掉最小元素，直到集合为空。

```python
t = s
while t:
    lowbit = t & -t
    t ^= lowbit
    i = lowbit.bit_length() - 1
    # 处理 i 的逻辑
```

---
