---
title: "位操作全解：从基础到高阶"
categories: [03_ProgrammingTips]
tags: [bitwise]

math: true
layout: post
---

对整数的二进制位进行操作，如与（AND）、或（OR）、异或（XOR）、左移、右移等操作。

## 原码、反码与补码

| 名称                 | 含义                        | 说明         |
| ------------------ |---------------------------| ---------- |
| 原码 | 最高位为符号位（0 正 1 负），其余位为数值部分 | 人类直观表示方式   |
| 反码 | 正数：和原码一样；负数：原码符号位不变，数值位按位取反    | 早期计算机中间表示  |
| 补码 | 正数：和原码一样；负数：**反码** + 1   | 现代计算机标准表示法 |

> 所有现代计算机用的都是 **补码（Two's Complement）**，它的好处是：
> 
> * 加减法统一，用一个加法器搞定
> * 符号位参与运算，无需特别处理）
> * 零只有一种表示方式
> * 补码的范围更对称，易于溢出检测


---

## 二机制数示例 

在计算机语言中，不同语言、不同类型的整数，其二进制长度也有所不同。
为方便演示二进制的具体格式和编码内容，以8位二进制数进行举例说明。

| 语言     | 整数类型   | 位数             | 是否固定？ | 备注                      |
| ------ | ------ | -------------- | --- | ----------------------- |
| Python | `int`  | **无限精度**（动态增长） |  非固定 | 只受限于内存；`2**1000` 也是合法整数 |
| Java   | `int`  | 32 位（补码）       |  固定 | -2³¹ 到 2³¹-1            |
| Java   | `long` | 64 位（补码）       |  固定 | -2⁶³ 到 2⁶³-1            |

**正数：`5` 的原码、反码、补码：**

| 编码类型 | 值    | 二进制解释      |
| ---- | ---- | ---------- |
| 原码   | `+5` | `00000101` |
| 反码   | `+5` | `00000101` |
| 补码   | `+5` | `00000101` |

> 正数在三种编码中是一样的

**负数：`-5` 的原码、反码、补码：**

| 编码类型 | 值    | 二进制解释                   |
| ---- | ---- | ----------------------- |
| 原码   | `-5` | `10000101`（符号1 + 绝对值）   |
| 反码   | `-5` | `11111010`（符号位不变，其它位取反） |
| 补码   | `-5` | `11111011`（反码 + 1）      |

> 现代计算机只使用补码存储整数！

---

**补码运算规则总结（重点）：**

1. 正数的补码 = 原码 = 反码
2. 负数的补码 = 原码符号位不变 + 其它位按位取反 + 最后 +1
3. `-x = ~x + 1` 反向生成负数（按位取反，末位加一）
4. 减法可转为加法：`a - b = a + (~b + 1)`

---

**二进制0：**

| 表示方式 | +0         | -0         | 是否不同 |
| --- | ---------- | ---------- | --- |
| 原码  | `00000000` | `10000000` |  不同 |
| 反码  | `00000000` | `11111111` |  不同 |
| 补码  | `00000000` | `00000000` |  相同 |

**计算过程：**

> 按照补码规则，**负数 = 反码 + 1**

计算 `-0` 的补码：
1. 0 的原码：`00000000`
2. 按位取反：`11111111`
3. 加 1：`11111111 + 1 = 00000000`（进位丢掉）

最终得到：`00000000`
> 所以 **-0 的补码 = +0 的补码 = `00000000`**

---

## 位操作运算符

1. 位操作只能用于**整形（字符）**数据
2. 位操作的优先级比较低，因此尽量使用**扩号**来确保运算顺序
3. 位操作也有一些复合操作符，如 &=、\|=、 ^=、\<<=、\>>=

| 符号   | 描述               | 位运算规则                                 |
|------| :----------------- | :----------------------------------------- |
| &    | 与                 | 两个位都为1时，结果才为1                   |
| \|   | 或                 | 两个位都为0时，结果才为0                   |
| ^    | 异或               | 两个位**相异时为1，相同时为0**             |
| ~    | 取反（单目运算符） | 0 变 1，1 变 0                             |
| \<<  | 左移               | 各二进位全部左移若干位，高位丢弃，低位补 0 |
| \>>  | 右移               | 各二进位全部右移若干位，**高位补符号位**   |
| \>>> | 无符号右移         | 各二进位全部右移若干位，**高位补0**        |


## 基础位操作技巧

### 判断奇偶性

```python
def is_odd(n):
    return (n & 1) == 1

print(is_odd(5))   # True
print(is_odd(8))   # False
```

解释：
* 任何整数的**最低位决定奇偶性**
* `x & 1` 提取最低位，如果是1，则为奇数

---

### 交换两个数（不使用临时变量）

```python
def swap(a, b):
    a = a ^ b
    b = a ^ b  # 相当于 b = (a ^ b) ^ b = a
    a = a ^ b  # 相当于 a = (a ^ b) ^ a = b
    return a, b

print(swap(5, 10))  # (10, 5)
```

解释：
* 利用异或的特性：`x ^ x = 0`, `x ^ 0 = x`
* 不需要使用额外内存

---

### 提取最低位的 1（lowbit）

```python
def lowbit(x):
    return x & -x

print(bin(12))        # 0b1100
print(bin(lowbit(12)))  # 0b100
```

解释：
* `-x` 在补码中等于 `~x + 1`，会把最低的1留下，其它清零
* 常用于树状数组、快速枚举子集

---

### 去除最低位的 1

```python
def remove_lowest_bit(x):
    return x & (x - 1)

print(bin(12))                # 0b1100
print(bin(remove_lowest_bit(12)))  # 0b1000
```

解释：
* `x - 1` 会把最低的1变成0，右边的0变成1
* 常用于**计数二进制中1的个数**

---

### 统计整数中1的个数（Hamming Weight）

```python
def count_ones(x):
    count = 0
    while x:
        x &= (x - 1)
        count += 1
    return count

print(count_ones(15))  # 4
```

解释：
* 每次 `x & (x - 1)` 去掉一个 1
* 时间复杂度 = 二进制中1的个数（比按位扫描快）

---

### 判断某一位是否为1

```python
def is_bit_set(x, k):
    return ((x >> k) & 1) == 1

print(is_bit_set(5, 0))  # True  (0001)
print(is_bit_set(5, 1))  # False
```

解释：
* 将第 `k` 位右移到最低位，然后与1做 & 运算

---

### 设置 / 清除 / 翻转某一位

```python
# 将第k位（从0开始索引）置为1
def set_kth_bit(x, k):
    return x | (1 << k)

# 将第k位（从0开始索引）置为0
def clear_kth_bit(x, k):
    return x & ~(1 << k)

# 将第k位（从0开始索引）翻转，即1->0；0->1
def toggle_kth_bit(x, k):
    return x ^ (1 << k)

print(bin(set_kth_bit(8, 1)))     # 0b1010
print(bin(clear_kth_bit(10, 1)))  # 0b1000
print(bin(toggle_kth_bit(10, 1))) # 0b1000
```

解释：
* `1 << k` 构造一个只有第 `k` 位是1 的掩码

---

### 判断是否是 2 的幂

```python
def is_power_of_two(x):
    return x > 0 and (x & (x - 1)) == 0

print(is_power_of_two(8))   # True
print(is_power_of_two(10))  # False
```

解释：
* 2 的幂在二进制中只有一个 1
* `x & (x - 1)` 可以去掉这个 1，所以结果应为 0

**经典例题**
- [326. 3 的幂](https://leetcode.cn/problems/power-of-three/)
- [1780. 判断一个数字是否可以表示成三的幂的和](https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three/)
- [342. 4的幂](https://leetcode.cn/problems/power-of-four/)

---

## 复杂位操作技巧

### 位操作快速乘法

```python
def fast_mul(a, b, mod):
    res = 0
    while b:
        if b & 1:
            res = (res + a) % mod
        a = (a + a) % mod
        b >>= 1
    return res

print(fast_mul(7, 13, 1000))  # 91
```

解释：
* 避免整数乘法溢出，用“加+位移”模拟乘法。
* 可用于**快速幂、模乘**

---

### 位操作实现加法

首先看十进制是如何做的： 5+7=12，三步走 

- 第一步：相加各位的值，不算进位，得到2。 
- 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。  
- 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 

同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 

- 第一步：相加各位的值，不算进位，得到010，**二进制每位相加就相当于各位做异或操作**，101^111。 
- 第二步：计算进位值，得到1010，**相当于各位进行与操作得到101，再向左移一位得到1010**，(101&111)<<1。  
- 第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。  

```java
public int getSum(int num1,int num2) {
    while(num2 != 0){
        int temp = num1 ^ num2;
        num2 = (num1 & num2) << 1;
        num1 = temp;
    }
    return num1;
}
```

```python
def getSum(a: int, b: int) -> int:
    MAX = 0x7FFFFFFF  # 最大32位整数（正数）
    MASK = 0xFFFFFFFF  # 32位掩码，模拟无符号整数

    while b != 0:
        temp = (a ^ b) & MASK
        b = ((a & b) << 1) & MASK
        a = temp

    # 如果 a 超过了最大正整数范围，表示它是负数补码
    return a if a <= MAX else ~(a ^ MASK)
```

> 在 Python 中： int 是 不限制位数的“无限精度整数” ，你可以表示任意大的正数或负数。
> 
> 所以，必须用 MASK 和 MAX 来模拟补码行为。

---

### 子集枚举

```python
def subset_enum(arr):
    n = len(arr)
    for mask in range(1 << n):
        subset = []
        for i in range(n):
            if (mask >> i) & 1:
                subset.append(arr[i])
        print(subset)

subset_enum([1, 2, 3])
```

解释：
* 用一个整数的二进制位表示集合的每个元素是否被选中

---

### 状压DP 

```python
n = 3
dp = [[float('inf')] * n for _ in range(1 << n)]
dp[1][0] = 0  # 从城市0出发，状态为 001

# 示例只是状态压缩DP框架，如TSP问题中会使用
```

---

## 经典例题

| 题号  | 题目                                                              | 标签                |
| --- | --------------------------------------------------------------- | ----------------- |
| 136 | [只出现一次的数字](https://leetcode.cn/problems/single-number/)         | 位运算 / 异或 / 模板题    |
| 137 | [只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)   | 位运算 / 三进制计数 / 提升题 |
| 260 | [只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/) | 位运算 / 分组异或 / 提升题  |

---
