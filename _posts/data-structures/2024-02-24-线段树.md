---
title: "线段树：区间查询与更新利器"
categories: [data-structures]
tags: [array, tree]

math: true
layout: post
---

线段树是一种高级数据结构，适用于频繁的区间查询和单点/区间修改问题。其本质是一个平衡二叉树，每个节点维护一个区间的信息。

**应用场景：**
* 区间和 / 区间最大值 / 区间最小值
* 区间加减 / 区间赋值（懒标记）

---

### 设计思路

**核心思想：**

每个节点表示一个区间 `[l, r]`，维护这个区间的信息，比如：
* 区间和
* 区间最大值/最小值
* 区间乘积/异或
* 甚至是复杂的结构（最大前缀和、懒惰标记等）


它将数组的每个元素看作一个区间 `[i, i]`，不断二分构建区间树，如：
```
原数组: nums = [2, 1, 5, 3]

对应区间：
        [0,3]
       /     \
    [0,1]    [2,3]
   /   \     /   \
 [0,0][1,1][2,2][3,3]
```

---

**基本操作详解及复杂度：**
* 建树 `build`, `O(n)`：从底层（叶子节点）递归构建向上，常用 DFS。
* 查询 `query`, `O(log n)`：如果目标区间包含在当前节点区间，返回当前节点值；否则递归到左右子树查找。
* 更新 `update`, `O(log n)`：修改某个元素或区间，递归更新对应的区间信息。


**线段树 vs 树状数组：**

| 项目    | 树状数组  | 线段树    |
| ----- | ----- | ------ |
| 支持操作  | 区间和类  | 任意区间统计 |
| 区间修改  | 需变形支持 | 可自然支持  |
| 空间复杂度 | O(n)  | O(n)   |
| 实现复杂度 | 简单    | 较复杂    |
| 灵活性   | 较差    | 非常强    |

---

### Python实现
**无懒惰标记**
```python
class SegmentTree:
    def __init__(self, nums):
        self.n = len(nums)
        self.tree = [0] * (self.n * 4)
        self.build(nums, 0, 0, self.n - 1) # 从根节点 build，区间为 [0, n-1]

    def build(self, nums, node, l, r):
        if l == r:
            self.tree[node] = nums[l]  # 叶子节点，赋值为原数组中的元素
        else:
            mid = (l + r) // 2
            # 递归构建左子树（编号：2*node+1），区间：[l, mid]
            self.build(nums, node * 2 + 1, l, mid)
            # 递归构建右子树（编号：2*node+2），区间：[mid+1, r]
            self.build(nums, node * 2 + 2, mid + 1, r)
            # 当前节点的值为左右子树的合并结果（此处为区间和）
            self.tree[node] = self.tree[node * 2 + 1] + self.tree[node * 2 + 2]
        
    def update(self, index, val, node=0, l=0, r=None):
        if r is None:
            r = self.n - 1
        if l == r:
            self.tree[node] = val  # 找到叶子节点，更新值
        else:
            mid = (l + r) // 2
            if index <= mid:
                self.update(index, val, node * 2 + 1, l, mid)
            else:
                self.update(index, val, node * 2 + 2, mid + 1, r)
            # 更新当前节点的值（从子树中更新）
            self.tree[node] = self.tree[node * 2 + 1] + self.tree[node * 2 + 2]

    def query(self, ql, qr, node=0, l=0, r=None):
        if r is None:
            r = self.n - 1
        if ql > r or qr < l:
            return 0  # 查询区间与当前区间完全不相交
        if ql <= l and r <= qr:
            return self.tree[node]  # 当前区间被查询区间完全包含，直接返回
        mid = (l + r) // 2
        return self.query(ql, qr, node * 2 + 1, l, mid) + \
               self.query(ql, qr, node * 2 + 2, mid + 1, r)
```

**使用示例：**
```python
arr = [2, 3, 5, 1, 4]

# 直接传入nums，进行初始化线段树
seg_tree = SegmentTree(arr)

# 外部查询或更新函数时，索引无需额外处理

# 查询原数组闭区间[0,2]
print(seg_tree.query(0, 2))  # 输出 10
# 查询原数组闭区间[1,3]
print(seg_tree.query(1, 3))  # 输出 9

# 更新：把索引2位置元素更新为10（原来是5）
seg_tree.update(2, 10)

# 再查询一次，可知更新有效
print(seg_tree.query(0, 2))  # 输出 15
print(seg_tree.query(1, 3))  # 输出 14
```

---
