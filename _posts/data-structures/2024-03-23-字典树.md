---
title: "字典树：高效字符串检索利器"
categories: [data-structures]
tags: [tree]

math: true
layout: post
---

**字典树（Trie）**，又称**前缀树**或**单词查找树**，是一种树形数据结构，常用于高效地处理字符串集合，尤其是**前缀匹配**、**字符串搜索**和**自动补全**等问题。

它的核心思想是：**利用字符串的公共前缀来节省存储空间和加快查询速度。**

---

### 设计思路

**Trie 的结构原理：**
* 每个节点表示一个字符。
* 从根节点到某一节点的路径表示一个前缀。
* 每个节点可以有多个子节点（通常是 26 个英文字母的分支）。
* 一个 `is_end` 标志表示该路径是否为一个完整单词。


**Trie 支持的基本操作：**

| 操作                   | 说明                  |
| -------------------- | ------------------- |
| `insert(word)`       | 插入单词                |
| `search(word)`       | 查询某个完整单词是否存在        |
| `startsWith(prefix)` | 是否存在以 prefix 为前缀的单词 |


**应用场景：**
* **搜索引擎自动补全**
* **拼写检查**
* **前缀匹配统计（如 LeetCode 208）**
* **敏感词过滤**

---

### Python实现

```python
class TrieNode:
    def __init__(self):
        self.children = {}  # 存储子节点，key 是字符
        self.is_end = False  # 标记是否是一个完整单词的结尾

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """插入单词"""
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()  # 若不存在则创建新节点
            node = node.children[char]
        node.is_end = True  # 标记为单词结束

    def search(self, word):
        """查找完整单词是否存在"""
        node = self._find_node(word)
        return node is not None and node.is_end

    def startsWith(self, prefix):
        """是否存在以 prefix 为前缀的单词"""
        return self._find_node(prefix) is not None

    def _find_node(self, prefix):
        """辅助方法，查找前缀末尾的节点"""
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        return node
```
---

### Java实现

```java
// 利用简单的关联数组实现Trie树
class TrieNode {
    TrieNode[] links = new TrieNode[26];
    boolean isleaf  = false;
}

class Trie {

    TrieNode root;

    Trie() {
        root = new TrieNode();
    }

    // 实现插入方法
    public void insert(String word) {
        insert(word, root);
    }

    public void insert(String word, TrieNode node) {
        if (node == null) {
            return;
        }
        if (word.length() == 0) {
            node.isleaf = true;
            return;
        }
        int index = word.charAt(0) - 'a';
        if (node.links[index] == null) {
            node.links[index] = new TrieNode();
        }
        insert(word.substring(1), node.links[index]);
    }

    // 实现 查找 功能
    public boolean search(String word) {
        return search(word, root);
    }

    private boolean search(String word, TrieNode node) {
        if (node == null) {
            return false;
        }
        if (word.length() == 0) return node.isleaf;
        int index = word.charAt(0) - 'a';
        return search(word.substring(1), node.links[index]);
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        return startsWith(prefix, root);
    }

    private boolean startsWith(String prefix, TrieNode node) {
        if (node == null) {
            return false;
        }
        if (prefix.length() == 0) return true;
        int index = prefix.charAt(0) - 'a';
        return startsWith(prefix.substring(1), node.links[index]);
    }
}
```

### 经典例题
- [键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)
- [实现一个 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

---
