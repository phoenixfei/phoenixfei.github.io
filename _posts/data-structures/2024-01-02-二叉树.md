---
title: "掌握二叉树：结构、遍历与递归艺术"
categories: [data-structures]
tags: [tree]

math: true
layout: post
---

“二叉树” 是数据结构中非常核心的内容，常见于各种算法题，特别是在递归、动态规划、图算法等领域有广泛应用。

---

## 树的基本概念

树（Tree）是一种常见的数据结构，用来表示 **层次关系（hierarchy）**。

**树的定义**：

树是由若干节点（Node）组成的集合，其中：
* 有一个特殊的节点称为 **根（Root）**。
* 除根节点外的其他节点都有且只有一个 **父节点（Parent）**。
* 每个节点可以有零个或多个 **子节点（Child）**。
* 没有子节点的节点称为 **叶子节点（Leaf）**。

**树的常用术语**：
* **深度（Depth）**：从根到该节点的路径长度。
* **高度（Height）**：从该节点到叶子的最长路径长度。
* **度（Degree）**：一个节点的子节点个数。
* **子树（Subtree）**：某个节点和它的所有后代组成的树。

---

### 二叉树

二叉树（Binary Tree）是最常见的一类树。

* **定义**：二叉树是指 **每个节点最多有两个子节点** 的树，分别称为 **左子树** 和 **右子树**。
* 特点：左右子树有顺序之分，不能随意调换。

**二叉树的几类特殊情况**

1. **满二叉树（Full Binary Tree）**
   每一层的节点数都达到最大值，即所有非叶子节点都有两个子节点。

2. **完全二叉树（Complete Binary Tree）**

   * 除最后一层外，其他层都是满的；
   * 最后一层的节点都靠左连续排列。
   * 常见于 **堆（Heap）** 的实现。

3. **二叉搜索树（BST, Binary Search Tree）**

   * 左子树所有节点值 < 根节点值；
   * 右子树所有节点值 > 根节点值；
   * 中序遍历结果是升序序列。

4. **平衡二叉树（Balanced Binary Tree）**

   * 任意节点的左右子树高度差 ≤ 1；
   * 常见实现：AVL 树、红黑树（Red-Black Tree）。

---

**二叉树的存储方式**

1. **链式存储**（常见）
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

2. **顺序存储**（完全二叉树可用数组表示）
* 下标从 1 开始：
  * 左子节点下标 = 2\*i
  * 右子节点下标 = 2\*i + 1
* 常见于堆（Heap）的实现。

---

### 二叉查找树

Binary Search Tree，也称为**[二叉搜索树](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9)**，是指一棵空树或者具有以下性质的树：

1. 若任意节点的左子树不空，则左子树所有节点的值小于它根节点的值；
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点。

二叉查找树**中序遍历**结果**有序**。

---

### 红黑树

[红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)，Red-black Tree，是一种自平衡二叉查找树，典型的用途是**关联数组**。

在二叉查找树强制的一般要求外，对于任何有效的红黑树，我们增加了如下额外的要求：
* 节点是红色或黑色。
* 根是黑色。
* 所有叶子都是黑色（叶子是NIL节点）。
* 每个红色节点必须有两个黑色的子节点。
  * 或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。
  * 或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。
  * 或者说红色节点的父节点和子节点均是黑色的。
* 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

![1920px-Red-black_tree_example.svg]({{ site.baseurl }}/assets/images/1920px-Red-black_tree_example.svg.png)

---

## 访问/遍历

### 层次遍历

层序遍历就是按照 从上到下、从左到右 的顺序，一层一层访问二叉树的节点。 它是 广度优先搜索 (BFS) 在二叉树上的应用。

- [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if root is None:
            return []
        ans = []
        q = deque([root])
        while q:
            vals = []
            for _ in range(len(q)):
                node = q.popleft()
                vals.append(node.val)
                if node.left:  q.append(node.left)
                if node.right: q.append(node.right)
            ans.append(vals)
        return ans
```

---

### 先/中/后序遍历

- 先序(根左右)：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树
- 中序(左根右)：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树
- 后序(左右根)：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值

> Tips：无论先序、中序、后序，对节点的考查（不一定输出）顺序都是一样的。

![2405011-5f5b0b136713f744]({{ site.baseurl }}/assets/images/2405011-5f5b0b136713f744-1558060683243.jpg)

---

**通过递归实现先/中/后序遍历**：
代码模板一致，仅节点处理的顺序不同

**通过迭代实现先/中/后序遍历**：
因为需要在遍历完节点的左子树时接着遍历节点的右子树，为了能找到该节点，需要使用**栈**来进行暂存。

---

**先序遍历**
- [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

递归实现
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            ans.append(node.val)
            dfs(node.left)
            dfs(node.right)
        dfs(root)
        return ans
```

迭代实现
```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        cur = root
        stack = []
        while cur or stack:
            while cur:
                stack.append(cur)
                ans.append(cur.val)
                cur = cur.left
            cur = stack.pop().right
        return ans
```

---

**中序遍历**
- [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

递归实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            dfs(node.left)
            ans.append(node.val)
            dfs(node.right)
        dfs(root)
        return ans
```

迭代实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = []
        cur = root
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack.pop()
            ans.append(cur.val)
            cur = cur.right
        return ans
```

---

**后序遍历**
- [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

递归实现
```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        def dfs(node):
            if node is None:
                return
            dfs(node.left)
            dfs(node.right)
            ans.append(node.val)
        dfs(root)
        return ans
```

迭代实现

后序遍历与先序、中序遍历不一样之处在于：**后序遍历在输出当前节点值时，需要考虑其左右之树是否已经遍历完成。**

> 所以，需要设置一个lastVisit游标。当lastVisit等于当前节点的右子树，表示该节点的左右子树都已经遍历完成，才可以输出当前节点值。

![2405011-a3b88566f13549af]({{ site.baseurl }}/assets/images/2405011-a3b88566f13549af.jpg)

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans = []
        stack = []
        cur = root
        last_vst = None
        while cur or stack:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack[-1]
            if cur.right is None or cur.right == last_vst:
                ans.append(cur.val)
                cur = stack.pop()
                last_vst = cur
                cur = None
            else:
                cur = cur.right
        return ans
```

---

### 经典例题
- [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
- [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)
- [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

---

## 递归/分治

### 方法介绍

树是**天然的递归结构**：每个节点的子树本身就是一棵树，因此大多数与树相关的问题，都可以通过 **递归 / 分治** 来解决。

**递归与分治的区别：**
* **递归 (Recursion)**：函数调用自身，解决规模更小的子问题。二叉树的遍历（前序、中序、后序）就是典型递归。
* **分治 (Divide and Conquer)**：将一个问题拆解成 **若干独立子问题**，分别求解，再合并结果。

换句话说：**递归是实现手段，分治是算法思想。**

> 在二叉树中，通常就是 **把整棵树问题拆成左子树 + 右子树**。

---

**树的递归遍历**就是“递归与分治”思想的最基本的应用。

以中序遍历为例：递归结构刚好契合“左子树—根—右子树”的定义。

```python
def inorder(root: TreeNode):
    if root is None:
        return
    inorder(root.left)       # 左
    print(root.val, end=" ") # 根
    inorder(root.right)      # 右
```

**典型流程：**

1. **拆解问题**：当前节点要做什么？左右子树分别要做什么？
2. **递归求解子问题**：递归调用左右子树。
3. **合并结果**：把左右子树结果与根节点结合。

**具体步骤：**

1. **定义递归函数**：明确函数返回值表示什么（高度？节点数？是否满足某条件？）。
2. **递归出口**：通常是 `null` 节点，返回一个「边界值」。
3. **递归调用**：分别递归求解左右子树。
4. **合并结果**：使用子树结果，推导当前节点的答案。

---

例如：**求树的高度**

* 定义：`f(node)` = 以该节点为根的子树高度
* 出口：若 `node == null`，高度为 0
* 分解：左子树高度 = `f(node.left)`
* 分解：右子树高度 = `f(node.right)`
* 合并：`f(node) = max(左, 右) + 1`

核心公式：

$$
f(root) = \text{combine}(f(root.left), f(root.right))
$$

几乎所有树的递归问题都能写成这种形式。

---

### 例题讲解

#### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```text
给定一个二叉树 root ，返回其最大深度。
二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。
```

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root is None: return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

* **分解**：树的深度 = 左子树深度、右子树深度的最大值 + 1。
* **合并**：取最大值。

---

#### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

```text
给定一个二叉树，判断它是否是平衡二叉树。
```

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def get_height(node: Optional[TreeNode]) -> int:
            if node is None:
                return 0
            left_h = get_height(node.left)
            right_h = get_height(node.right)
            if left_h == -1 or right_h == -1 or abs(left_h - right_h) > 1:
                return -1
            return max(left_h, right_h) + 1
        return get_height(root) != -1
```

* **分解**：判断一棵树是否平衡，需要左右子树都平衡，且高度差 ≤ 1。
* **合并**：用高度作为子问题结果，结合左右子树的判断。

---

### 经典例题

- [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
- [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)
- [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-treea)

**二叉树的构造：**
通常是根据遍历结果进行递归/分治。

- [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)
- [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
- [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

---

## 回溯/路径搜索

### 方法介绍

二叉树的「回溯 / 路径搜索」问题，通常都围绕 **“从根到叶的一条路径”** 展开。

**典型形式：**

* 找到所有路径
* 找到满足条件的路径（如和为某个数）
* 找到最长 / 最短路径
* 判断是否存在路径

**回溯的关键点**：

1. **选择**：进入某个子节点。
2. **递归**：继续向下探索。
3. **撤销选择**：返回上一层时，要把路径恢复原状。

> 这与图的回溯/DFS类似，但树没有环，因此不需要 visited 标记。

---

**伪代码形式：**

```python
def dfs(node, path):
    if not node:
        return

    # 做选择（进入节点）
    path.append(node.val)

    # 判断是否到达叶子（路径结束条件）
    if not node.left and not node.right:
        # 此时 path 就是一条完整路径
        process(path)

    # 递归子树
    dfs(node.left, path)
    dfs(node.right, path)

    # 撤销选择（回溯）
    path.pop()
```

> 关键点：**进入节点时加入，离开节点时移除**。这就是「回溯」思想。

---

**应用场景：**

1. 枚举所有路径

   * 不需要额外约束，直接收集所有根到叶的路径。
   * 用于打印、统计路径数。

2. 路径和问题

   * 限定路径的节点值之和是否等于目标值。
   * 典型思路：递归时传递「剩余和」或在回溯时累加求和。

3. 路径存在性判断

   * 只需找到一条符合条件的路径即可。
   * 可以在递归中 **提前返回**，不必遍历所有路径。

4. 最长/最短路径

   * 在回溯时，维护一个全局变量存最大/最小路径长度。
   * 或者在叶子节点时更新答案。

---

### 例题讲解

#### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

```text
给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
叶子节点 是指没有子节点的节点。
```

**思路要点**：
* `path` 维护一条从根到当前节点的路径。
* 每次进入节点 → `path.append()`
* 递归子树 → 搜索继续
* 回溯 → `path.pop()`

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        ans = []
        path = []
        def dfs(node):
            if node is None:
                return
            path.append(str(node.val))
            if node.left is None and node.right is None:
                ans.append("->".join(path))
            dfs(node.left)
            dfs(node.right)
            path.pop()
        dfs(root)
        return ans
```

---

#### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

```text
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
叶子节点 是指没有子节点的节点。
```

**思路要点**：
* `left` 记录剩余和。
* 到叶子时判断 `left == 0`。
* 回溯清理路径，保证路径状态不污染。

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        ans = []
        path = []
        def dfs(node, left):
            if node is None:
                return 
            path.append(node.val)
            left -= node.val
            if node.left is None and node.right is None and left == 0:
                ans.append(path.copy())
            dfs(node.left, left)
            dfs(node.right, left)
            path.pop()
        dfs(root, targetSum)
        return ans
```

---

### 经典例题
- [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

---

## 树形DP

### 方法介绍

树形 DP 是一种 **在树结构上进行动态规划** 的方法。

* 树的递归特性天然适合「自底向上」地做状态转移。
* 本质是：**在子树上求解子问题，再合并结果得到父节点的解**。

公式化描述：

$$
f(u) = \text{Combine}\{ f(v) \mid v \in children(u) \}
$$

---

**树形 DP 的核心思想：**
树形 DP 其实是 **分治 + 动态规划** 的结合。

1. **分治**：树可以递归拆分为子树。
2. **动态规划**：对子问题结果进行缓存，避免重复计算。

**树形 DP 的一般套路：**

1. 明确 **状态定义**（在某个节点、某种选择下的最优解）。
2. 明确 **状态转移**（父节点如何依赖子节点的结果）。
3. 通过 DFS 后序遍历来计算（先算子树，后算父节点）。

> 关键在于 **后序遍历**（因为要等左右子树算完，才能算父节点）。

---

**常见的树形 DP 模式1：子树信息统计类**

* 问题特点：
  父节点的答案依赖于子节点的统计结果。每次递归只需合并子树结果即可。

* 常见问题：

  * 统计子树大小
  * 计算树的高度 / 深度
  * 子树权值和

* 解法思路：

  1. DFS 遍历整棵树。
  2. 在回溯阶段，利用子节点的结果更新父节点的值。
  3. 最终根节点存储整个树的答案。

* 示例代码（树高度）：

```python
def tree_height(root):
    if not root:
        return 0
    left = tree_height(root.left)
    right = tree_height(root.right)
    return max(left, right) + 1
```

---

**常见的树形 DP 模式2：树上的路径 / 直径问题**

* 问题特点：
  父节点答案不仅依赖子节点，还可能需要 拼接多个子树结果。

* 常见问题：

  * 树的直径（两点之间的最长路径）
  * 二叉树最大路径和

* 解法思路：

  1. 在 DFS 过程中，返回「从该节点向下的最长路径长度」。
  2. 同时用两个子树的路径拼接，尝试更新全局最大值。
  3. 递归返回时，父节点取单边最长路径。

* 示例代码（树直径）：

```python
diameter = 0

def dfs(u):
    global diameter
    if not u:
        return 0
    left = dfs(u.left)
    right = dfs(u.right)
    diameter = max(diameter, left + right)  # 更新直径
    return max(left, right) + 1
```

---

**常见的树形 DP 模式3：节点选或不选类（树上独立集）**

* 问题特点：
  涉及「选 / 不选」状态，父节点的选择影响子节点的选择。

* 常见问题：

  * 树形打家劫舍（LeetCode 337）
  * 最大独立集（图论经典问题）

* 解法思路：

  1. 定义状态：

     * \$f(u,0)\$：不选 \$u\$ 的最优解
     * \$f(u,1)\$：选 \$u\$ 的最优解
  2. 转移：

     * 如果选 \$u\$，则子节点不能选。
     * 如果不选 \$u\$，子节点可自由选择。
  3. 递归处理所有子树。

* 示例代码（打家劫舍 III）：

```python
def dfs(u):
    if not u:
        return (0, 0)  # (不选u, 选u)
    left = dfs(u.left)
    right = dfs(u.right)

    not_pick = max(left) + max(right)   # u不选，孩子自由
    pick = u.val + left[0] + right[0]   # u选，孩子不能选

    return (not_pick, pick)

res = max(dfs(root))
```

---

**常见的树形 DP 模式4：树上背包类**

* 问题特点：
  树的结构与背包问题结合，父节点容量固定，需要对子树方案进行「合并」。

* 常见问题：

  * 树形背包问题（选子树中的若干节点，容量限制）
  * 树上分组背包

* 解法思路：

  1. 用 DFS 遍历子树。
  2. 每个子树返回一个「容量 → 最大价值」的数组。
  3. 父节点合并子节点的 DP 数组（类似背包的卷积）。
  4. 注意需要从大到小循环，以避免重复选择。

* 示例代码（简化版树上背包）：

```python
def dfs(u, capacity):
    dp = [0] * (capacity + 1)  # dp[i] = 最大价值
    for v in u.children:
        child_dp = dfs(v, capacity)
        for c in range(capacity, -1, -1):     # 当前容量
            for k in range(c+1):              # 分配给子树的容量
                dp[c] = max(dp[c], dp[c-k] + child_dp[k])
    return dp
```

---

树形 DP 与其他方法的区别

* **递归 / 分治**：关注子树的计算，但不强调「状态定义与转移」，更多是直接合并答案。
* **回溯 / 路径搜索**：关注的是「路径枚举」和「搜索剪枝」，而不是「最优解」。
* **树形 DP**：核心在于 **定义状态** + **子问题转移**，目标是求解「全局最优」。

一句话总结：

* **回溯**：找路径（枚举 / 存在性）。
* **递归分治**：求子树性质（高度 / 节点数）。
* **树形 DP**：定义状态，在树上做「最优子结构」合并。

---

### 例题讲解

#### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

```text
给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。
```

* 定义 `depth(u)` = 节点 `u` 的最大深度。
* 每次计算直径 = `depth(left) + depth(right)`。
* 全局维护最大值。

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        ans = 0
        def dfs(node: Optional[TreeNode]) -> int:
            if node is None:
                return -1  # 对于叶子来说，链长就是 -1+1=0
            l_len = dfs(node.left) + 1  # 左子树最大链长+1
            r_len = dfs(node.right) + 1  # 右子树最大链长+1
            nonlocal ans
            ans = max(ans, l_len + r_len)  # 两条链拼成路径
            return max(l_len, r_len)  # 当前子树最大链长
        dfs(root)
        return ans
```

---

#### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

```text
二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。
```

定义 `f(u)` = 以 `u` 为根的子树，**从 `u` 出发的最大路径和**。

转移方程：
```
f(u) = max(0, f(left)) + max(0, f(right)) + u.val
```

实现细节：
- 如果子树贡献为负，就不要它
- 全局维护最大值

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        ans = -inf
        def dfs(node: Optional[TreeNode]) -> int:
            if node is None:
                return 0  # 没有节点，和为 0
            l_val = dfs(node.left)  # 左子树最大链和
            r_val = dfs(node.right)  # 右子树最大链和
            nonlocal ans
            ans = max(ans, l_val + r_val + node.val)  # 两条链拼成路径
            return max(max(l_val, r_val) + node.val, 0)  # 当前子树最大链和（注意这里和 0 取最大值了）
        dfs(root)
        return ans
```

---

### 经典例题
- [2246. 相邻字符不同的最长路径](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/)
- [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)
- [1617. 统计子树中城市之间最大距离](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/)
- [2539. 最大价值和与最小价值和的差值](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/)

---
