---
title: "树状数组：前缀和与区间更新的利器"
categories: [data-structures]
tags: [array, tree]

math: true
layout: post
---

树状数组是一个一维数组（通常称为 `tree` 或 `bit`），它本质上是对原始数组的前缀和进行“分块压缩”保存，使得我们可以在 `O(log n)` 的时间内：

* **查询某个位置前的所有数的和**（前缀和）
* **快速更新某个位置的值**

它是 **数组的一种增强结构**，可以看作是用空间换时间的“前缀和优化方案”。

---

### 设计思路

**为什么叫“树状”？**

虽然结构是数组，它的“跳跃规则”就像是树：
* 每个位置 i 代表的是一个区间的和（区间大小 = `lowbit(i)`）
* 利用 `lowbit(x)` 快速跳转到父区间或子区间，和树遍历类似

`lowbit(x)` 是什么？
```python
def lowbit(x):
    return x & -x
```

功能：得到 x 的二进制中最右侧的 `1` 所代表的数值
例如：

| x  | 二进制  | lowbit(x) |
| -- | ---- | --------- |
| 6  | 110  | 2         |
| 12 | 1100 | 4         |
| 8  | 1000 | 8         |

---

**举个例子：构建 BIT 结构**

设原始数组：`arr = [0, 3, 2, -1, 6, 5, 4, -3]`（从下标 1 开始）

构建 BIT 结构（只记录区间和）：

| i | lowbit(i) | 管辖的元素         | tree\[i] 存什么            |
| - | --------- | ------------- | ----------------------- |
| 1 | 1         | \[1]          | arr\[1]                 |
| 2 | 2         | \[1, 2]       | arr\[1] + arr\[2]       |
| 3 | 1         | \[3]          | arr\[3]                 |
| 4 | 4         | \[1, 2, 3, 4] | arr\[1]+...+arr\[4]     |
| 5 | 1         | \[5]          | arr\[5]                 |
| 6 | 2         | \[5, 6]       | arr\[5] + arr\[6]       |
| 7 | 1         | \[7]          | arr\[7]                 |
| 8 | 8         | \[1..8]       | arr\[1] + ... + arr\[8] |

每个节点代表一个前缀块的和，通过 `lowbit(i)` 快速跳转。

---

树状数组擅长处理以下类型问题：

| 类型              | 举例                          |
| --------------- | --------------------------- |
| **前缀和 / 区间和查询** | 查询 `[1..r]` 或 `[l..r]` 区间的和 |
| **频率统计 / 出现次数** | 出现多少个小于等于 `x` 的数            |
| **逆序对计数**       | 比某数小的元素有多少个                 |
| **动态第 K 小**     | 使用 BIT 二分查找第 K 大/小          |

---

操作时间复杂度：

| 操作    | 时间复杂度      |
| ----- | ---------- |
| 单点修改  | `O(log n)` |
| 前缀和查询 | `O(log n)` |

相比于前缀和数组 `O(1)` 查询但 `O(n)` 更新的缺陷，树状数组做到了更新与查询都快。

---

### Python实现
**使用 1-based 下标**
```python
class FenwickTree:
    def __init__(self, size):
        # 树状数组使用 1-based index，因此 size = n 时，tree 大小 = n+1
        self.n = size
        self.tree = [0] * (self.n + 1)

    def lowbit(self, x):
        # 获取最低有效位，例：6 -> 2（0b110 -> 0b10）
        return x & -x

    def update(self, index, delta):
        """将 arr[index] += delta"""
        while index <= self.n:
            self.tree[index] += delta
            index += self.lowbit(index)

    def query(self, index):
        """返回 arr[1] + arr[2] + ... + arr[index] 的前缀和"""
        result = 0
        while index > 0:
            result += self.tree[index]
            index -= self.lowbit(index)
        return result

    def range_query(self, left, right):
        """返回 arr[left] + ... + arr[right] 的区间和"""
        return self.query(right) - self.query(left - 1)
```

**使用示例：**
```python
arr = [2, 3, 5, 1, 4]
n = len(arr)
fenw = FenwickTree(n)

# 外部查询或更新函数时，索引都必须加1处理

# 挨个元素更新，即初始化
for i, val in enumerate(arr):
    fenw.update(i + 1, val)  # 由于内部是1-based实现

# 查询原数组闭区间[0,2]
print(fenw.query(3))  # 输出 10
# 查询原数组闭区间[1,3]
print(fenw.range_query(2, 4))  # 输出 9

# 更新：把索引2位置元素更新为10（原来是5）
idx = 2
fenw.update(idx+1, 10 - arr[idx])

# 再查询一次，可知更新有效
print(fenw.query(3))  # 输出 15
print(fenw.range_query(2, 4))  # 输出 14
```

---
