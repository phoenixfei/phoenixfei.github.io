---
title: "Python集合操作技巧"
categories: [think-n-code]
tags: [programming]

math: true
layout: post
---

在 Python 编程和算法题中，`set`、`dict` 和 `Counter` 是高频且非常实用的三种数据结构。它们都基于 **哈希表** 实现，支持 O(1) 平均时间复杂度的查找，但各自的用途、特性和接口有所不同。

---

## 集合(set)

### 基本操作

**创建**
```python
s = set([1, 2, 3, 2])  # 重复元素会被自动去掉
print(s)  # 输出: {1, 2, 3}
print(len(s)) # 输出: 3   

s2 = {4, 5, 6}  # 使用花括号直接定义集合
```

> 注意：空集合只能用 `set()` 创建，不能写成 `{}`，后者是空字典。

---

**集合推导式：**类似列表推导
```python
squares = {x**2 for x in range(5)}  # {0, 1, 4, 9, 16}
```

---

**添加和删除元素**
```python
s.add(4)         # 添加元素
s.remove(2)      # 删除元素，不存在会报错
s.discard(2)     # 删除元素，不存在不会报错
s.clear()        # 清空集合
```

---

**判断元素是否存在**
```python
fruits = {"apple", "banana", "cherry"}

# 判断元素是否在集合中
print("apple" in fruits)   # True
print("orange" in fruits)  # False
```

---

**集合运算**：集合可以进行数学集合操作
```python
a = {1, 2, 3}
b = {3, 4, 5}

print(a | b)   # 并集 {1, 2, 3, 4, 5}
print(a & b)   # 交集 {3}
print(a - b)   # 差集 {1, 2}
print(a ^ b)   # 对称差集（异或）{1, 2, 4, 5}
```

---

**判断子集**
```python
a = {1, 2}
b = {1, 2, 3}

print(a.issubset(b))  # True
print(b.issubset(a))  # False
```

---

**判断超集**
```python
a = {1, 2, 3}
b = {1, 2}

print(a.issuperset(b))  # True
print(b.issuperset(a))  # False
```

---

**判断交集**
```python
a = {1, 2}
b = {3, 4}
c = {2, 3}

print(a.isdisjoint(b))  # True   → 没有公共元素
print(a.isdisjoint(c))  # False  → 公共元素是 2
```

---

## 字典(dict)

字典是 **Python 内置的映射类型**，以 **键值对（key-value）** 的形式存储数据：

* **key**：必须是可哈希的（不可变类型，如字符串、数字、元组），且唯一
* **value**：可以是任意类型，可以重复
* **顺序**：Python 3.7+ 开始，`dict` 会保留插入顺序（但不是排序）
* **底层**：基于哈希表实现，查找、插入、删除的平均时间复杂度为 **O(1)**

```python
d = {'name': 'Alice', 'age': 25}
```

---

### 基本操作

**创建字典**
```python
# 直接定义
d1 = {'a': 1, 'b': 2}

# 使用 dict() 函数
d2 = dict(a=1, b=2)

# 从列表/元组创建
d3 = dict([('a', 1), ('b', 2)])

# 从两个列表/元组配对创建
keys = ['a', 'b', 'c']
values = [1, 2, 3]
d4 = dict(zip(keys, values))
```

---

**从键生成字典**
```python
new_d = dict.fromkeys(['x', 'y', 'z'], 0)
# {'x': 0, 'y': 0, 'z': 0}
```

---

**字典推导式**
```python
# 生成平方字典
squares = {x: x**2 for x in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 过滤
even_squares = {x: x**2 for x in range(5) if x % 2 == 0}
# {0: 0, 2: 4, 4: 16}
```

---

**访问与修改**
```python
d = {'name': 'Alice', 'age': 25}

# 访问
print(d['name'])          # 直接访问，不存在会报 KeyError
print(d.get('gender'))    # 返回 None
print(d.get('gender', '未知'))  # 返回默认值

# 修改或新增
d['age'] = 26
d['city'] = 'Beijing'

# 删除
del d['city']
d.pop('age', None)   # 第二个参数是默认值，不存在时不会报错
d.clear()            # 清空
```

---

**查看元素**
```python
d = {'a': 1, 'b': 2, 'c': 3}

print(d.keys())      # dict_keys(['a', 'b', 'c'])
print(d.values())    # dict_values([1, 2, 3])
print(d.items())     # dict_items([('a', 1), ('b', 2), ('c', 3)])
```

---

**遍历**
```python
for k in d:                  # 遍历键
    print(k)

for k, v in d.items():        # 遍历键值对
    print(k, v)

for v in d.values():          # 遍历值
    print(v)
```

---

### defaultdict用法

在 Python 的 `collections` 模块中，`defaultdict` 允许你为字典的默认值指定一个工厂函数。当你访问一个不存在的键时，它会自动创建一个默认值。

如果你想指定默认值为 `int`，这相当于：

```python
from collections import defaultdict

d = defaultdict(int)
```
此时，每当你访问一个不存在的键时，它会自动赋值为 `0`（因为 `int()` 返回 0）。

你还可以替换成其他类型的工厂函数，比如：
* `defaultdict(list)` → 默认值为 `[]`
* `defaultdict(set)` → 默认值为 `set()`

**指定默认值的方式：**重新定义工厂函数。
```python
from collections import defaultdict

d1 = defaultdict(lambda: float('inf'))

d2 = defaultdict(lambda: [0])
```

---

### OrderedDict用法

`collections.OrderedDict` 在 Python 3.7+ 虽然**不再是“保序字典”的唯一选择**（因为普通 `dict` 也保留插入顺序），但它仍有几个**普通 dict 没有的功能**。

**主要作用**

1. **保留插入顺序（3.6 之前必须用它）**

   * 在 Python 3.6 以前，普通 `dict` 不保证遍历顺序，`OrderedDict` 是唯一能保证顺序的选择。
   * Python 3.7+ 中，这点变成了普通 `dict` 的默认行为，但它的其他功能仍然有用。

2. **提供顺序操作方法**

   * `move_to_end(key, last=True)`
     把某个键移动到末尾或开头，方便实现 LRU、MRU 等缓存结构。

     ```python
     from collections import OrderedDict
     od = OrderedDict(a=1, b=2, c=3)
     od.move_to_end('a')        # {'b': 2, 'c': 3, 'a': 1}
     od.move_to_end('b', last=False)  # {'b': 2, 'c': 3, 'a': 1}
     ```

3. **提供删除头部、尾部元素的操作方法**

   * **`popitem(last=True)`**：弹出并返回一个 `(key, value)`。
   
   **参数**：
     * `last=True`（默认） → 弹出末尾的元素（LIFO）
     * `last=False` → 弹出开头的元素（FIFO）
   
   **用途**：实现 **LRU 缓存**（删除末尾）或 **FIFO 缓存**（删除开头）

    ```python
    od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
    print(od.popitem(last=False))  # ('a', 1)
    print(od)  # OrderedDict([('b', 2), ('c', 3)])
    ```

4. **顺序比较（3.7 以前有区别）**

   * 在旧版本中，两个 `OrderedDict` 比较时，不仅比较键值，还比较顺序。

     ```python
     from collections import OrderedDict
     od1 = OrderedDict([('a', 1), ('b', 2)])
     od2 = OrderedDict([('b', 2), ('a', 1)])
     print(od1 == od2)  # False（顺序不同）
     ```
     
   * 普通 `dict` 在 3.7+ 中也是忽略顺序进行比较，但 `OrderedDict` 依旧是顺序敏感的。
     ```python
     d1 = {'a': 1, 'b': 2}
     d2 = {'b': 2, 'a': 1}
     
     print(d1 == d2)  # True，顺序无关
     ```

4. **可作为队列型映射结构**

   * 因为能在头尾插入/删除键值对，所以它常用来实现：

     * [**LRU 缓存**（最近最少使用）](/posts/字典树_LRU_并查集/#lru)
     * **FIFO 队列**（先进先出映射）

---

**VS 普通 dict**

| 特性              | dict (3.7+) | OrderedDict |
| --------------- | ----------- | ----------- |
| 保留插入顺序          | ✅           | ✅           |
| `move_to_end()` | ❌           | ✅           |
| 顺序敏感比较          | ❌           | ✅           |
| LRU/FIFO 支持     | ❌（需手写）      | ✅（方便）       |
| Python 3.6- 保序  | ❌           | ✅           |

---

## Counter

在数据统计、文本分析、日志处理等场景中，我们经常需要**快速统计元素的出现次数**。
如果用普通字典，需要写一堆 `if key in dict` 的判断，很啰嗦。
Python 标准库的 `collections.Counter` 专门为这种需求设计，让统计变得简单而高效。

`Counter` 是 Python `collections` 模块中的一个**字典子类**，专门用于 **计数可哈希对象**。

* **key**：元素
* **value**：该元素出现的次数
* 默认值为 `0`，不存在的键访问不会报错

```python
from collections import Counter

c = Counter(['a', 'b', 'a', 'c', 'b', 'a'])
print(c)  # Counter({'a': 3, 'b': 2, 'c': 1})
```

---

### 基本操作

**创建 `Counter`**
```python
from collections import Counter

# 从可迭代对象（列表、字符串等）
c1 = Counter('banana')
# Counter({'a': 3, 'n': 2, 'b': 1})

# 从字典
c2 = Counter({'a': 3, 'b': 2})

# 从关键字参数
c3 = Counter(a=3, b=2, c=1)
```

---

**访问和更新**
```python
c = Counter('banana')
print(c['a'])   # 3
print(c['x'])   # 0（不存在不会报错）

# 更新计数
c.update('band')      # 叠加计数
print(c)              # Counter({'a': 4, 'n': 3, 'b': 2, 'd': 1})

# 减少计数
c.subtract('ana')     # 对应计数减去出现次数
print(c)
```

---

**获取最常见元素**
```python
c = Counter('banana')
print(c.most_common(2))
# [('a', 3), ('n', 2)]
```

---

**元素展开**
```python
c = Counter('banana')
print(list(c.elements()))
# ['b', 'a', 'a', 'a', 'n', 'n']
```

---

**集合运算（多重集运算）：**
`Counter` 支持类似集合的交集、并集操作，但它是对计数取 **最小值 / 最大值**。
```python
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)

print(c1 & c2)  # 交集（计数取最小值）=> Counter({'a': 1, 'b': 1})
print(c1 | c2)  # 并集（计数取最大值）=> Counter({'a': 3, 'b': 2})
```

---

### VS 字典

| 特性     | 说明                             |                 |
| ------ | ------------------------------ | --------------- |
| 基于字典实现 | key 是元素，value 是计数              |                 |
| 访问不存在键 | 返回 0，不会报错                      |                 |
| 更新计数   | `update()` 增加，`subtract()` 减少  |                 |
| 排序     | `most_common(n)` 获取出现次数前 n 的元素 |                 |
| 集合运算   | 支持 `&`、\`                      | \`，基于计数的最小值/最大值 |

---

**Counter 相比普通计数字典的优势**

| 功能          | `Counter` 支持        | 普通 `dict` 需要自己实现         |
| ----------- | ------------------- | ------------------------ |
| 自动初始化计数为 0  | ✅                   | ❌（需用 `defaultdict(int)`） |
| 求元素频率       | ✅                   | ✅（但需写循环）                 |
| 获取最多的 n 个元素 | ✅ `.most_common(n)` | ❌（需排序）                   |
| 元素加减、交并操作   | ✅（支持算术运算）           | ❌（需自定义合并逻辑）              |
| 输出所有元素（按频率） | ✅ `.elements()`     | ❌（需构造）                   |
| 比较频率是否相等    | ✅（可直接 `==`）         | ❌（需写比较逻辑）                |

---

## sortedcontainers

`sortedcontainers` 是一个高性能的 **有序数据结构库**，它提供了 **自动保持有序** 的容器，和标准库里的 `list`, `dict`, `set` 类似，但区别是：

* 标准的 `list/dict/set` 插入后 **不保证有序**。
* `sortedcontainers` 会在插入、删除时自动维护排序。
* 内部实现基于 **分块数组（list of lists）**，避免了树结构的复杂性，同时性能优异。

| 结构   | 标准库                    | sortedcontainers 替代    |
| ---- | ---------------------- | ---------------------- |
| List | `list` (无序插入)          | `SortedList`（自动排序）     |
| Set  | `set` (无序)             | `SortedSet`（有序集合）      |
| Dict | `dict` (>=3.7插入顺序，非排序) | `SortedDict`（按 key 排序） |

安装：

```bash
pip install sortedcontainers
```

---

### SortedList

* 类似 Python 的 `list`，但始终保持有序。
* 支持二分查找、切片、快速查找区间。
* 复杂度：

  * 插入、删除：`O(log n)`
  * 索引、切片：`O(log n)`
  * 遍历：`O(n)`

示例：

```python
from sortedcontainers import SortedList

sl = SortedList([5, 1, 3])
print(sl)       # SortedList([1, 3, 5])

sl.add(2)
print(sl)       # SortedList([1, 2, 3, 5])

print(sl[0])    # 1
print(sl.bisect_left(3))  # 2 (3的位置)
```

---

### SortedSet

* 类似 `set`，但是有序且支持索引。
* 自动去重，并保持排序。
* 内部其实是 `SortedList` 的包装。

示例：

```python
from sortedcontainers import SortedSet

ss = SortedSet([5, 1, 3, 3])
print(ss)      # SortedSet([1, 3, 5])

ss.add(2)
print(ss)      # SortedSet([1, 2, 3, 5])

print(ss[1])   # 2
```

---

### SortedDict

* 类似 `dict`，但是 key 始终保持有序。
* 遍历时按照 key 的顺序。
* 类似 Java 的 `TreeMap`。

示例：

```python
from sortedcontainers import SortedDict

sd = SortedDict()
sd['b'] = 2
sd['a'] = 1
sd['c'] = 3

print(sd)          # SortedDict({'a': 1, 'b': 2, 'c': 3})
print(sd.keys())   # SortedKeysView(SortedDict({'a': 1, 'b': 2, 'c': 3}))
print(sd.peekitem(0))  # ('a', 1)
```

---

**应用场景**

* **有序数据维护**：实时保持排序（比 `sort()` 更高效）。
* **滑动窗口**：比如“中位数维护”问题（LeetCode 高频）。
* **区间查找**：快速二分查找。
* **LRU、排名系统**：可以根据顺序快速获取前 k 或后 k 个元素。

---

### 对比`SortedList`和`heapq`

**概括：**

* **`heapq`**：适合 **动态获取最小值/最大值**，比如优先队列、Dijkstra 算法、调度任务。
* **`SortedList`**：适合需要 **全局有序视图** 的情况，比如排名统计、二分查找、第 k 小元素、区间查询。

可以这么理解：

* 只关心“堆顶” → 用 **`heapq`**。
* 关心“全局顺序/任意排名” → 用 **`SortedList`**。

---

**共性**

* 都可以处理一组数字/元素。
* 都能支持插入和取出「某些有序位置」的元素。
* 都是 Python 里常见的“有序容器”解决方案。

---

**核心区别**

| 特性        | `SortedList` (`sortedcontainers`)   | `heapq`（最小堆）     |
| --------- | ----------------------------------- | ---------------- |
| 数据结构      | 动态数组 + 二分查找                         | 二叉堆（数组实现）        |
| 是否全局有序    | 全部保持有序                              | 只保证堆顶最小          |
| 插入复杂度     | O(log n) 插入 + O(n) 移动 → 均摊接近 O(log n) | O(log n)         |
| 删除最小值     | O(1)（取第一个元素）                        | O(log n)（heappop） |
| 删除任意元素    | O(log n + n)（二分查找 + 删除）             | 不支持，需要线性查找 O(n)  |
| 查找第 k 小元素 | O(1)（直接索引）                          | O(n log k) 或堆转排序 |
| 遍历        | 升序遍历 O(n)                           | 无序，只能 pop 出来才能得到排序结果 |
| 应用场景      | 需要全局有序视图（排名、区间查询、二分搜索）              | 只关心最小值/最大值（优先队列、调度） |

---

### 与Java集合框架的对应

Java 标准库（`java.util`）里已经有对应的“有序”集合：

| Python       | Java 对应 | 底层实现   | 是否有序     | 备注                  |
| ------------ |---------| ------ | -------- |---------------------|
| `SortedList` | 无       | 动态数组/堆 | 不自动排序    | Java 没有内置自动排序的 List |
| `SortedSet`  | `TreeSet` | 红黑树    | 始终有序     | 相当于 `SortedSet`     |
| `SortedDict` | `TreeMap` | 红黑树    | key 始终有序 | 相当于 `SortedDict`    |

---

**对比解析**

* **`SortedSet` vs `TreeSet`**

  * 两者都保证元素不重复 & 有序。
  * Python 用 **动态数组 + 二分** 实现，Java 用 **红黑树** 实现。
  * 复杂度：Python 插入 O(log n) + 移动 O(n)（整体接近 O(log n) 均摊），Java 插入严格 O(log n)。

* **`SortedDict` vs `TreeMap`**

  * 两者都保证 key 有序。
  * API 上也非常接近，比如 `firstKey()` / `lastKey()` / `subMap()`。

* **`SortedList`**

  * Java 没有直接对应的容器。
  * 但可以用 `ArrayList` + `Collections.binarySearch()` + 手动插入，或者用 `PriorityQueue`（堆，但只能保证堆顶有序，不是全局排序）。

---
