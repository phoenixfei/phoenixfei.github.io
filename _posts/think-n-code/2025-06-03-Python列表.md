---
title: "Python序列结构全解析"
categories: [think-n-code]
tags: [programming]

math: true
layout: post
---

Python 中的 列表（List） 是一种有序、可变、可重复的序列类型，用于存储一组项目。它是 Python 中最常用的数据结构之一，类似于数组，但功能更强大。

---

## 列表

### 创建列表

```python
# 空列表
a = []

# 含元素的列表
b = [1, 2, 3]

# 混合类型
c = [1, "hello", True, 3.14]

# 嵌套列表（二维）
d = [[1, 2], [3, 4]]
```

**列表推导式**
```python
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]
evens = [x for x in lst if x % 2 == 0]
```

### 基本操作技巧

**访问元素**
```python
lst = [10, 20, 30, 40]

print(lst[0])    # 10
print(lst[-1])   # 40（最后一个）
```

**修改元素**
```python
lst[1] = 200
print(lst)  # [10, 200, 30, 40]
```

**添加元素**
```python
lst.append(50)        # 末尾添加一个元素
lst.extend([60, 70])  # 扩展多个元素
lst.insert(1, 999)    # 在索引1插入一个元素
```

**删除元素**
```python
del lst[2]         # 删除索引为2的元素
lst.remove(999)    # 删除第一个值为999的元素
lst.pop()          # 删除最后一个元素并返回
lst.clear()        # 清空列表
```

**清空列表**
```python
lst = [1, 2, 3]
lst.clear()  # 清空列表
print(lst)  # []
```

**查询与判断**
```python
len(lst)           # 列表长度
20 in lst          # 是否包含某个元素（True/False）
lst.index(30)      # 查找元素索引
lst.count(20)      # 某元素出现次数
```

**排序与反转**
```python
lst.sort()         # 原地排序
lst.sort(reverse=True)  # 降序
lst.reverse()      # 反转列表
```

**遍历列表**
```python
for item in lst:
    print(item)

# 同时获取索引和值
for idx, val in enumerate(lst):
    print(idx, val)
```

**列表是可变对象（mutable）**
```python
a = [1, 2, 3]
b = a
b[0] = 100
print(a)  # [100, 2, 3]，b 修改会影响 a（指向同一对象）

# 正确复制方法
b = a[:]  # 或 list(a)、copy.copy(a)
```

---

### 切片操作

切片是 Python 中提取列表（或字符串、元组）一部分的强大方式，语法如下。
```python
list[start:stop:step]
```
* `start`: 起始索引（包含）
* `stop`: 结束索引（不包含）
* `step`: 步长（可选）

---

**基本示例**
```python
lst = [0, 1, 2, 3, 4, 5, 6]
print(lst[1:4])    # [1, 2, 3]  从索引1到3
print(lst[:3])     # [0, 1, 2]  从头到索引2
print(lst[3:])     # [3, 4, 5, 6] 从索引3到结尾
print(lst[:])      # [0, 1, 2, 3, 4, 5, 6] 整个列表的复制
```

**步长 step**
```python
lst = [0, 1, 2, 3, 4, 5, 6]
print(lst[::2])    # [0, 2, 4, 6] 每隔一个取一个（偶数索引）
print(lst[1::2])   # [1, 3, 5]    从索引1开始，每隔一个取（奇数索引）
```

**倒序切片（step 为负数）**
```python
lst = [0, 1, 2, 3, 4, 5]
print(lst[::-1])   # [5, 4, 3, 2, 1, 0]  反转列表
print(lst[4:1:-1]) # [4, 3, 2] 从索引4到2（不包含1），倒着来
```

**切片赋值（修改）**
```python
lst = [1, 2, 3, 4, 5]
lst[1:4] = [20, 30, 40]  # 替换索引1到3的值
print(lst)  # [1, 20, 30, 40, 5]
```

**删除切片元素**
```python
lst = [1, 2, 3, 4, 5]
del lst[1:4]  # 删除索引1到3
print(lst)  # [1, 5]
```

**切片复制列表（浅拷贝）**
```python
a = [1, 2, 3]
b = a[:]  # 浅复制
b[0] = 100
print(a)  # [1, 2, 3]
print(b)  # [100, 2, 3]
```

---

**索引支持负数**
```python
lst = [10, 20, 30, 40, 50]
print(lst[-3:-1])  # [30, 40] 倒数第3到倒数第2（不包含最后一个）
```

---

### 切片越界处理


在 Python 中进行**切片操作**（slicing）时，如果**右边界越界**（即超出了序列的实际长度），**不会抛出异常或错误**，而是会自动截取到序列的末尾。


```python
lst = [1, 2, 3, 4, 5]
# 右边界越界，最大索引为 4，但我们切片到索引 10
print(lst[1:10])  # 输出: [2, 3, 4, 5]

lst = [10, 20, 30, 40, 50]
# 左边界为负数（从末尾开始），右边界远超最大索引
print(lst[-3:100])  # 输出: [30, 40, 50]

lst = [10, 20, 30, 40, 50]
print(lst[-10:10])  # 输出: [10, 20, 30, 40, 50]
```

Python 在执行 `lst[start:end]` 时的行为如下：
* **start**：起始索引（包含该索引），如果为负数则从后往前计数。
* **end**：结束索引（**不包含**该索引），如果超过了列表长度，Python 会自动截断到列表末尾，不会报错。

直接访问超出范围的索引会报错，而切片操作则更“宽容”。
```python
print(lst[10])  # 会抛出 IndexError: list index out of range
```

---

### 删除列表元素

**按索引删除**

使用 `del` 或 `pop()`：
```python
# del 删除指定索引元素
lst = [1, 2, 3, 4, 5]
del lst[2]  # 删除索引为 2 的元素，即 3
print(lst)  # [1, 2, 4, 5]

# pop() 删除并返回指定索引元素（默认最后一个）
x = lst.pop(1)  # 删除索引 1 的元素，即 2
print(x)   # 2
print(lst) # [1, 4, 5]
```

> * `list.pop(i)` 可以删除任意索引元素，但开头/中间删除是 **O(n)**。
> * `list` 当队列用时（`pop(0)`）效率低。
> * 推荐用 **`collections.deque`** 实现队列，支持 **O(1)** 的 `append` 和 `popleft`。

---

**按切片删除**

```python
lst = [10, 20, 30, 40, 50]
del lst[1:3]  # 删除索引 1 和 2，即 20 和 30
print(lst)  # [10, 40, 50]

# 带步长删除
lst = [0, 1, 2, 3, 4, 5]
del lst[::2]  # 删除索引为 0, 2, 4 的元素
print(lst)  # [1, 3, 5]
```

**语法形式是：**
```python
del lst[start:stop]
```
* `start`：起始索引（包含）
* `stop`：结束索引（不包含）
* 可以带步长 `step`，例如 `del lst[::2]` 删除偶数索引项。


**注意事项**：
* `del` 是**原地修改**列表，不返回新列表。
* 尽量避免在遍历中对原列表使用 `del`，以免逻辑混乱。

---

**按值删除**

使用 `remove()`（只会删掉第一个匹配值）：
```python
lst = [1, 2, 3, 2, 4]
lst.remove(2)  # 删除第一个 2
print(lst)     # [1, 3, 2, 4]
```

---

**条件删除（保留不符合条件的）**

- 使用列表推导式创建一个新列表
```python
lst = [1, 2, 3, 4, 5, 6]
lst = [x for x in lst if x % 2 == 0]  # 只保留偶数
print(lst)  # [2, 4, 6]
```

- 或者使用 `filter()`
```python
lst = list(filter(lambda x: x % 2 == 0, lst))
```

- **注意**：
不要在遍历列表时直接删除元素，否则可能跳过部分元素。如下为错误示例。
```python
lst = [1, 2, 3, 4]
for x in lst:
    if x % 2 == 0:
        lst.remove(x)  # ⚠️ 错误写法
print(lst)  # [1, 3]，2 被删后，3 位置变化，跳过了
```

---

## 二维列表

### 创建二维列表

* 表达式 `[1] * 26` 的含义是：创建一个包含 26 个元素 的列表，每个元素都是整数 1。
* 如果你想构造二维列表或多个空子列表，正确的做法是用 `[[] for _ in range(n)]`。
* **不要用 `[[0]*3]*2`，因为那样会创建两个引用相同的子列表！**

```python
a = [[] * 26]
# 等价于 a = [[]]
b = [1] * 26
# [1, 1, 1, 1, ..., 1]
c = [[] for _ in range(26)]
# [[], [], [], ..., []]  # 共 26 个空列表，每个都是独立的对象
d = [[0] * 3 for _ in range(2)]
# [ [0, 0, 0], [0, 0, 0]]
```

在 Python 中，表达式 `[[0]*3]*2` 看似创建了一个 2 行 3 列的二维列表，但**它的行为容易引起误解**。
这个表达式，做了以下两件事：
1. `[0] * 3` 创建了一个列表 `[0, 0, 0]`
2. 然后用 `* 2` **重复这个同一个列表对象两次**，形成二维结构。

所以，最终结果看起来像这样：
```python
a = [
    [0, 0, 0],
    [0, 0, 0]
]
```

但注意：**两行其实指向的是同一个列表对象的引用！**
因此，引入的问题就是“共享引用”问题。

比如修改`a[0][0] = 99`，实际输出的结果却是：
```python
[
    [99, 0, 0],
    [99, 0, 0]
]
```
即使你的初衷是只改 `a[0][0]` 的值，但 `a[1][0]` 也被一起改了，因为它们是**同一个内层列表的两个引用**！

因此，正确的写法是使用**列表推导式**创建二维数组。

| 写法                     | 是否安全 | 说明           |
| ---------------------- | ---- | ------------ |
| `[[0]*3]*2`            | ❌ 否  | 多行共享同一个列表对象  |
| `[[0]*3 for _ in ...]` | ✅ 是  | 每行都是新列表，互不影响 |

---

### 转置二维数组（行变列）

`*grid`表示解包。 

>在 Python 中，解包（unpacking） 是一种将“可迭代对象”的元素拆解出来，并分别赋值给变量的语法。它非常常见且强大，可以用于元组、列表、字符串、字典等。
> 
> 基本解包：`x, y, z = (10, 20, 30)`
> 
> 使用*号进行扩展解包: `a, *b = [1, 2, 3, 4]` ，解包后，a为1; b为列表[2, 3, 4]。

解包后，用zip将行对应的列表“打包”在一起，再转成list形式，即可得到转置后的矩阵。
> Python 中的 zip() 是一个非常实用的内置函数，用于将多个可迭代对象“打包”在一起，生成一个由元组组成的迭代器，每个元组包含来自所有输入可迭代对象中对应位置的元素。

```python
grid = [
    [1, 2, 3],
    [4, 5, 6]
]
transposed = list(zip(*grid))
# [(1, 4), (2, 5), (3, 6)]
```

---

### 平铺二维数组

```python
flat = [x for row in grid for x in row]
# [1, 2, 3, 4, 5, 6]
```

**条件筛选 / 条件替换**
- 将所有奇数变为 0
```python
new_grid = [[x if x % 2 == 0 else 0 for x in row] for row in grid]
```

- 查找最大值及其位置
```python
max_val = max(max(row) for row in grid)
positions = [(i, j) for i, row in enumerate(grid) for j, val in enumerate(row) if val == max_val]
```

---

### 旋转二维数组

- 顺时针旋转 90 度
```python
rotated = [list(row)[::-1] for row in zip(*grid)]
```

- 逆时针旋转 90 度
```python
rotated = list(zip(*grid[::-1]))
```

---

### 二维数组中任意值是否满足某条件
```python
any_odd = any(x % 2 != 0 for row in grid for x in row)
all_positive = all(x > 0 for row in grid for x in row)
```

---

### 使用 enumerate 获取坐标和值
```python
for i, row in enumerate(grid):
    for j, val in enumerate(row):
        print(f"grid[{i}][{j}] = {val}")
```

---

### zip 配合多个二维数组
```python
a = [[1, 2], [3, 4]]
b = [[5, 6], [7, 8]]

summed = [[x + y for x, y in zip(row_a, row_b)] for row_a, row_b in zip(a, b)]
# [[6, 8], [10, 12]]
```

---

## deque

`deque`（double-ended queue，双端队列）是 Python **collections** 模块里的一个高性能容器，支持在队列 **两端** 以 **O(1)** 的时间复杂度进行插入和删除。

```python
from collections import deque
```

---

**初始化**

```python
from collections import deque

# 空队列
dq = deque()

# 带初始元素
dq = deque([1, 2, 3])

print(dq)  # deque([1, 2, 3])
```

---

### 基本操作

**添加元素**

```python
dq.append(4)        # 右边添加
dq.appendleft(0)    # 左边添加
print(dq)           # deque([0, 1, 2, 3, 4])
```

**删除元素**

```python
dq.pop()            # 删除右边，返回 4
dq.popleft()        # 删除左边，返回 0
print(dq)           # deque([1, 2, 3])
```

---

**批量扩展**

```python
dq.extend([4, 5])       # 相当于右边批量 append
dq.extendleft([-1, -2]) # 从左边批量 append（注意顺序反转）
print(dq)               # deque([-2, -1, 1, 2, 3, 4, 5])
```

**指定最大长度（自动丢弃旧数据 → 环形队列）**

```python
dq = deque(maxlen=3)
dq.extend([1, 2, 3])
dq.append(4)
print(dq)  # deque([2, 3, 4], maxlen=3)  # 1 被丢弃
```

---

**队列旋转（rotate）**

**关键点：**
* `rotate(k)` 就是 **循环位移**，不会丢数据。
* `k` 的正负号决定方向（右移/左移）。
* 如果 `|k|` 大于长度，会自动取模，相当于 `k % len(dq)`。

```python
dq = deque([1, 2, 3, 4, 5])
dq.rotate(2)   # 向右旋转 2 位
print(dq)      # deque([4, 5, 1, 2, 3])

dq.rotate(-1)  # 向左旋转 1 位
print(dq)      # deque([5, 1, 2, 3, 4])
```

---

**清空/反转**

```python
dq.clear()      # 清空队列
dq.reverse()    # 原地反转
```

---

### list vs deque 对比

| 功能/特性             | `list`                   | `deque` (`collections.deque`)            |
| ----------------- | ------------------------ | ---------------------------------------- |
| **数据结构类型**        | 动态数组（array-based）        | 双端链表（doubly-linked list, block-based 实现） |
| **尾部插入 `append`** | ✅ O(1)                   | ✅ O(1)                                   |
| **尾部删除 `pop()`**  | ✅ O(1)                   | ✅ O(1)                                   |
| **头部插入**          | ❌ O(n)（整体移动）             | ✅ O(1) `appendleft()`                    |
| **头部删除**          | ❌ O(n)（整体移动）             | ✅ O(1) `popleft()`                       |
| **随机访问/修改**       | ✅ O(1)                   | ❌ O(n)（需遍历）                              |
| **按索引删除**         | ✅ `pop(i)`，O(n)（末尾 O(1)） | ❌ 不支持（需旋转或转 list）                        |
| **删除指定值**         | ✅ `remove(value)`，O(n)   | ✅ `remove(value)`，O(n)                   |
| **扩展多个元素**        | ✅ `extend(iterable)`     | ✅ `extend()` / `extendleft()`            |
| **最大长度限制**        | ❌ 不支持                    | ✅ `maxlen`（自动丢弃旧数据）                      |
| **旋转操作**          | ❌ 需要切片                   | ✅ `rotate(n)`，O(k)                       |
| **排序**            | ✅ 内置 `sort()`，`sorted()` | ❌ 需先转为 list                              |
| **内存局部性**         | 好（连续数组，cache 友好）         | 较差（链表式分块存储）                              |
| **常见用途**          | 栈（stack）、动态数组、随机访问场景     | 队列（queue）、双端队列（deque）、滑动窗口、流处理           |

---

**内存与性能特征**

* **list**

  * 基于动态数组实现，内存是连续的，**缓存友好**，随机访问性能非常高。
  * 头部操作需要整体移动，效率低。
  * 适合 **栈、随机访问、排序** 场景。

* **deque**

  * 基于双端链表（block linked list），支持 **O(1) 头尾插入/删除**。
  * 不适合随机访问（需要遍历），内存局部性比 `list` 差。
  * 适合 **队列、双端队列、滑动窗口** 场景。

---

**实际性能对比（示意）**

* **尾部 append/pop**
  `list` ≈ `deque`，都很快。
* **头部 append/pop**
  `deque` 明显快很多（O(1) vs O(n)）。
* **随机访问**
  `list` 明显快很多（O(1) vs O(n)）。

---

**总结**

* 如果你需要**随机访问、需要排序、当作栈（后进先出 LIFO）** → 用 `list`。
* 如果你需要**队列（FIFO）、双端队列、高效头尾操作、固定窗口（`maxlen`）**→ 用 `deque`。
* **list = 动态数组**，**deque = 双端队列**，二者各有优势。

---
