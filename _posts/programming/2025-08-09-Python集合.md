---
title: "Python集合操作技巧"
categories: [programming]

math: true
layout: post
---

在 Python 编程和算法题中，`set`、`dict` 和 `Counter` 是高频且非常实用的三种数据结构。它们都基于 **哈希表** 实现，支持 O(1) 平均时间复杂度的查找，但各自的用途、特性和接口有所不同。

---

## 集合(set)

### 基本操作

**创建**
```python
s = set([1, 2, 3, 2])  # 重复元素会被自动去掉
print(s)  # 输出: {1, 2, 3}
print(len(s)) # 输出: 3   

s2 = {4, 5, 6}  # 使用花括号直接定义集合
```

> 注意：空集合只能用 `set()` 创建，不能写成 `{}`，后者是空字典。

---

**集合推导式：**类似列表推导
```python
squares = {x**2 for x in range(5)}  # {0, 1, 4, 9, 16}
```

---

**添加和删除元素**
```python
s.add(4)         # 添加元素
s.remove(2)      # 删除元素，不存在会报错
s.discard(2)     # 删除元素，不存在不会报错
s.clear()        # 清空集合
```

---

**判断元素是否存在**
```python
fruits = {"apple", "banana", "cherry"}

# 判断元素是否在集合中
print("apple" in fruits)   # True
print("orange" in fruits)  # False
```

---

**集合运算**：集合可以进行数学集合操作
```python
a = {1, 2, 3}
b = {3, 4, 5}

print(a | b)   # 并集 {1, 2, 3, 4, 5}
print(a & b)   # 交集 {3}
print(a - b)   # 差集 {1, 2}
print(a ^ b)   # 对称差集（异或）{1, 2, 4, 5}
```

---

**判断子集**
```python
a = {1, 2}
b = {1, 2, 3}

print(a.issubset(b))  # True
print(b.issubset(a))  # False
```

---

**判断超集**
```python
a = {1, 2, 3}
b = {1, 2}

print(a.issuperset(b))  # True
print(b.issuperset(a))  # False
```

---

**判断交集**
```python
a = {1, 2}
b = {3, 4}
c = {2, 3}

print(a.isdisjoint(b))  # True   → 没有公共元素
print(a.isdisjoint(c))  # False  → 公共元素是 2
```

---

## 字典(dict)

字典是 **Python 内置的映射类型**，以 **键值对（key-value）** 的形式存储数据：

* **key**：必须是可哈希的（不可变类型，如字符串、数字、元组），且唯一
* **value**：可以是任意类型，可以重复
* **顺序**：Python 3.7+ 开始，`dict` 会保留插入顺序（但不是排序）
* **底层**：基于哈希表实现，查找、插入、删除的平均时间复杂度为 **O(1)**

```python
d = {'name': 'Alice', 'age': 25}
```

---

### 基本操作

**创建字典**
```python
# 直接定义
d1 = {'a': 1, 'b': 2}

# 使用 dict() 函数
d2 = dict(a=1, b=2)

# 从列表/元组创建
d3 = dict([('a', 1), ('b', 2)])

# 从两个列表/元组配对创建
keys = ['a', 'b', 'c']
values = [1, 2, 3]
d4 = dict(zip(keys, values))
```

---

**从键生成字典**
```python
new_d = dict.fromkeys(['x', 'y', 'z'], 0)
# {'x': 0, 'y': 0, 'z': 0}
```

---

**字典推导式**
```python
# 生成平方字典
squares = {x: x**2 for x in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 过滤
even_squares = {x: x**2 for x in range(5) if x % 2 == 0}
# {0: 0, 2: 4, 4: 16}
```

---

**访问与修改**
```python
d = {'name': 'Alice', 'age': 25}

# 访问
print(d['name'])          # 直接访问，不存在会报 KeyError
print(d.get('gender'))    # 返回 None
print(d.get('gender', '未知'))  # 返回默认值

# 修改或新增
d['age'] = 26
d['city'] = 'Beijing'

# 删除
del d['city']
d.pop('age', None)   # 第二个参数是默认值，不存在时不会报错
d.clear()            # 清空
```

---

**查看元素**
```python
d = {'a': 1, 'b': 2, 'c': 3}

print(d.keys())      # dict_keys(['a', 'b', 'c'])
print(d.values())    # dict_values([1, 2, 3])
print(d.items())     # dict_items([('a', 1), ('b', 2), ('c', 3)])
```

---

**遍历**
```python
for k in d:                  # 遍历键
    print(k)

for k, v in d.items():        # 遍历键值对
    print(k, v)

for v in d.values():          # 遍历值
    print(v)
```

---

### defaultdict用法

在 Python 的 `collections` 模块中，`defaultdict` 允许你为字典的默认值指定一个工厂函数。当你访问一个不存在的键时，它会自动创建一个默认值。

如果你想指定默认值为 `int`，这相当于：

```python
from collections import defaultdict

d = defaultdict(int)
```
此时，每当你访问一个不存在的键时，它会自动赋值为 `0`（因为 `int()` 返回 0）。

你还可以替换成其他类型的工厂函数，比如：
* `defaultdict(list)` → 默认值为 `[]`
* `defaultdict(set)` → 默认值为 `set()`

**指定默认值的方式：**重新定义工厂函数。
```python
from collections import defaultdict

d1 = defaultdict(lambda: float('inf'))

d2 = defaultdict(lambda: [0])
```

---

### OrderedDict用法

`collections.OrderedDict` 在 Python 3.7+ 虽然**不再是“保序字典”的唯一选择**（因为普通 `dict` 也保留插入顺序），但它仍有几个**普通 dict 没有的功能**。

**主要作用**

1. **保留插入顺序（3.6 之前必须用它）**

   * 在 Python 3.6 以前，普通 `dict` 不保证遍历顺序，`OrderedDict` 是唯一能保证顺序的选择。
   * Python 3.7+ 中，这点变成了普通 `dict` 的默认行为，但它的其他功能仍然有用。

2. **提供顺序操作方法**

   * `move_to_end(key, last=True)`
     把某个键移动到末尾或开头，方便实现 LRU、MRU 等缓存结构。

     ```python
     from collections import OrderedDict
     od = OrderedDict(a=1, b=2, c=3)
     od.move_to_end('a')        # {'b': 2, 'c': 3, 'a': 1}
     od.move_to_end('b', last=False)  # {'b': 2, 'c': 3, 'a': 1}
     ```

3. **提供删除头部、尾部元素的操作方法**

   * **`popitem(last=True)`**：弹出并返回一个 `(key, value)`。
   
   **参数**：
     * `last=True`（默认） → 弹出末尾的元素（LIFO）
     * `last=False` → 弹出开头的元素（FIFO）
   
   **用途**：实现 **LRU 缓存**（删除末尾）或 **FIFO 缓存**（删除开头）

    ```python
    od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
    print(od.popitem(last=False))  # ('a', 1)
    print(od)  # OrderedDict([('b', 2), ('c', 3)])
    ```

4. **顺序比较（3.7 以前有区别）**

   * 在旧版本中，两个 `OrderedDict` 比较时，不仅比较键值，还比较顺序。

     ```python
     from collections import OrderedDict
     od1 = OrderedDict([('a', 1), ('b', 2)])
     od2 = OrderedDict([('b', 2), ('a', 1)])
     print(od1 == od2)  # False（顺序不同）
     ```
     
   * 普通 `dict` 在 3.7+ 中也是忽略顺序进行比较，但 `OrderedDict` 依旧是顺序敏感的。
     ```python
     d1 = {'a': 1, 'b': 2}
     d2 = {'b': 2, 'a': 1}
     
     print(d1 == d2)  # True，顺序无关
     ```

4. **可作为队列型映射结构**

   * 因为能在头尾插入/删除键值对，所以它常用来实现：

     * [**LRU 缓存**（最近最少使用）](/posts/字典树_LRU_并查集/#lru)
     * **FIFO 队列**（先进先出映射）

---

**VS 普通 dict**

| 特性              | dict (3.7+) | OrderedDict |
| --------------- | ----------- | ----------- |
| 保留插入顺序          | ✅           | ✅           |
| `move_to_end()` | ❌           | ✅           |
| 顺序敏感比较          | ❌           | ✅           |
| LRU/FIFO 支持     | ❌（需手写）      | ✅（方便）       |
| Python 3.6- 保序  | ❌           | ✅           |

---

## Counter

在数据统计、文本分析、日志处理等场景中，我们经常需要**快速统计元素的出现次数**。
如果用普通字典，需要写一堆 `if key in dict` 的判断，很啰嗦。
Python 标准库的 `collections.Counter` 专门为这种需求设计，让统计变得简单而高效。

`Counter` 是 Python `collections` 模块中的一个**字典子类**，专门用于 **计数可哈希对象**。

* **key**：元素
* **value**：该元素出现的次数
* 默认值为 `0`，不存在的键访问不会报错

```python
from collections import Counter

c = Counter(['a', 'b', 'a', 'c', 'b', 'a'])
print(c)  # Counter({'a': 3, 'b': 2, 'c': 1})
```

---

### 基本操作

**创建 `Counter`**
```python
from collections import Counter

# 从可迭代对象（列表、字符串等）
c1 = Counter('banana')
# Counter({'a': 3, 'n': 2, 'b': 1})

# 从字典
c2 = Counter({'a': 3, 'b': 2})

# 从关键字参数
c3 = Counter(a=3, b=2, c=1)
```

---

**访问和更新**
```python
c = Counter('banana')
print(c['a'])   # 3
print(c['x'])   # 0（不存在不会报错）

# 更新计数
c.update('band')      # 叠加计数
print(c)              # Counter({'a': 4, 'n': 3, 'b': 2, 'd': 1})

# 减少计数
c.subtract('ana')     # 对应计数减去出现次数
print(c)
```

---

**获取最常见元素**
```python
c = Counter('banana')
print(c.most_common(2))
# [('a', 3), ('n', 2)]
```

---

**元素展开**
```python
c = Counter('banana')
print(list(c.elements()))
# ['b', 'a', 'a', 'a', 'n', 'n']
```

---

**集合运算（多重集运算）：**
`Counter` 支持类似集合的交集、并集操作，但它是对计数取 **最小值 / 最大值**。
```python
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)

print(c1 & c2)  # 交集（计数取最小值）=> Counter({'a': 1, 'b': 1})
print(c1 | c2)  # 并集（计数取最大值）=> Counter({'a': 3, 'b': 2})
```

---

### VS 字典

| 特性     | 说明                             |                 |
| ------ | ------------------------------ | --------------- |
| 基于字典实现 | key 是元素，value 是计数              |                 |
| 访问不存在键 | 返回 0，不会报错                      |                 |
| 更新计数   | `update()` 增加，`subtract()` 减少  |                 |
| 排序     | `most_common(n)` 获取出现次数前 n 的元素 |                 |
| 集合运算   | 支持 `&`、\`                      | \`，基于计数的最小值/最大值 |

---

**Counter 相比普通计数字典的优势**

| 功能          | `Counter` 支持        | 普通 `dict` 需要自己实现         |
| ----------- | ------------------- | ------------------------ |
| 自动初始化计数为 0  | ✅                   | ❌（需用 `defaultdict(int)`） |
| 求元素频率       | ✅                   | ✅（但需写循环）                 |
| 获取最多的 n 个元素 | ✅ `.most_common(n)` | ❌（需排序）                   |
| 元素加减、交并操作   | ✅（支持算术运算）           | ❌（需自定义合并逻辑）              |
| 输出所有元素（按频率） | ✅ `.elements()`     | ❌（需构造）                   |
| 比较频率是否相等    | ✅（可直接 `==`）         | ❌（需写比较逻辑）                |

---
